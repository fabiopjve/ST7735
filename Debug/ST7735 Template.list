
E:\ARM\Atollic\ST7735 Template\Debug\ST7735 Template.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000018c  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00003eb8  08000190  08000190  00010190  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000748  08004048  08004048  00014048  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  08004790  08004790  00014790  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  08004798  08004798  00014798  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  0800479c  0800479c  0001479c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         0000000c  20000000  080047a0  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00000110  2000000c  080047ac  0002000c  2**2
                  ALLOC
  8 ._user_heap_stack 00000600  2000011c  080047ac  0002011c  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  0002000c  2**0
                  CONTENTS, READONLY
 10 .debug_info   0000d878  00000000  00000000  0002003c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00002131  00000000  00000000  0002d8b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000070e9  00000000  00000000  0002f9e5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 000009e8  00000000  00000000  00036ad0  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000c58  00000000  00000000  000374b8  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00004c25  00000000  00000000  00038110  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00003364  00000000  00000000  0003cd35  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007e  00000000  00000000  00040099  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00001da0  00000000  00000000  00040118  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000190 <__do_global_dtors_aux>:
 8000190:	b510      	push	{r4, lr}
 8000192:	4c05      	ldr	r4, [pc, #20]	; (80001a8 <__do_global_dtors_aux+0x18>)
 8000194:	7823      	ldrb	r3, [r4, #0]
 8000196:	b933      	cbnz	r3, 80001a6 <__do_global_dtors_aux+0x16>
 8000198:	4b04      	ldr	r3, [pc, #16]	; (80001ac <__do_global_dtors_aux+0x1c>)
 800019a:	b113      	cbz	r3, 80001a2 <__do_global_dtors_aux+0x12>
 800019c:	4804      	ldr	r0, [pc, #16]	; (80001b0 <__do_global_dtors_aux+0x20>)
 800019e:	f3af 8000 	nop.w
 80001a2:	2301      	movs	r3, #1
 80001a4:	7023      	strb	r3, [r4, #0]
 80001a6:	bd10      	pop	{r4, pc}
 80001a8:	2000000c 	.word	0x2000000c
 80001ac:	00000000 	.word	0x00000000
 80001b0:	08004030 	.word	0x08004030

080001b4 <frame_dummy>:
 80001b4:	b508      	push	{r3, lr}
 80001b6:	4b03      	ldr	r3, [pc, #12]	; (80001c4 <frame_dummy+0x10>)
 80001b8:	b11b      	cbz	r3, 80001c2 <frame_dummy+0xe>
 80001ba:	4903      	ldr	r1, [pc, #12]	; (80001c8 <frame_dummy+0x14>)
 80001bc:	4803      	ldr	r0, [pc, #12]	; (80001cc <frame_dummy+0x18>)
 80001be:	f3af 8000 	nop.w
 80001c2:	bd08      	pop	{r3, pc}
 80001c4:	00000000 	.word	0x00000000
 80001c8:	20000010 	.word	0x20000010
 80001cc:	08004030 	.word	0x08004030

080001d0 <strlen>:
 80001d0:	4603      	mov	r3, r0
 80001d2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001d6:	2a00      	cmp	r2, #0
 80001d8:	d1fb      	bne.n	80001d2 <strlen+0x2>
 80001da:	1a18      	subs	r0, r3, r0
 80001dc:	3801      	subs	r0, #1
 80001de:	4770      	bx	lr

080001e0 <__aeabi_drsub>:
 80001e0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80001e4:	e002      	b.n	80001ec <__adddf3>
 80001e6:	bf00      	nop

080001e8 <__aeabi_dsub>:
 80001e8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080001ec <__adddf3>:
 80001ec:	b530      	push	{r4, r5, lr}
 80001ee:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80001f2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80001f6:	ea94 0f05 	teq	r4, r5
 80001fa:	bf08      	it	eq
 80001fc:	ea90 0f02 	teqeq	r0, r2
 8000200:	bf1f      	itttt	ne
 8000202:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000206:	ea55 0c02 	orrsne.w	ip, r5, r2
 800020a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800020e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000212:	f000 80e2 	beq.w	80003da <__adddf3+0x1ee>
 8000216:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800021a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800021e:	bfb8      	it	lt
 8000220:	426d      	neglt	r5, r5
 8000222:	dd0c      	ble.n	800023e <__adddf3+0x52>
 8000224:	442c      	add	r4, r5
 8000226:	ea80 0202 	eor.w	r2, r0, r2
 800022a:	ea81 0303 	eor.w	r3, r1, r3
 800022e:	ea82 0000 	eor.w	r0, r2, r0
 8000232:	ea83 0101 	eor.w	r1, r3, r1
 8000236:	ea80 0202 	eor.w	r2, r0, r2
 800023a:	ea81 0303 	eor.w	r3, r1, r3
 800023e:	2d36      	cmp	r5, #54	; 0x36
 8000240:	bf88      	it	hi
 8000242:	bd30      	pophi	{r4, r5, pc}
 8000244:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000248:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800024c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000250:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000254:	d002      	beq.n	800025c <__adddf3+0x70>
 8000256:	4240      	negs	r0, r0
 8000258:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800025c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000260:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000264:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000268:	d002      	beq.n	8000270 <__adddf3+0x84>
 800026a:	4252      	negs	r2, r2
 800026c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000270:	ea94 0f05 	teq	r4, r5
 8000274:	f000 80a7 	beq.w	80003c6 <__adddf3+0x1da>
 8000278:	f1a4 0401 	sub.w	r4, r4, #1
 800027c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000280:	db0d      	blt.n	800029e <__adddf3+0xb2>
 8000282:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000286:	fa22 f205 	lsr.w	r2, r2, r5
 800028a:	1880      	adds	r0, r0, r2
 800028c:	f141 0100 	adc.w	r1, r1, #0
 8000290:	fa03 f20e 	lsl.w	r2, r3, lr
 8000294:	1880      	adds	r0, r0, r2
 8000296:	fa43 f305 	asr.w	r3, r3, r5
 800029a:	4159      	adcs	r1, r3
 800029c:	e00e      	b.n	80002bc <__adddf3+0xd0>
 800029e:	f1a5 0520 	sub.w	r5, r5, #32
 80002a2:	f10e 0e20 	add.w	lr, lr, #32
 80002a6:	2a01      	cmp	r2, #1
 80002a8:	fa03 fc0e 	lsl.w	ip, r3, lr
 80002ac:	bf28      	it	cs
 80002ae:	f04c 0c02 	orrcs.w	ip, ip, #2
 80002b2:	fa43 f305 	asr.w	r3, r3, r5
 80002b6:	18c0      	adds	r0, r0, r3
 80002b8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80002bc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80002c0:	d507      	bpl.n	80002d2 <__adddf3+0xe6>
 80002c2:	f04f 0e00 	mov.w	lr, #0
 80002c6:	f1dc 0c00 	rsbs	ip, ip, #0
 80002ca:	eb7e 0000 	sbcs.w	r0, lr, r0
 80002ce:	eb6e 0101 	sbc.w	r1, lr, r1
 80002d2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80002d6:	d31b      	bcc.n	8000310 <__adddf3+0x124>
 80002d8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80002dc:	d30c      	bcc.n	80002f8 <__adddf3+0x10c>
 80002de:	0849      	lsrs	r1, r1, #1
 80002e0:	ea5f 0030 	movs.w	r0, r0, rrx
 80002e4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80002e8:	f104 0401 	add.w	r4, r4, #1
 80002ec:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80002f0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80002f4:	f080 809a 	bcs.w	800042c <__adddf3+0x240>
 80002f8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80002fc:	bf08      	it	eq
 80002fe:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000302:	f150 0000 	adcs.w	r0, r0, #0
 8000306:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800030a:	ea41 0105 	orr.w	r1, r1, r5
 800030e:	bd30      	pop	{r4, r5, pc}
 8000310:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000314:	4140      	adcs	r0, r0
 8000316:	eb41 0101 	adc.w	r1, r1, r1
 800031a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800031e:	f1a4 0401 	sub.w	r4, r4, #1
 8000322:	d1e9      	bne.n	80002f8 <__adddf3+0x10c>
 8000324:	f091 0f00 	teq	r1, #0
 8000328:	bf04      	itt	eq
 800032a:	4601      	moveq	r1, r0
 800032c:	2000      	moveq	r0, #0
 800032e:	fab1 f381 	clz	r3, r1
 8000332:	bf08      	it	eq
 8000334:	3320      	addeq	r3, #32
 8000336:	f1a3 030b 	sub.w	r3, r3, #11
 800033a:	f1b3 0220 	subs.w	r2, r3, #32
 800033e:	da0c      	bge.n	800035a <__adddf3+0x16e>
 8000340:	320c      	adds	r2, #12
 8000342:	dd08      	ble.n	8000356 <__adddf3+0x16a>
 8000344:	f102 0c14 	add.w	ip, r2, #20
 8000348:	f1c2 020c 	rsb	r2, r2, #12
 800034c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000350:	fa21 f102 	lsr.w	r1, r1, r2
 8000354:	e00c      	b.n	8000370 <__adddf3+0x184>
 8000356:	f102 0214 	add.w	r2, r2, #20
 800035a:	bfd8      	it	le
 800035c:	f1c2 0c20 	rsble	ip, r2, #32
 8000360:	fa01 f102 	lsl.w	r1, r1, r2
 8000364:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000368:	bfdc      	itt	le
 800036a:	ea41 010c 	orrle.w	r1, r1, ip
 800036e:	4090      	lslle	r0, r2
 8000370:	1ae4      	subs	r4, r4, r3
 8000372:	bfa2      	ittt	ge
 8000374:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000378:	4329      	orrge	r1, r5
 800037a:	bd30      	popge	{r4, r5, pc}
 800037c:	ea6f 0404 	mvn.w	r4, r4
 8000380:	3c1f      	subs	r4, #31
 8000382:	da1c      	bge.n	80003be <__adddf3+0x1d2>
 8000384:	340c      	adds	r4, #12
 8000386:	dc0e      	bgt.n	80003a6 <__adddf3+0x1ba>
 8000388:	f104 0414 	add.w	r4, r4, #20
 800038c:	f1c4 0220 	rsb	r2, r4, #32
 8000390:	fa20 f004 	lsr.w	r0, r0, r4
 8000394:	fa01 f302 	lsl.w	r3, r1, r2
 8000398:	ea40 0003 	orr.w	r0, r0, r3
 800039c:	fa21 f304 	lsr.w	r3, r1, r4
 80003a0:	ea45 0103 	orr.w	r1, r5, r3
 80003a4:	bd30      	pop	{r4, r5, pc}
 80003a6:	f1c4 040c 	rsb	r4, r4, #12
 80003aa:	f1c4 0220 	rsb	r2, r4, #32
 80003ae:	fa20 f002 	lsr.w	r0, r0, r2
 80003b2:	fa01 f304 	lsl.w	r3, r1, r4
 80003b6:	ea40 0003 	orr.w	r0, r0, r3
 80003ba:	4629      	mov	r1, r5
 80003bc:	bd30      	pop	{r4, r5, pc}
 80003be:	fa21 f004 	lsr.w	r0, r1, r4
 80003c2:	4629      	mov	r1, r5
 80003c4:	bd30      	pop	{r4, r5, pc}
 80003c6:	f094 0f00 	teq	r4, #0
 80003ca:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80003ce:	bf06      	itte	eq
 80003d0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80003d4:	3401      	addeq	r4, #1
 80003d6:	3d01      	subne	r5, #1
 80003d8:	e74e      	b.n	8000278 <__adddf3+0x8c>
 80003da:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80003de:	bf18      	it	ne
 80003e0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80003e4:	d029      	beq.n	800043a <__adddf3+0x24e>
 80003e6:	ea94 0f05 	teq	r4, r5
 80003ea:	bf08      	it	eq
 80003ec:	ea90 0f02 	teqeq	r0, r2
 80003f0:	d005      	beq.n	80003fe <__adddf3+0x212>
 80003f2:	ea54 0c00 	orrs.w	ip, r4, r0
 80003f6:	bf04      	itt	eq
 80003f8:	4619      	moveq	r1, r3
 80003fa:	4610      	moveq	r0, r2
 80003fc:	bd30      	pop	{r4, r5, pc}
 80003fe:	ea91 0f03 	teq	r1, r3
 8000402:	bf1e      	ittt	ne
 8000404:	2100      	movne	r1, #0
 8000406:	2000      	movne	r0, #0
 8000408:	bd30      	popne	{r4, r5, pc}
 800040a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800040e:	d105      	bne.n	800041c <__adddf3+0x230>
 8000410:	0040      	lsls	r0, r0, #1
 8000412:	4149      	adcs	r1, r1
 8000414:	bf28      	it	cs
 8000416:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800041a:	bd30      	pop	{r4, r5, pc}
 800041c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000420:	bf3c      	itt	cc
 8000422:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8000426:	bd30      	popcc	{r4, r5, pc}
 8000428:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800042c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000430:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000434:	f04f 0000 	mov.w	r0, #0
 8000438:	bd30      	pop	{r4, r5, pc}
 800043a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800043e:	bf1a      	itte	ne
 8000440:	4619      	movne	r1, r3
 8000442:	4610      	movne	r0, r2
 8000444:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000448:	bf1c      	itt	ne
 800044a:	460b      	movne	r3, r1
 800044c:	4602      	movne	r2, r0
 800044e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000452:	bf06      	itte	eq
 8000454:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000458:	ea91 0f03 	teqeq	r1, r3
 800045c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000460:	bd30      	pop	{r4, r5, pc}
 8000462:	bf00      	nop

08000464 <__aeabi_ui2d>:
 8000464:	f090 0f00 	teq	r0, #0
 8000468:	bf04      	itt	eq
 800046a:	2100      	moveq	r1, #0
 800046c:	4770      	bxeq	lr
 800046e:	b530      	push	{r4, r5, lr}
 8000470:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000474:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000478:	f04f 0500 	mov.w	r5, #0
 800047c:	f04f 0100 	mov.w	r1, #0
 8000480:	e750      	b.n	8000324 <__adddf3+0x138>
 8000482:	bf00      	nop

08000484 <__aeabi_i2d>:
 8000484:	f090 0f00 	teq	r0, #0
 8000488:	bf04      	itt	eq
 800048a:	2100      	moveq	r1, #0
 800048c:	4770      	bxeq	lr
 800048e:	b530      	push	{r4, r5, lr}
 8000490:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000494:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000498:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800049c:	bf48      	it	mi
 800049e:	4240      	negmi	r0, r0
 80004a0:	f04f 0100 	mov.w	r1, #0
 80004a4:	e73e      	b.n	8000324 <__adddf3+0x138>
 80004a6:	bf00      	nop

080004a8 <__aeabi_f2d>:
 80004a8:	0042      	lsls	r2, r0, #1
 80004aa:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80004ae:	ea4f 0131 	mov.w	r1, r1, rrx
 80004b2:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80004b6:	bf1f      	itttt	ne
 80004b8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80004bc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80004c0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80004c4:	4770      	bxne	lr
 80004c6:	f092 0f00 	teq	r2, #0
 80004ca:	bf14      	ite	ne
 80004cc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80004d0:	4770      	bxeq	lr
 80004d2:	b530      	push	{r4, r5, lr}
 80004d4:	f44f 7460 	mov.w	r4, #896	; 0x380
 80004d8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004dc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80004e0:	e720      	b.n	8000324 <__adddf3+0x138>
 80004e2:	bf00      	nop

080004e4 <__aeabi_ul2d>:
 80004e4:	ea50 0201 	orrs.w	r2, r0, r1
 80004e8:	bf08      	it	eq
 80004ea:	4770      	bxeq	lr
 80004ec:	b530      	push	{r4, r5, lr}
 80004ee:	f04f 0500 	mov.w	r5, #0
 80004f2:	e00a      	b.n	800050a <__aeabi_l2d+0x16>

080004f4 <__aeabi_l2d>:
 80004f4:	ea50 0201 	orrs.w	r2, r0, r1
 80004f8:	bf08      	it	eq
 80004fa:	4770      	bxeq	lr
 80004fc:	b530      	push	{r4, r5, lr}
 80004fe:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000502:	d502      	bpl.n	800050a <__aeabi_l2d+0x16>
 8000504:	4240      	negs	r0, r0
 8000506:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800050a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800050e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000512:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000516:	f43f aedc 	beq.w	80002d2 <__adddf3+0xe6>
 800051a:	f04f 0203 	mov.w	r2, #3
 800051e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000522:	bf18      	it	ne
 8000524:	3203      	addne	r2, #3
 8000526:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800052a:	bf18      	it	ne
 800052c:	3203      	addne	r2, #3
 800052e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000532:	f1c2 0320 	rsb	r3, r2, #32
 8000536:	fa00 fc03 	lsl.w	ip, r0, r3
 800053a:	fa20 f002 	lsr.w	r0, r0, r2
 800053e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000542:	ea40 000e 	orr.w	r0, r0, lr
 8000546:	fa21 f102 	lsr.w	r1, r1, r2
 800054a:	4414      	add	r4, r2
 800054c:	e6c1      	b.n	80002d2 <__adddf3+0xe6>
 800054e:	bf00      	nop

08000550 <__aeabi_dmul>:
 8000550:	b570      	push	{r4, r5, r6, lr}
 8000552:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000556:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800055a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800055e:	bf1d      	ittte	ne
 8000560:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000564:	ea94 0f0c 	teqne	r4, ip
 8000568:	ea95 0f0c 	teqne	r5, ip
 800056c:	f000 f8de 	bleq	800072c <__aeabi_dmul+0x1dc>
 8000570:	442c      	add	r4, r5
 8000572:	ea81 0603 	eor.w	r6, r1, r3
 8000576:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800057a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800057e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000582:	bf18      	it	ne
 8000584:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000588:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800058c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000590:	d038      	beq.n	8000604 <__aeabi_dmul+0xb4>
 8000592:	fba0 ce02 	umull	ip, lr, r0, r2
 8000596:	f04f 0500 	mov.w	r5, #0
 800059a:	fbe1 e502 	umlal	lr, r5, r1, r2
 800059e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80005a2:	fbe0 e503 	umlal	lr, r5, r0, r3
 80005a6:	f04f 0600 	mov.w	r6, #0
 80005aa:	fbe1 5603 	umlal	r5, r6, r1, r3
 80005ae:	f09c 0f00 	teq	ip, #0
 80005b2:	bf18      	it	ne
 80005b4:	f04e 0e01 	orrne.w	lr, lr, #1
 80005b8:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80005bc:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80005c0:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80005c4:	d204      	bcs.n	80005d0 <__aeabi_dmul+0x80>
 80005c6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80005ca:	416d      	adcs	r5, r5
 80005cc:	eb46 0606 	adc.w	r6, r6, r6
 80005d0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80005d4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80005d8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80005dc:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80005e0:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80005e4:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80005e8:	bf88      	it	hi
 80005ea:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80005ee:	d81e      	bhi.n	800062e <__aeabi_dmul+0xde>
 80005f0:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80005f4:	bf08      	it	eq
 80005f6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80005fa:	f150 0000 	adcs.w	r0, r0, #0
 80005fe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000602:	bd70      	pop	{r4, r5, r6, pc}
 8000604:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000608:	ea46 0101 	orr.w	r1, r6, r1
 800060c:	ea40 0002 	orr.w	r0, r0, r2
 8000610:	ea81 0103 	eor.w	r1, r1, r3
 8000614:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000618:	bfc2      	ittt	gt
 800061a:	ebd4 050c 	rsbsgt	r5, r4, ip
 800061e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000622:	bd70      	popgt	{r4, r5, r6, pc}
 8000624:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000628:	f04f 0e00 	mov.w	lr, #0
 800062c:	3c01      	subs	r4, #1
 800062e:	f300 80ab 	bgt.w	8000788 <__aeabi_dmul+0x238>
 8000632:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8000636:	bfde      	ittt	le
 8000638:	2000      	movle	r0, #0
 800063a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800063e:	bd70      	pople	{r4, r5, r6, pc}
 8000640:	f1c4 0400 	rsb	r4, r4, #0
 8000644:	3c20      	subs	r4, #32
 8000646:	da35      	bge.n	80006b4 <__aeabi_dmul+0x164>
 8000648:	340c      	adds	r4, #12
 800064a:	dc1b      	bgt.n	8000684 <__aeabi_dmul+0x134>
 800064c:	f104 0414 	add.w	r4, r4, #20
 8000650:	f1c4 0520 	rsb	r5, r4, #32
 8000654:	fa00 f305 	lsl.w	r3, r0, r5
 8000658:	fa20 f004 	lsr.w	r0, r0, r4
 800065c:	fa01 f205 	lsl.w	r2, r1, r5
 8000660:	ea40 0002 	orr.w	r0, r0, r2
 8000664:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000668:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800066c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000670:	fa21 f604 	lsr.w	r6, r1, r4
 8000674:	eb42 0106 	adc.w	r1, r2, r6
 8000678:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800067c:	bf08      	it	eq
 800067e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000682:	bd70      	pop	{r4, r5, r6, pc}
 8000684:	f1c4 040c 	rsb	r4, r4, #12
 8000688:	f1c4 0520 	rsb	r5, r4, #32
 800068c:	fa00 f304 	lsl.w	r3, r0, r4
 8000690:	fa20 f005 	lsr.w	r0, r0, r5
 8000694:	fa01 f204 	lsl.w	r2, r1, r4
 8000698:	ea40 0002 	orr.w	r0, r0, r2
 800069c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80006a0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80006a4:	f141 0100 	adc.w	r1, r1, #0
 80006a8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80006ac:	bf08      	it	eq
 80006ae:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80006b2:	bd70      	pop	{r4, r5, r6, pc}
 80006b4:	f1c4 0520 	rsb	r5, r4, #32
 80006b8:	fa00 f205 	lsl.w	r2, r0, r5
 80006bc:	ea4e 0e02 	orr.w	lr, lr, r2
 80006c0:	fa20 f304 	lsr.w	r3, r0, r4
 80006c4:	fa01 f205 	lsl.w	r2, r1, r5
 80006c8:	ea43 0302 	orr.w	r3, r3, r2
 80006cc:	fa21 f004 	lsr.w	r0, r1, r4
 80006d0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80006d4:	fa21 f204 	lsr.w	r2, r1, r4
 80006d8:	ea20 0002 	bic.w	r0, r0, r2
 80006dc:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80006e0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80006e4:	bf08      	it	eq
 80006e6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80006ea:	bd70      	pop	{r4, r5, r6, pc}
 80006ec:	f094 0f00 	teq	r4, #0
 80006f0:	d10f      	bne.n	8000712 <__aeabi_dmul+0x1c2>
 80006f2:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80006f6:	0040      	lsls	r0, r0, #1
 80006f8:	eb41 0101 	adc.w	r1, r1, r1
 80006fc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000700:	bf08      	it	eq
 8000702:	3c01      	subeq	r4, #1
 8000704:	d0f7      	beq.n	80006f6 <__aeabi_dmul+0x1a6>
 8000706:	ea41 0106 	orr.w	r1, r1, r6
 800070a:	f095 0f00 	teq	r5, #0
 800070e:	bf18      	it	ne
 8000710:	4770      	bxne	lr
 8000712:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8000716:	0052      	lsls	r2, r2, #1
 8000718:	eb43 0303 	adc.w	r3, r3, r3
 800071c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000720:	bf08      	it	eq
 8000722:	3d01      	subeq	r5, #1
 8000724:	d0f7      	beq.n	8000716 <__aeabi_dmul+0x1c6>
 8000726:	ea43 0306 	orr.w	r3, r3, r6
 800072a:	4770      	bx	lr
 800072c:	ea94 0f0c 	teq	r4, ip
 8000730:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000734:	bf18      	it	ne
 8000736:	ea95 0f0c 	teqne	r5, ip
 800073a:	d00c      	beq.n	8000756 <__aeabi_dmul+0x206>
 800073c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000740:	bf18      	it	ne
 8000742:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000746:	d1d1      	bne.n	80006ec <__aeabi_dmul+0x19c>
 8000748:	ea81 0103 	eor.w	r1, r1, r3
 800074c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000750:	f04f 0000 	mov.w	r0, #0
 8000754:	bd70      	pop	{r4, r5, r6, pc}
 8000756:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800075a:	bf06      	itte	eq
 800075c:	4610      	moveq	r0, r2
 800075e:	4619      	moveq	r1, r3
 8000760:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000764:	d019      	beq.n	800079a <__aeabi_dmul+0x24a>
 8000766:	ea94 0f0c 	teq	r4, ip
 800076a:	d102      	bne.n	8000772 <__aeabi_dmul+0x222>
 800076c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000770:	d113      	bne.n	800079a <__aeabi_dmul+0x24a>
 8000772:	ea95 0f0c 	teq	r5, ip
 8000776:	d105      	bne.n	8000784 <__aeabi_dmul+0x234>
 8000778:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800077c:	bf1c      	itt	ne
 800077e:	4610      	movne	r0, r2
 8000780:	4619      	movne	r1, r3
 8000782:	d10a      	bne.n	800079a <__aeabi_dmul+0x24a>
 8000784:	ea81 0103 	eor.w	r1, r1, r3
 8000788:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800078c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000790:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000794:	f04f 0000 	mov.w	r0, #0
 8000798:	bd70      	pop	{r4, r5, r6, pc}
 800079a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800079e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80007a2:	bd70      	pop	{r4, r5, r6, pc}

080007a4 <__aeabi_ddiv>:
 80007a4:	b570      	push	{r4, r5, r6, lr}
 80007a6:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80007aa:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80007ae:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80007b2:	bf1d      	ittte	ne
 80007b4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80007b8:	ea94 0f0c 	teqne	r4, ip
 80007bc:	ea95 0f0c 	teqne	r5, ip
 80007c0:	f000 f8a7 	bleq	8000912 <__aeabi_ddiv+0x16e>
 80007c4:	eba4 0405 	sub.w	r4, r4, r5
 80007c8:	ea81 0e03 	eor.w	lr, r1, r3
 80007cc:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80007d0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80007d4:	f000 8088 	beq.w	80008e8 <__aeabi_ddiv+0x144>
 80007d8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80007dc:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80007e0:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80007e4:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80007e8:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80007ec:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80007f0:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80007f4:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80007f8:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80007fc:	429d      	cmp	r5, r3
 80007fe:	bf08      	it	eq
 8000800:	4296      	cmpeq	r6, r2
 8000802:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8000806:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800080a:	d202      	bcs.n	8000812 <__aeabi_ddiv+0x6e>
 800080c:	085b      	lsrs	r3, r3, #1
 800080e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000812:	1ab6      	subs	r6, r6, r2
 8000814:	eb65 0503 	sbc.w	r5, r5, r3
 8000818:	085b      	lsrs	r3, r3, #1
 800081a:	ea4f 0232 	mov.w	r2, r2, rrx
 800081e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8000822:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8000826:	ebb6 0e02 	subs.w	lr, r6, r2
 800082a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800082e:	bf22      	ittt	cs
 8000830:	1ab6      	subcs	r6, r6, r2
 8000832:	4675      	movcs	r5, lr
 8000834:	ea40 000c 	orrcs.w	r0, r0, ip
 8000838:	085b      	lsrs	r3, r3, #1
 800083a:	ea4f 0232 	mov.w	r2, r2, rrx
 800083e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000842:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000846:	bf22      	ittt	cs
 8000848:	1ab6      	subcs	r6, r6, r2
 800084a:	4675      	movcs	r5, lr
 800084c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000850:	085b      	lsrs	r3, r3, #1
 8000852:	ea4f 0232 	mov.w	r2, r2, rrx
 8000856:	ebb6 0e02 	subs.w	lr, r6, r2
 800085a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800085e:	bf22      	ittt	cs
 8000860:	1ab6      	subcs	r6, r6, r2
 8000862:	4675      	movcs	r5, lr
 8000864:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000868:	085b      	lsrs	r3, r3, #1
 800086a:	ea4f 0232 	mov.w	r2, r2, rrx
 800086e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000872:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000876:	bf22      	ittt	cs
 8000878:	1ab6      	subcs	r6, r6, r2
 800087a:	4675      	movcs	r5, lr
 800087c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000880:	ea55 0e06 	orrs.w	lr, r5, r6
 8000884:	d018      	beq.n	80008b8 <__aeabi_ddiv+0x114>
 8000886:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800088a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800088e:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000892:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000896:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800089a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800089e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80008a2:	d1c0      	bne.n	8000826 <__aeabi_ddiv+0x82>
 80008a4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80008a8:	d10b      	bne.n	80008c2 <__aeabi_ddiv+0x11e>
 80008aa:	ea41 0100 	orr.w	r1, r1, r0
 80008ae:	f04f 0000 	mov.w	r0, #0
 80008b2:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80008b6:	e7b6      	b.n	8000826 <__aeabi_ddiv+0x82>
 80008b8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80008bc:	bf04      	itt	eq
 80008be:	4301      	orreq	r1, r0
 80008c0:	2000      	moveq	r0, #0
 80008c2:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80008c6:	bf88      	it	hi
 80008c8:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80008cc:	f63f aeaf 	bhi.w	800062e <__aeabi_dmul+0xde>
 80008d0:	ebb5 0c03 	subs.w	ip, r5, r3
 80008d4:	bf04      	itt	eq
 80008d6:	ebb6 0c02 	subseq.w	ip, r6, r2
 80008da:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80008de:	f150 0000 	adcs.w	r0, r0, #0
 80008e2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80008e6:	bd70      	pop	{r4, r5, r6, pc}
 80008e8:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80008ec:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80008f0:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80008f4:	bfc2      	ittt	gt
 80008f6:	ebd4 050c 	rsbsgt	r5, r4, ip
 80008fa:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80008fe:	bd70      	popgt	{r4, r5, r6, pc}
 8000900:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000904:	f04f 0e00 	mov.w	lr, #0
 8000908:	3c01      	subs	r4, #1
 800090a:	e690      	b.n	800062e <__aeabi_dmul+0xde>
 800090c:	ea45 0e06 	orr.w	lr, r5, r6
 8000910:	e68d      	b.n	800062e <__aeabi_dmul+0xde>
 8000912:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000916:	ea94 0f0c 	teq	r4, ip
 800091a:	bf08      	it	eq
 800091c:	ea95 0f0c 	teqeq	r5, ip
 8000920:	f43f af3b 	beq.w	800079a <__aeabi_dmul+0x24a>
 8000924:	ea94 0f0c 	teq	r4, ip
 8000928:	d10a      	bne.n	8000940 <__aeabi_ddiv+0x19c>
 800092a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800092e:	f47f af34 	bne.w	800079a <__aeabi_dmul+0x24a>
 8000932:	ea95 0f0c 	teq	r5, ip
 8000936:	f47f af25 	bne.w	8000784 <__aeabi_dmul+0x234>
 800093a:	4610      	mov	r0, r2
 800093c:	4619      	mov	r1, r3
 800093e:	e72c      	b.n	800079a <__aeabi_dmul+0x24a>
 8000940:	ea95 0f0c 	teq	r5, ip
 8000944:	d106      	bne.n	8000954 <__aeabi_ddiv+0x1b0>
 8000946:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800094a:	f43f aefd 	beq.w	8000748 <__aeabi_dmul+0x1f8>
 800094e:	4610      	mov	r0, r2
 8000950:	4619      	mov	r1, r3
 8000952:	e722      	b.n	800079a <__aeabi_dmul+0x24a>
 8000954:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000958:	bf18      	it	ne
 800095a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800095e:	f47f aec5 	bne.w	80006ec <__aeabi_dmul+0x19c>
 8000962:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000966:	f47f af0d 	bne.w	8000784 <__aeabi_dmul+0x234>
 800096a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800096e:	f47f aeeb 	bne.w	8000748 <__aeabi_dmul+0x1f8>
 8000972:	e712      	b.n	800079a <__aeabi_dmul+0x24a>

08000974 <__gedf2>:
 8000974:	f04f 3cff 	mov.w	ip, #4294967295
 8000978:	e006      	b.n	8000988 <__cmpdf2+0x4>
 800097a:	bf00      	nop

0800097c <__ledf2>:
 800097c:	f04f 0c01 	mov.w	ip, #1
 8000980:	e002      	b.n	8000988 <__cmpdf2+0x4>
 8000982:	bf00      	nop

08000984 <__cmpdf2>:
 8000984:	f04f 0c01 	mov.w	ip, #1
 8000988:	f84d cd04 	str.w	ip, [sp, #-4]!
 800098c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000990:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000994:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000998:	bf18      	it	ne
 800099a:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 800099e:	d01b      	beq.n	80009d8 <__cmpdf2+0x54>
 80009a0:	b001      	add	sp, #4
 80009a2:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 80009a6:	bf0c      	ite	eq
 80009a8:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 80009ac:	ea91 0f03 	teqne	r1, r3
 80009b0:	bf02      	ittt	eq
 80009b2:	ea90 0f02 	teqeq	r0, r2
 80009b6:	2000      	moveq	r0, #0
 80009b8:	4770      	bxeq	lr
 80009ba:	f110 0f00 	cmn.w	r0, #0
 80009be:	ea91 0f03 	teq	r1, r3
 80009c2:	bf58      	it	pl
 80009c4:	4299      	cmppl	r1, r3
 80009c6:	bf08      	it	eq
 80009c8:	4290      	cmpeq	r0, r2
 80009ca:	bf2c      	ite	cs
 80009cc:	17d8      	asrcs	r0, r3, #31
 80009ce:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 80009d2:	f040 0001 	orr.w	r0, r0, #1
 80009d6:	4770      	bx	lr
 80009d8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80009dc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80009e0:	d102      	bne.n	80009e8 <__cmpdf2+0x64>
 80009e2:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80009e6:	d107      	bne.n	80009f8 <__cmpdf2+0x74>
 80009e8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80009ec:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80009f0:	d1d6      	bne.n	80009a0 <__cmpdf2+0x1c>
 80009f2:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 80009f6:	d0d3      	beq.n	80009a0 <__cmpdf2+0x1c>
 80009f8:	f85d 0b04 	ldr.w	r0, [sp], #4
 80009fc:	4770      	bx	lr
 80009fe:	bf00      	nop

08000a00 <__aeabi_cdrcmple>:
 8000a00:	4684      	mov	ip, r0
 8000a02:	4610      	mov	r0, r2
 8000a04:	4662      	mov	r2, ip
 8000a06:	468c      	mov	ip, r1
 8000a08:	4619      	mov	r1, r3
 8000a0a:	4663      	mov	r3, ip
 8000a0c:	e000      	b.n	8000a10 <__aeabi_cdcmpeq>
 8000a0e:	bf00      	nop

08000a10 <__aeabi_cdcmpeq>:
 8000a10:	b501      	push	{r0, lr}
 8000a12:	f7ff ffb7 	bl	8000984 <__cmpdf2>
 8000a16:	2800      	cmp	r0, #0
 8000a18:	bf48      	it	mi
 8000a1a:	f110 0f00 	cmnmi.w	r0, #0
 8000a1e:	bd01      	pop	{r0, pc}

08000a20 <__aeabi_dcmpeq>:
 8000a20:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a24:	f7ff fff4 	bl	8000a10 <__aeabi_cdcmpeq>
 8000a28:	bf0c      	ite	eq
 8000a2a:	2001      	moveq	r0, #1
 8000a2c:	2000      	movne	r0, #0
 8000a2e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a32:	bf00      	nop

08000a34 <__aeabi_dcmplt>:
 8000a34:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a38:	f7ff ffea 	bl	8000a10 <__aeabi_cdcmpeq>
 8000a3c:	bf34      	ite	cc
 8000a3e:	2001      	movcc	r0, #1
 8000a40:	2000      	movcs	r0, #0
 8000a42:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a46:	bf00      	nop

08000a48 <__aeabi_dcmple>:
 8000a48:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a4c:	f7ff ffe0 	bl	8000a10 <__aeabi_cdcmpeq>
 8000a50:	bf94      	ite	ls
 8000a52:	2001      	movls	r0, #1
 8000a54:	2000      	movhi	r0, #0
 8000a56:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a5a:	bf00      	nop

08000a5c <__aeabi_dcmpge>:
 8000a5c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a60:	f7ff ffce 	bl	8000a00 <__aeabi_cdrcmple>
 8000a64:	bf94      	ite	ls
 8000a66:	2001      	movls	r0, #1
 8000a68:	2000      	movhi	r0, #0
 8000a6a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a6e:	bf00      	nop

08000a70 <__aeabi_dcmpgt>:
 8000a70:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a74:	f7ff ffc4 	bl	8000a00 <__aeabi_cdrcmple>
 8000a78:	bf34      	ite	cc
 8000a7a:	2001      	movcc	r0, #1
 8000a7c:	2000      	movcs	r0, #0
 8000a7e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a82:	bf00      	nop

08000a84 <__aeabi_d2iz>:
 8000a84:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a88:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000a8c:	d215      	bcs.n	8000aba <__aeabi_d2iz+0x36>
 8000a8e:	d511      	bpl.n	8000ab4 <__aeabi_d2iz+0x30>
 8000a90:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000a94:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000a98:	d912      	bls.n	8000ac0 <__aeabi_d2iz+0x3c>
 8000a9a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000a9e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000aa2:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000aa6:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000aaa:	fa23 f002 	lsr.w	r0, r3, r2
 8000aae:	bf18      	it	ne
 8000ab0:	4240      	negne	r0, r0
 8000ab2:	4770      	bx	lr
 8000ab4:	f04f 0000 	mov.w	r0, #0
 8000ab8:	4770      	bx	lr
 8000aba:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000abe:	d105      	bne.n	8000acc <__aeabi_d2iz+0x48>
 8000ac0:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000ac4:	bf08      	it	eq
 8000ac6:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000aca:	4770      	bx	lr
 8000acc:	f04f 0000 	mov.w	r0, #0
 8000ad0:	4770      	bx	lr
 8000ad2:	bf00      	nop

08000ad4 <__aeabi_uldivmod>:
 8000ad4:	b953      	cbnz	r3, 8000aec <__aeabi_uldivmod+0x18>
 8000ad6:	b94a      	cbnz	r2, 8000aec <__aeabi_uldivmod+0x18>
 8000ad8:	2900      	cmp	r1, #0
 8000ada:	bf08      	it	eq
 8000adc:	2800      	cmpeq	r0, #0
 8000ade:	bf1c      	itt	ne
 8000ae0:	f04f 31ff 	movne.w	r1, #4294967295
 8000ae4:	f04f 30ff 	movne.w	r0, #4294967295
 8000ae8:	f000 b97e 	b.w	8000de8 <__aeabi_idiv0>
 8000aec:	f1ad 0c08 	sub.w	ip, sp, #8
 8000af0:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000af4:	f000 f806 	bl	8000b04 <__udivmoddi4>
 8000af8:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000afc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000b00:	b004      	add	sp, #16
 8000b02:	4770      	bx	lr

08000b04 <__udivmoddi4>:
 8000b04:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000b08:	468c      	mov	ip, r1
 8000b0a:	460e      	mov	r6, r1
 8000b0c:	4604      	mov	r4, r0
 8000b0e:	9d08      	ldr	r5, [sp, #32]
 8000b10:	2b00      	cmp	r3, #0
 8000b12:	d150      	bne.n	8000bb6 <__udivmoddi4+0xb2>
 8000b14:	428a      	cmp	r2, r1
 8000b16:	4617      	mov	r7, r2
 8000b18:	d96c      	bls.n	8000bf4 <__udivmoddi4+0xf0>
 8000b1a:	fab2 fe82 	clz	lr, r2
 8000b1e:	f1be 0f00 	cmp.w	lr, #0
 8000b22:	d00b      	beq.n	8000b3c <__udivmoddi4+0x38>
 8000b24:	f1ce 0420 	rsb	r4, lr, #32
 8000b28:	fa20 f404 	lsr.w	r4, r0, r4
 8000b2c:	fa01 f60e 	lsl.w	r6, r1, lr
 8000b30:	ea44 0c06 	orr.w	ip, r4, r6
 8000b34:	fa02 f70e 	lsl.w	r7, r2, lr
 8000b38:	fa00 f40e 	lsl.w	r4, r0, lr
 8000b3c:	ea4f 4917 	mov.w	r9, r7, lsr #16
 8000b40:	0c22      	lsrs	r2, r4, #16
 8000b42:	fbbc f0f9 	udiv	r0, ip, r9
 8000b46:	fa1f f887 	uxth.w	r8, r7
 8000b4a:	fb09 c610 	mls	r6, r9, r0, ip
 8000b4e:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
 8000b52:	fb00 f308 	mul.w	r3, r0, r8
 8000b56:	42b3      	cmp	r3, r6
 8000b58:	d909      	bls.n	8000b6e <__udivmoddi4+0x6a>
 8000b5a:	19f6      	adds	r6, r6, r7
 8000b5c:	f100 32ff 	add.w	r2, r0, #4294967295
 8000b60:	f080 8122 	bcs.w	8000da8 <__udivmoddi4+0x2a4>
 8000b64:	42b3      	cmp	r3, r6
 8000b66:	f240 811f 	bls.w	8000da8 <__udivmoddi4+0x2a4>
 8000b6a:	3802      	subs	r0, #2
 8000b6c:	443e      	add	r6, r7
 8000b6e:	1af6      	subs	r6, r6, r3
 8000b70:	b2a2      	uxth	r2, r4
 8000b72:	fbb6 f3f9 	udiv	r3, r6, r9
 8000b76:	fb09 6613 	mls	r6, r9, r3, r6
 8000b7a:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
 8000b7e:	fb03 f808 	mul.w	r8, r3, r8
 8000b82:	45a0      	cmp	r8, r4
 8000b84:	d909      	bls.n	8000b9a <__udivmoddi4+0x96>
 8000b86:	19e4      	adds	r4, r4, r7
 8000b88:	f103 32ff 	add.w	r2, r3, #4294967295
 8000b8c:	f080 810a 	bcs.w	8000da4 <__udivmoddi4+0x2a0>
 8000b90:	45a0      	cmp	r8, r4
 8000b92:	f240 8107 	bls.w	8000da4 <__udivmoddi4+0x2a0>
 8000b96:	3b02      	subs	r3, #2
 8000b98:	443c      	add	r4, r7
 8000b9a:	ebc8 0404 	rsb	r4, r8, r4
 8000b9e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8000ba2:	2100      	movs	r1, #0
 8000ba4:	2d00      	cmp	r5, #0
 8000ba6:	d062      	beq.n	8000c6e <__udivmoddi4+0x16a>
 8000ba8:	fa24 f40e 	lsr.w	r4, r4, lr
 8000bac:	2300      	movs	r3, #0
 8000bae:	602c      	str	r4, [r5, #0]
 8000bb0:	606b      	str	r3, [r5, #4]
 8000bb2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000bb6:	428b      	cmp	r3, r1
 8000bb8:	d907      	bls.n	8000bca <__udivmoddi4+0xc6>
 8000bba:	2d00      	cmp	r5, #0
 8000bbc:	d055      	beq.n	8000c6a <__udivmoddi4+0x166>
 8000bbe:	2100      	movs	r1, #0
 8000bc0:	e885 0041 	stmia.w	r5, {r0, r6}
 8000bc4:	4608      	mov	r0, r1
 8000bc6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000bca:	fab3 f183 	clz	r1, r3
 8000bce:	2900      	cmp	r1, #0
 8000bd0:	f040 8090 	bne.w	8000cf4 <__udivmoddi4+0x1f0>
 8000bd4:	42b3      	cmp	r3, r6
 8000bd6:	d302      	bcc.n	8000bde <__udivmoddi4+0xda>
 8000bd8:	4282      	cmp	r2, r0
 8000bda:	f200 80f8 	bhi.w	8000dce <__udivmoddi4+0x2ca>
 8000bde:	1a84      	subs	r4, r0, r2
 8000be0:	eb66 0603 	sbc.w	r6, r6, r3
 8000be4:	2001      	movs	r0, #1
 8000be6:	46b4      	mov	ip, r6
 8000be8:	2d00      	cmp	r5, #0
 8000bea:	d040      	beq.n	8000c6e <__udivmoddi4+0x16a>
 8000bec:	e885 1010 	stmia.w	r5, {r4, ip}
 8000bf0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000bf4:	b912      	cbnz	r2, 8000bfc <__udivmoddi4+0xf8>
 8000bf6:	2701      	movs	r7, #1
 8000bf8:	fbb7 f7f2 	udiv	r7, r7, r2
 8000bfc:	fab7 fe87 	clz	lr, r7
 8000c00:	f1be 0f00 	cmp.w	lr, #0
 8000c04:	d135      	bne.n	8000c72 <__udivmoddi4+0x16e>
 8000c06:	1bf3      	subs	r3, r6, r7
 8000c08:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8000c0c:	fa1f fc87 	uxth.w	ip, r7
 8000c10:	2101      	movs	r1, #1
 8000c12:	fbb3 f0f8 	udiv	r0, r3, r8
 8000c16:	0c22      	lsrs	r2, r4, #16
 8000c18:	fb08 3610 	mls	r6, r8, r0, r3
 8000c1c:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
 8000c20:	fb0c f300 	mul.w	r3, ip, r0
 8000c24:	42b3      	cmp	r3, r6
 8000c26:	d907      	bls.n	8000c38 <__udivmoddi4+0x134>
 8000c28:	19f6      	adds	r6, r6, r7
 8000c2a:	f100 32ff 	add.w	r2, r0, #4294967295
 8000c2e:	d202      	bcs.n	8000c36 <__udivmoddi4+0x132>
 8000c30:	42b3      	cmp	r3, r6
 8000c32:	f200 80ce 	bhi.w	8000dd2 <__udivmoddi4+0x2ce>
 8000c36:	4610      	mov	r0, r2
 8000c38:	1af6      	subs	r6, r6, r3
 8000c3a:	b2a2      	uxth	r2, r4
 8000c3c:	fbb6 f3f8 	udiv	r3, r6, r8
 8000c40:	fb08 6613 	mls	r6, r8, r3, r6
 8000c44:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
 8000c48:	fb0c fc03 	mul.w	ip, ip, r3
 8000c4c:	45a4      	cmp	ip, r4
 8000c4e:	d907      	bls.n	8000c60 <__udivmoddi4+0x15c>
 8000c50:	19e4      	adds	r4, r4, r7
 8000c52:	f103 32ff 	add.w	r2, r3, #4294967295
 8000c56:	d202      	bcs.n	8000c5e <__udivmoddi4+0x15a>
 8000c58:	45a4      	cmp	ip, r4
 8000c5a:	f200 80b5 	bhi.w	8000dc8 <__udivmoddi4+0x2c4>
 8000c5e:	4613      	mov	r3, r2
 8000c60:	ebcc 0404 	rsb	r4, ip, r4
 8000c64:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8000c68:	e79c      	b.n	8000ba4 <__udivmoddi4+0xa0>
 8000c6a:	4629      	mov	r1, r5
 8000c6c:	4628      	mov	r0, r5
 8000c6e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000c72:	f1ce 0120 	rsb	r1, lr, #32
 8000c76:	fa06 f30e 	lsl.w	r3, r6, lr
 8000c7a:	fa07 f70e 	lsl.w	r7, r7, lr
 8000c7e:	fa20 f901 	lsr.w	r9, r0, r1
 8000c82:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8000c86:	40ce      	lsrs	r6, r1
 8000c88:	ea49 0903 	orr.w	r9, r9, r3
 8000c8c:	fbb6 faf8 	udiv	sl, r6, r8
 8000c90:	ea4f 4419 	mov.w	r4, r9, lsr #16
 8000c94:	fb08 661a 	mls	r6, r8, sl, r6
 8000c98:	fa1f fc87 	uxth.w	ip, r7
 8000c9c:	ea44 4306 	orr.w	r3, r4, r6, lsl #16
 8000ca0:	fb0a f20c 	mul.w	r2, sl, ip
 8000ca4:	429a      	cmp	r2, r3
 8000ca6:	fa00 f40e 	lsl.w	r4, r0, lr
 8000caa:	d90a      	bls.n	8000cc2 <__udivmoddi4+0x1be>
 8000cac:	19db      	adds	r3, r3, r7
 8000cae:	f10a 31ff 	add.w	r1, sl, #4294967295
 8000cb2:	f080 8087 	bcs.w	8000dc4 <__udivmoddi4+0x2c0>
 8000cb6:	429a      	cmp	r2, r3
 8000cb8:	f240 8084 	bls.w	8000dc4 <__udivmoddi4+0x2c0>
 8000cbc:	f1aa 0a02 	sub.w	sl, sl, #2
 8000cc0:	443b      	add	r3, r7
 8000cc2:	1a9b      	subs	r3, r3, r2
 8000cc4:	fa1f f989 	uxth.w	r9, r9
 8000cc8:	fbb3 f1f8 	udiv	r1, r3, r8
 8000ccc:	fb08 3311 	mls	r3, r8, r1, r3
 8000cd0:	ea49 4303 	orr.w	r3, r9, r3, lsl #16
 8000cd4:	fb01 f60c 	mul.w	r6, r1, ip
 8000cd8:	429e      	cmp	r6, r3
 8000cda:	d907      	bls.n	8000cec <__udivmoddi4+0x1e8>
 8000cdc:	19db      	adds	r3, r3, r7
 8000cde:	f101 32ff 	add.w	r2, r1, #4294967295
 8000ce2:	d26b      	bcs.n	8000dbc <__udivmoddi4+0x2b8>
 8000ce4:	429e      	cmp	r6, r3
 8000ce6:	d969      	bls.n	8000dbc <__udivmoddi4+0x2b8>
 8000ce8:	3902      	subs	r1, #2
 8000cea:	443b      	add	r3, r7
 8000cec:	1b9b      	subs	r3, r3, r6
 8000cee:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
 8000cf2:	e78e      	b.n	8000c12 <__udivmoddi4+0x10e>
 8000cf4:	f1c1 0e20 	rsb	lr, r1, #32
 8000cf8:	fa22 f40e 	lsr.w	r4, r2, lr
 8000cfc:	408b      	lsls	r3, r1
 8000cfe:	4323      	orrs	r3, r4
 8000d00:	fa20 f70e 	lsr.w	r7, r0, lr
 8000d04:	fa06 f401 	lsl.w	r4, r6, r1
 8000d08:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 8000d0c:	fa26 f60e 	lsr.w	r6, r6, lr
 8000d10:	433c      	orrs	r4, r7
 8000d12:	fbb6 f9fc 	udiv	r9, r6, ip
 8000d16:	0c27      	lsrs	r7, r4, #16
 8000d18:	fb0c 6619 	mls	r6, ip, r9, r6
 8000d1c:	fa1f f883 	uxth.w	r8, r3
 8000d20:	ea47 4606 	orr.w	r6, r7, r6, lsl #16
 8000d24:	fb09 f708 	mul.w	r7, r9, r8
 8000d28:	42b7      	cmp	r7, r6
 8000d2a:	fa02 f201 	lsl.w	r2, r2, r1
 8000d2e:	fa00 fa01 	lsl.w	sl, r0, r1
 8000d32:	d908      	bls.n	8000d46 <__udivmoddi4+0x242>
 8000d34:	18f6      	adds	r6, r6, r3
 8000d36:	f109 30ff 	add.w	r0, r9, #4294967295
 8000d3a:	d241      	bcs.n	8000dc0 <__udivmoddi4+0x2bc>
 8000d3c:	42b7      	cmp	r7, r6
 8000d3e:	d93f      	bls.n	8000dc0 <__udivmoddi4+0x2bc>
 8000d40:	f1a9 0902 	sub.w	r9, r9, #2
 8000d44:	441e      	add	r6, r3
 8000d46:	1bf6      	subs	r6, r6, r7
 8000d48:	b2a0      	uxth	r0, r4
 8000d4a:	fbb6 f4fc 	udiv	r4, r6, ip
 8000d4e:	fb0c 6614 	mls	r6, ip, r4, r6
 8000d52:	ea40 4706 	orr.w	r7, r0, r6, lsl #16
 8000d56:	fb04 f808 	mul.w	r8, r4, r8
 8000d5a:	45b8      	cmp	r8, r7
 8000d5c:	d907      	bls.n	8000d6e <__udivmoddi4+0x26a>
 8000d5e:	18ff      	adds	r7, r7, r3
 8000d60:	f104 30ff 	add.w	r0, r4, #4294967295
 8000d64:	d228      	bcs.n	8000db8 <__udivmoddi4+0x2b4>
 8000d66:	45b8      	cmp	r8, r7
 8000d68:	d926      	bls.n	8000db8 <__udivmoddi4+0x2b4>
 8000d6a:	3c02      	subs	r4, #2
 8000d6c:	441f      	add	r7, r3
 8000d6e:	ea44 4009 	orr.w	r0, r4, r9, lsl #16
 8000d72:	ebc8 0707 	rsb	r7, r8, r7
 8000d76:	fba0 8902 	umull	r8, r9, r0, r2
 8000d7a:	454f      	cmp	r7, r9
 8000d7c:	4644      	mov	r4, r8
 8000d7e:	464e      	mov	r6, r9
 8000d80:	d314      	bcc.n	8000dac <__udivmoddi4+0x2a8>
 8000d82:	d029      	beq.n	8000dd8 <__udivmoddi4+0x2d4>
 8000d84:	b365      	cbz	r5, 8000de0 <__udivmoddi4+0x2dc>
 8000d86:	ebba 0304 	subs.w	r3, sl, r4
 8000d8a:	eb67 0706 	sbc.w	r7, r7, r6
 8000d8e:	fa07 fe0e 	lsl.w	lr, r7, lr
 8000d92:	40cb      	lsrs	r3, r1
 8000d94:	40cf      	lsrs	r7, r1
 8000d96:	ea4e 0303 	orr.w	r3, lr, r3
 8000d9a:	e885 0088 	stmia.w	r5, {r3, r7}
 8000d9e:	2100      	movs	r1, #0
 8000da0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000da4:	4613      	mov	r3, r2
 8000da6:	e6f8      	b.n	8000b9a <__udivmoddi4+0x96>
 8000da8:	4610      	mov	r0, r2
 8000daa:	e6e0      	b.n	8000b6e <__udivmoddi4+0x6a>
 8000dac:	ebb8 0402 	subs.w	r4, r8, r2
 8000db0:	eb69 0603 	sbc.w	r6, r9, r3
 8000db4:	3801      	subs	r0, #1
 8000db6:	e7e5      	b.n	8000d84 <__udivmoddi4+0x280>
 8000db8:	4604      	mov	r4, r0
 8000dba:	e7d8      	b.n	8000d6e <__udivmoddi4+0x26a>
 8000dbc:	4611      	mov	r1, r2
 8000dbe:	e795      	b.n	8000cec <__udivmoddi4+0x1e8>
 8000dc0:	4681      	mov	r9, r0
 8000dc2:	e7c0      	b.n	8000d46 <__udivmoddi4+0x242>
 8000dc4:	468a      	mov	sl, r1
 8000dc6:	e77c      	b.n	8000cc2 <__udivmoddi4+0x1be>
 8000dc8:	3b02      	subs	r3, #2
 8000dca:	443c      	add	r4, r7
 8000dcc:	e748      	b.n	8000c60 <__udivmoddi4+0x15c>
 8000dce:	4608      	mov	r0, r1
 8000dd0:	e70a      	b.n	8000be8 <__udivmoddi4+0xe4>
 8000dd2:	3802      	subs	r0, #2
 8000dd4:	443e      	add	r6, r7
 8000dd6:	e72f      	b.n	8000c38 <__udivmoddi4+0x134>
 8000dd8:	45c2      	cmp	sl, r8
 8000dda:	d3e7      	bcc.n	8000dac <__udivmoddi4+0x2a8>
 8000ddc:	463e      	mov	r6, r7
 8000dde:	e7d1      	b.n	8000d84 <__udivmoddi4+0x280>
 8000de0:	4629      	mov	r1, r5
 8000de2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000de6:	bf00      	nop

08000de8 <__aeabi_idiv0>:
 8000de8:	4770      	bx	lr
 8000dea:	bf00      	nop

08000dec <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000dec:	b510      	push	{r4, lr}
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000);
 8000dee:	4b08      	ldr	r3, [pc, #32]	; (8000e10 <HAL_InitTick+0x24>)
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000df0:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000);
 8000df2:	6818      	ldr	r0, [r3, #0]
 8000df4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000df8:	fbb0 f0f3 	udiv	r0, r0, r3
 8000dfc:	f000 f878 	bl	8000ef0 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 8000e00:	2200      	movs	r2, #0
 8000e02:	4621      	mov	r1, r4
 8000e04:	f04f 30ff 	mov.w	r0, #4294967295
 8000e08:	f000 f83e 	bl	8000e88 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 8000e0c:	2000      	movs	r0, #0
 8000e0e:	bd10      	pop	{r4, pc}
 8000e10:	20000008 	.word	0x20000008

08000e14 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8000e14:	b508      	push	{r3, lr}
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000e16:	2003      	movs	r0, #3
 8000e18:	f000 f824 	bl	8000e64 <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8000e1c:	2000      	movs	r0, #0
 8000e1e:	f7ff ffe5 	bl	8000dec <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8000e22:	f001 ff57 	bl	8002cd4 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 8000e26:	2000      	movs	r0, #0
 8000e28:	bd08      	pop	{r3, pc}
	...

08000e2c <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000e2c:	4a02      	ldr	r2, [pc, #8]	; (8000e38 <HAL_IncTick+0xc>)
 8000e2e:	6813      	ldr	r3, [r2, #0]
 8000e30:	3301      	adds	r3, #1
 8000e32:	6013      	str	r3, [r2, #0]
 8000e34:	4770      	bx	lr
 8000e36:	bf00      	nop
 8000e38:	20000044 	.word	0x20000044

08000e3c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000e3c:	4b01      	ldr	r3, [pc, #4]	; (8000e44 <HAL_GetTick+0x8>)
 8000e3e:	6818      	ldr	r0, [r3, #0]
}
 8000e40:	4770      	bx	lr
 8000e42:	bf00      	nop
 8000e44:	20000044 	.word	0x20000044

08000e48 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000e48:	b538      	push	{r3, r4, r5, lr}
 8000e4a:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000e4c:	f7ff fff6 	bl	8000e3c <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 8000e50:	1c63      	adds	r3, r4, #1
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
  uint32_t tickstart = HAL_GetTick();
 8000e52:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
  {
    wait++;
 8000e54:	bf18      	it	ne
 8000e56:	3401      	addne	r4, #1
  } 

  while((HAL_GetTick() - tickstart) < wait)
 8000e58:	f7ff fff0 	bl	8000e3c <HAL_GetTick>
 8000e5c:	1b40      	subs	r0, r0, r5
 8000e5e:	4284      	cmp	r4, r0
 8000e60:	d8fa      	bhi.n	8000e58 <HAL_Delay+0x10>
  {
  }
}
 8000e62:	bd38      	pop	{r3, r4, r5, pc}

08000e64 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000e64:	4a07      	ldr	r2, [pc, #28]	; (8000e84 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8000e66:	68d3      	ldr	r3, [r2, #12]
 8000e68:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000e6c:	041b      	lsls	r3, r3, #16
 8000e6e:	0c1b      	lsrs	r3, r3, #16
 8000e70:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8000e74:	0200      	lsls	r0, r0, #8
 8000e76:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000e7a:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 8000e7e:	4303      	orrs	r3, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000e80:	60d3      	str	r3, [r2, #12]
 8000e82:	4770      	bx	lr
 8000e84:	e000ed00 	.word	0xe000ed00

08000e88 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000e88:	4b17      	ldr	r3, [pc, #92]	; (8000ee8 <HAL_NVIC_SetPriority+0x60>)
 8000e8a:	68db      	ldr	r3, [r3, #12]
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8000e8c:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8000e90:	b530      	push	{r4, r5, lr}
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000e92:	f1c3 0407 	rsb	r4, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000e96:	1d1d      	adds	r5, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000e98:	2c04      	cmp	r4, #4
 8000e9a:	bf28      	it	cs
 8000e9c:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000e9e:	2d06      	cmp	r5, #6

  return (
 8000ea0:	f04f 0501 	mov.w	r5, #1
 8000ea4:	fa05 f404 	lsl.w	r4, r5, r4
 8000ea8:	f104 34ff 	add.w	r4, r4, #4294967295
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000eac:	bf8c      	ite	hi
 8000eae:	3b03      	subhi	r3, #3
 8000eb0:	2300      	movls	r3, #0

  return (
 8000eb2:	400c      	ands	r4, r1
 8000eb4:	409c      	lsls	r4, r3
 8000eb6:	fa05 f303 	lsl.w	r3, r5, r3
 8000eba:	3b01      	subs	r3, #1
 8000ebc:	401a      	ands	r2, r3
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8000ebe:	2800      	cmp	r0, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8000ec0:	ea42 0204 	orr.w	r2, r2, r4
 8000ec4:	ea4f 1202 	mov.w	r2, r2, lsl #4
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000ec8:	bfaf      	iteee	ge
 8000eca:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000ece:	f000 000f 	andlt.w	r0, r0, #15
 8000ed2:	4b06      	ldrlt	r3, [pc, #24]	; (8000eec <HAL_NVIC_SetPriority+0x64>)
 8000ed4:	b2d2      	uxtblt	r2, r2
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000ed6:	bfa5      	ittet	ge
 8000ed8:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 8000edc:	b2d2      	uxtbge	r2, r2
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000ede:	541a      	strblt	r2, [r3, r0]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000ee0:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 8000ee4:	bd30      	pop	{r4, r5, pc}
 8000ee6:	bf00      	nop
 8000ee8:	e000ed00 	.word	0xe000ed00
 8000eec:	e000ed14 	.word	0xe000ed14

08000ef0 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000ef0:	3801      	subs	r0, #1
 8000ef2:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000ef6:	d20a      	bcs.n	8000f0e <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000ef8:	4b06      	ldr	r3, [pc, #24]	; (8000f14 <HAL_SYSTICK_Config+0x24>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000efa:	4a07      	ldr	r2, [pc, #28]	; (8000f18 <HAL_SYSTICK_Config+0x28>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000efc:	6058      	str	r0, [r3, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000efe:	21f0      	movs	r1, #240	; 0xf0
 8000f00:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000f04:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000f06:	2207      	movs	r2, #7
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000f08:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000f0a:	601a      	str	r2, [r3, #0]
 8000f0c:	4770      	bx	lr
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
 8000f0e:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000f10:	4770      	bx	lr
 8000f12:	bf00      	nop
 8000f14:	e000e010 	.word	0xe000e010
 8000f18:	e000ed00 	.word	0xe000ed00

08000f1c <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 8000f1c:	4b04      	ldr	r3, [pc, #16]	; (8000f30 <HAL_SYSTICK_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000f1e:	681a      	ldr	r2, [r3, #0]
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8000f20:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000f22:	bf0c      	ite	eq
 8000f24:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8000f28:	f022 0204 	bicne.w	r2, r2, #4
 8000f2c:	601a      	str	r2, [r3, #0]
 8000f2e:	4770      	bx	lr
 8000f30:	e000e010 	.word	0xe000e010

08000f34 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 8000f34:	4770      	bx	lr

08000f36 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  Handle SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 8000f36:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 8000f38:	f7ff fffc 	bl	8000f34 <HAL_SYSTICK_Callback>
 8000f3c:	bd08      	pop	{r3, pc}
	...

08000f40 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000f40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000f44:	b085      	sub	sp, #20
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000f46:	680b      	ldr	r3, [r1, #0]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000f48:	f8df c168 	ldr.w	ip, [pc, #360]	; 80010b4 <HAL_GPIO_Init+0x174>
 8000f4c:	4c57      	ldr	r4, [pc, #348]	; (80010ac <HAL_GPIO_Init+0x16c>)
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000f4e:	9301      	str	r3, [sp, #4]
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000f50:	f04f 080f 	mov.w	r8, #15
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  uint32_t position = 0x00;
 8000f54:	2300      	movs	r3, #0
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000f56:	9a01      	ldr	r2, [sp, #4]
 8000f58:	40da      	lsrs	r2, r3
 8000f5a:	f000 80a4 	beq.w	80010a6 <HAL_GPIO_Init+0x166>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 8000f5e:	2201      	movs	r2, #1
 8000f60:	fa02 f903 	lsl.w	r9, r2, r3

    if(iocurrent)
 8000f64:	9a01      	ldr	r2, [sp, #4]
 8000f66:	ea12 0509 	ands.w	r5, r2, r9
 8000f6a:	f000 809a 	beq.w	80010a2 <HAL_GPIO_Init+0x162>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000f6e:	684a      	ldr	r2, [r1, #4]
 8000f70:	f022 0a10 	bic.w	sl, r2, #16
 8000f74:	f1ba 0f02 	cmp.w	sl, #2
 8000f78:	d113      	bne.n	8000fa2 <HAL_GPIO_Init+0x62>
 8000f7a:	ea4f 0ed3 	mov.w	lr, r3, lsr #3
 8000f7e:	eb00 0e8e 	add.w	lr, r0, lr, lsl #2
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000f82:	f003 0b07 	and.w	fp, r3, #7
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 8000f86:	f8de 7020 	ldr.w	r7, [lr, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000f8a:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 8000f8e:	fa08 f60b 	lsl.w	r6, r8, fp
 8000f92:	ea27 0706 	bic.w	r7, r7, r6
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8000f96:	690e      	ldr	r6, [r1, #16]
 8000f98:	fa06 f60b 	lsl.w	r6, r6, fp
 8000f9c:	433e      	orrs	r6, r7
        GPIOx->AFR[position >> 3] = temp;
 8000f9e:	f8ce 6020 	str.w	r6, [lr, #32]
 8000fa2:	ea4f 0e43 	mov.w	lr, r3, lsl #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 8000fa6:	2603      	movs	r6, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8000fa8:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 8000faa:	fa06 f60e 	lsl.w	r6, r6, lr
 8000fae:	43f6      	mvns	r6, r6
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000fb0:	f002 0b03 	and.w	fp, r2, #3
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 8000fb4:	4037      	ands	r7, r6
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000fb6:	fa0b fb0e 	lsl.w	fp, fp, lr
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000fba:	f10a 3aff 	add.w	sl, sl, #4294967295
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000fbe:	ea4b 0707 	orr.w	r7, fp, r7
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000fc2:	f1ba 0f01 	cmp.w	sl, #1

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
      GPIOx->MODER = temp;
 8000fc6:	6007      	str	r7, [r0, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000fc8:	d811      	bhi.n	8000fee <HAL_GPIO_Init+0xae>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8000fca:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2));
 8000fcc:	ea06 0a07 	and.w	sl, r6, r7
        temp |= (GPIO_Init->Speed << (position * 2));
 8000fd0:	68cf      	ldr	r7, [r1, #12]
 8000fd2:	fa07 f70e 	lsl.w	r7, r7, lr
 8000fd6:	ea47 070a 	orr.w	r7, r7, sl
        GPIOx->OSPEEDR = temp;
 8000fda:	6087      	str	r7, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8000fdc:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8000fde:	ea27 0909 	bic.w	r9, r7, r9
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8000fe2:	f3c2 1700 	ubfx	r7, r2, #4, #1
 8000fe6:	409f      	lsls	r7, r3
 8000fe8:	ea47 0709 	orr.w	r7, r7, r9
        GPIOx->OTYPER = temp;
 8000fec:	6047      	str	r7, [r0, #4]
      }

#endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8000fee:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2));
 8000ff0:	403e      	ands	r6, r7
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8000ff2:	688f      	ldr	r7, [r1, #8]
 8000ff4:	fa07 f70e 	lsl.w	r7, r7, lr
 8000ff8:	433e      	orrs	r6, r7
      GPIOx->PUPDR = temp;
 8000ffa:	60c6      	str	r6, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000ffc:	00d6      	lsls	r6, r2, #3
 8000ffe:	d550      	bpl.n	80010a2 <HAL_GPIO_Init+0x162>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001000:	f8dc 6060 	ldr.w	r6, [ip, #96]	; 0x60
 8001004:	f046 0601 	orr.w	r6, r6, #1
 8001008:	f8cc 6060 	str.w	r6, [ip, #96]	; 0x60
 800100c:	f8dc 6060 	ldr.w	r6, [ip, #96]	; 0x60
 8001010:	f006 0601 	and.w	r6, r6, #1
 8001014:	9603      	str	r6, [sp, #12]
 8001016:	9e03      	ldr	r6, [sp, #12]
 8001018:	f023 0603 	bic.w	r6, r3, #3
 800101c:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
 8001020:	f506 3680 	add.w	r6, r6, #65536	; 0x10000

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001024:	f003 0903 	and.w	r9, r3, #3
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
 8001028:	68b7      	ldr	r7, [r6, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 800102a:	ea4f 0989 	mov.w	r9, r9, lsl #2
 800102e:	fa08 fe09 	lsl.w	lr, r8, r9
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 8001032:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001036:	ea27 0a0e 	bic.w	sl, r7, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 800103a:	d00b      	beq.n	8001054 <HAL_GPIO_Init+0x114>
 800103c:	4f1c      	ldr	r7, [pc, #112]	; (80010b0 <HAL_GPIO_Init+0x170>)
 800103e:	42b8      	cmp	r0, r7
 8001040:	d00b      	beq.n	800105a <HAL_GPIO_Init+0x11a>
 8001042:	f507 6780 	add.w	r7, r7, #1024	; 0x400
 8001046:	42b8      	cmp	r0, r7
 8001048:	bf14      	ite	ne
 800104a:	f04f 0e07 	movne.w	lr, #7
 800104e:	f04f 0e02 	moveq.w	lr, #2
 8001052:	e004      	b.n	800105e <HAL_GPIO_Init+0x11e>
 8001054:	f04f 0e00 	mov.w	lr, #0
 8001058:	e001      	b.n	800105e <HAL_GPIO_Init+0x11e>
 800105a:	f04f 0e01 	mov.w	lr, #1
 800105e:	fa0e f909 	lsl.w	r9, lr, r9
 8001062:	ea49 070a 	orr.w	r7, r9, sl
        SYSCFG->EXTICR[position >> 2] = temp;
 8001066:	60b7      	str	r7, [r6, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8001068:	4e10      	ldr	r6, [pc, #64]	; (80010ac <HAL_GPIO_Init+0x16c>)
 800106a:	6836      	ldr	r6, [r6, #0]
        temp &= ~((uint32_t)iocurrent);
 800106c:	43ef      	mvns	r7, r5
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800106e:	f412 3f80 	tst.w	r2, #65536	; 0x10000
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
        temp &= ~((uint32_t)iocurrent);
 8001072:	bf0c      	ite	eq
 8001074:	403e      	andeq	r6, r7
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
 8001076:	432e      	orrne	r6, r5
        }
        EXTI->IMR1 = temp;
 8001078:	6026      	str	r6, [r4, #0]

        temp = EXTI->EMR1;
 800107a:	6866      	ldr	r6, [r4, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800107c:	f412 3f00 	tst.w	r2, #131072	; 0x20000
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;

        temp = EXTI->EMR1;
        temp &= ~((uint32_t)iocurrent);
 8001080:	bf0c      	ite	eq
 8001082:	403e      	andeq	r6, r7
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
 8001084:	432e      	orrne	r6, r5
        }
        EXTI->EMR1 = temp;
 8001086:	6066      	str	r6, [r4, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8001088:	68a6      	ldr	r6, [r4, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800108a:	f412 1f80 	tst.w	r2, #1048576	; 0x100000
        }
        EXTI->EMR1 = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
        temp &= ~((uint32_t)iocurrent);
 800108e:	bf0c      	ite	eq
 8001090:	403e      	andeq	r6, r7
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
 8001092:	432e      	orrne	r6, r5
        }
        EXTI->RTSR1 = temp;
 8001094:	60a6      	str	r6, [r4, #8]

        temp = EXTI->FTSR1;
 8001096:	68e6      	ldr	r6, [r4, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001098:	0292      	lsls	r2, r2, #10
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;

        temp = EXTI->FTSR1;
        temp &= ~((uint32_t)iocurrent);
 800109a:	bf54      	ite	pl
 800109c:	403e      	andpl	r6, r7
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 800109e:	432e      	orrmi	r6, r5
        }
        EXTI->FTSR1 = temp;
 80010a0:	60e6      	str	r6, [r4, #12]
      }
    }
    
    position++;
 80010a2:	3301      	adds	r3, #1
 80010a4:	e757      	b.n	8000f56 <HAL_GPIO_Init+0x16>
  }
}
 80010a6:	b005      	add	sp, #20
 80010a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80010ac:	40010400 	.word	0x40010400
 80010b0:	48000400 	.word	0x48000400
 80010b4:	40021000 	.word	0x40021000

080010b8 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80010b8:	b10a      	cbz	r2, 80010be <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 80010ba:	6181      	str	r1, [r0, #24]
 80010bc:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 80010be:	6281      	str	r1, [r0, #40]	; 0x28
 80010c0:	4770      	bx	lr
	...

080010c4 <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_RANGE1 or PWR_REGULATOR_VOLTAGE_RANGE2)
  */  
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return  (PWR->CR1 & PWR_CR1_VOS);
 80010c4:	4b02      	ldr	r3, [pc, #8]	; (80010d0 <HAL_PWREx_GetVoltageRange+0xc>)
 80010c6:	6818      	ldr	r0, [r3, #0]
}
 80010c8:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 80010cc:	4770      	bx	lr
 80010ce:	bf00      	nop
 80010d0:	40007000 	.word	0x40007000

080010d4 <HAL_PWREx_ControlVoltageScaling>:
  *        cleared before returning the status. If the flag is not cleared within
  *        50 microseconds, HAL_TIMEOUT status is reported.                    
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
 80010d4:	4b17      	ldr	r3, [pc, #92]	; (8001134 <HAL_PWREx_ControlVoltageScaling+0x60>)
  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
  
  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 80010d6:	681a      	ldr	r2, [r3, #0]
  uint32_t wait_loop_index = 0;  

  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
  
  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 80010d8:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 80010dc:	f402 62c0 	and.w	r2, r2, #1536	; 0x600
  uint32_t wait_loop_index = 0;  

  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
  
  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 80010e0:	d11a      	bne.n	8001118 <HAL_PWREx_ControlVoltageScaling+0x44>
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 80010e2:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 80010e6:	d020      	beq.n	800112a <HAL_PWREx_ControlVoltageScaling+0x56>
    {
      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 80010e8:	681a      	ldr	r2, [r3, #0]
      
      /* Wait until VOSF is cleared */      
      wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 80010ea:	4913      	ldr	r1, [pc, #76]	; (8001138 <HAL_PWREx_ControlVoltageScaling+0x64>)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
    {
      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 80010ec:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 80010f0:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80010f4:	601a      	str	r2, [r3, #0]
      
      /* Wait until VOSF is cleared */      
      wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 80010f6:	4a11      	ldr	r2, [pc, #68]	; (800113c <HAL_PWREx_ControlVoltageScaling+0x68>)
 80010f8:	6812      	ldr	r2, [r2, #0]
 80010fa:	fbb2 f1f1 	udiv	r1, r2, r1
 80010fe:	2232      	movs	r2, #50	; 0x32
 8001100:	434a      	muls	r2, r1
      while ((wait_loop_index != 0) && (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)))
 8001102:	b122      	cbz	r2, 800110e <HAL_PWREx_ControlVoltageScaling+0x3a>
 8001104:	6959      	ldr	r1, [r3, #20]
 8001106:	0549      	lsls	r1, r1, #21
 8001108:	d501      	bpl.n	800110e <HAL_PWREx_ControlVoltageScaling+0x3a>
      {
        wait_loop_index--;
 800110a:	3a01      	subs	r2, #1
 800110c:	e7f9      	b.n	8001102 <HAL_PWREx_ControlVoltageScaling+0x2e>
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 800110e:	4b09      	ldr	r3, [pc, #36]	; (8001134 <HAL_PWREx_ControlVoltageScaling+0x60>)
 8001110:	695b      	ldr	r3, [r3, #20]
 8001112:	055b      	lsls	r3, r3, #21
 8001114:	d40b      	bmi.n	800112e <HAL_PWREx_ControlVoltageScaling+0x5a>
 8001116:	e008      	b.n	800112a <HAL_PWREx_ControlVoltageScaling+0x56>
      }
    }
  }
  else
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE2)
 8001118:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
    {
      /* Set Range 2 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 800111c:	bf1f      	itttt	ne
 800111e:	681a      	ldrne	r2, [r3, #0]
 8001120:	f422 62c0 	bicne.w	r2, r2, #1536	; 0x600
 8001124:	f442 6280 	orrne.w	r2, r2, #1024	; 0x400
 8001128:	601a      	strne	r2, [r3, #0]
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
  
  return HAL_OK;
 800112a:	2000      	movs	r0, #0
 800112c:	4770      	bx	lr
      {
        wait_loop_index--;
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
      {
        return HAL_TIMEOUT;
 800112e:	2003      	movs	r0, #3
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
  
  return HAL_OK;
}  
 8001130:	4770      	bx	lr
 8001132:	bf00      	nop
 8001134:	40007000 	.word	0x40007000
 8001138:	000f4240 	.word	0x000f4240
 800113c:	20000008 	.word	0x20000008

08001140 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8001140:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
  
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8001142:	4d1e      	ldr	r5, [pc, #120]	; (80011bc <RCC_SetFlashLatencyFromMSIRange+0x7c>)
 8001144:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8001146:	00d9      	lsls	r1, r3, #3
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8001148:	4604      	mov	r4, r0
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
  
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 800114a:	d502      	bpl.n	8001152 <RCC_SetFlashLatencyFromMSIRange+0x12>
  {
    vos = HAL_PWREx_GetVoltageRange();
 800114c:	f7ff ffba 	bl	80010c4 <HAL_PWREx_GetVoltageRange>
 8001150:	e00e      	b.n	8001170 <RCC_SetFlashLatencyFromMSIRange+0x30>
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
 8001152:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8001154:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001158:	65ab      	str	r3, [r5, #88]	; 0x58
 800115a:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800115c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001160:	9301      	str	r3, [sp, #4]
 8001162:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 8001164:	f7ff ffae 	bl	80010c4 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 8001168:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800116a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800116e:	65ab      	str	r3, [r5, #88]	; 0x58
  }
  
  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8001170:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8001174:	d106      	bne.n	8001184 <RCC_SetFlashLatencyFromMSIRange+0x44>
  {
    if(msirange > RCC_MSIRANGE_8)
 8001176:	2c80      	cmp	r4, #128	; 0x80
 8001178:	d90c      	bls.n	8001194 <RCC_SetFlashLatencyFromMSIRange+0x54>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
 800117a:	2ca0      	cmp	r4, #160	; 0xa0
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else
      {
        /* MSI 24Mhz or 32Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 800117c:	bf8c      	ite	hi
 800117e:	2302      	movhi	r3, #2
 8001180:	2301      	movls	r3, #1
 8001182:	e00c      	b.n	800119e <RCC_SetFlashLatencyFromMSIRange+0x5e>
    }
    /* else MSI <= 16Mhz default FLASH_LATENCY_0 0WS */
  }
  else
  {
    if(msirange > RCC_MSIRANGE_8)
 8001184:	2c80      	cmp	r4, #128	; 0x80
 8001186:	d807      	bhi.n	8001198 <RCC_SetFlashLatencyFromMSIRange+0x58>
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
    }
    else
    {
      if(msirange == RCC_MSIRANGE_8)
 8001188:	d008      	beq.n	800119c <RCC_SetFlashLatencyFromMSIRange+0x5c>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
      {
        /* MSI 48Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 800118a:	f1a4 0270 	sub.w	r2, r4, #112	; 0x70
 800118e:	4253      	negs	r3, r2
 8001190:	4153      	adcs	r3, r2
 8001192:	e004      	b.n	800119e <RCC_SetFlashLatencyFromMSIRange+0x5e>
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 8001194:	2300      	movs	r3, #0
 8001196:	e002      	b.n	800119e <RCC_SetFlashLatencyFromMSIRange+0x5e>
  else
  {
    if(msirange > RCC_MSIRANGE_8)
    {
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
 8001198:	2303      	movs	r3, #3
 800119a:	e000      	b.n	800119e <RCC_SetFlashLatencyFromMSIRange+0x5e>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
      {
        /* MSI 48Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 800119c:	2302      	movs	r3, #2
      }
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
  }
       
  __HAL_FLASH_SET_LATENCY(latency);
 800119e:	4908      	ldr	r1, [pc, #32]	; (80011c0 <RCC_SetFlashLatencyFromMSIRange+0x80>)
 80011a0:	680a      	ldr	r2, [r1, #0]
 80011a2:	f022 0207 	bic.w	r2, r2, #7
 80011a6:	431a      	orrs	r2, r3
 80011a8:	600a      	str	r2, [r1, #0]
  
  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
 80011aa:	6808      	ldr	r0, [r1, #0]
 80011ac:	f000 0007 	and.w	r0, r0, #7
  {
    return HAL_ERROR;
  }
  
  return HAL_OK;
}
 80011b0:	1ac0      	subs	r0, r0, r3
 80011b2:	bf18      	it	ne
 80011b4:	2001      	movne	r0, #1
 80011b6:	b003      	add	sp, #12
 80011b8:	bd30      	pop	{r4, r5, pc}
 80011ba:	bf00      	nop
 80011bc:	40021000 	.word	0x40021000
 80011c0:	40022000 	.word	0x40022000

080011c4 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80011c4:	b570      	push	{r4, r5, r6, lr}
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
  uint32_t sysclockfreq = 0U;

  if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
 80011c6:	4c4a      	ldr	r4, [pc, #296]	; (80012f0 <HAL_RCC_GetSysClockFreq+0x12c>)
 80011c8:	68a3      	ldr	r3, [r4, #8]
 80011ca:	f013 0f0c 	tst.w	r3, #12
 80011ce:	d009      	beq.n	80011e4 <HAL_RCC_GetSysClockFreq+0x20>
     ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
 80011d0:	68a3      	ldr	r3, [r4, #8]
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
  uint32_t sysclockfreq = 0U;

  if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
 80011d2:	f003 030c 	and.w	r3, r3, #12
 80011d6:	2b0c      	cmp	r3, #12
 80011d8:	d126      	bne.n	8001228 <HAL_RCC_GetSysClockFreq+0x64>
     ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
 80011da:	68e3      	ldr	r3, [r4, #12]
 80011dc:	f003 0303 	and.w	r3, r3, #3
 80011e0:	2b01      	cmp	r3, #1
 80011e2:	d121      	bne.n	8001228 <HAL_RCC_GetSysClockFreq+0x64>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
 80011e4:	6822      	ldr	r2, [r4, #0]
 80011e6:	4b42      	ldr	r3, [pc, #264]	; (80012f0 <HAL_RCC_GetSysClockFreq+0x12c>)
 80011e8:	0712      	lsls	r2, r2, #28
 80011ea:	d40a      	bmi.n	8001202 <HAL_RCC_GetSysClockFreq+0x3e>
    { /* MSISRANGE from RCC_CSR applies */
      msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> POSITION_VAL(RCC_CSR_MSISRANGE);
 80011ec:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80011f0:	f44f 6270 	mov.w	r2, #3840	; 0xf00
 80011f4:	fa92 f2a2 	rbit	r2, r2
 80011f8:	fab2 f282 	clz	r2, r2
 80011fc:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8001200:	e007      	b.n	8001212 <HAL_RCC_GetSysClockFreq+0x4e>
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->CR & RCC_CR_MSIRANGE) >> POSITION_VAL(RCC_CR_MSIRANGE);
 8001202:	681b      	ldr	r3, [r3, #0]
 8001204:	22f0      	movs	r2, #240	; 0xf0
 8001206:	fa92 f2a2 	rbit	r2, r2
 800120a:	fab2 f282 	clz	r2, r2
 800120e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8001212:	40d3      	lsrs	r3, r2
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8001214:	4a37      	ldr	r2, [pc, #220]	; (80012f4 <HAL_RCC_GetSysClockFreq+0x130>)
 8001216:	f852 6023 	ldr.w	r6, [r2, r3, lsl #2]

    if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI)
 800121a:	68a3      	ldr	r3, [r4, #8]
    {
      /* MSI used as system clock source */
      sysclockfreq = msirange;
 800121c:	f013 0f0c 	tst.w	r3, #12
 8001220:	bf0c      	ite	eq
 8001222:	4630      	moveq	r0, r6
 8001224:	2000      	movne	r0, #0
 8001226:	e011      	b.n	800124c <HAL_RCC_GetSysClockFreq+0x88>
    }
  }
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
 8001228:	68a3      	ldr	r3, [r4, #8]
 800122a:	f003 030c 	and.w	r3, r3, #12
 800122e:	2b04      	cmp	r3, #4
 8001230:	d007      	beq.n	8001242 <HAL_RCC_GetSysClockFreq+0x7e>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
  }
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
 8001232:	4b2f      	ldr	r3, [pc, #188]	; (80012f0 <HAL_RCC_GetSysClockFreq+0x12c>)
 8001234:	689b      	ldr	r3, [r3, #8]
 8001236:	f003 030c 	and.w	r3, r3, #12
 800123a:	2b08      	cmp	r3, #8
 800123c:	d104      	bne.n	8001248 <HAL_RCC_GetSysClockFreq+0x84>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
 800123e:	482e      	ldr	r0, [pc, #184]	; (80012f8 <HAL_RCC_GetSysClockFreq+0x134>)
 8001240:	e000      	b.n	8001244 <HAL_RCC_GetSysClockFreq+0x80>
    }
  }
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 8001242:	482e      	ldr	r0, [pc, #184]	; (80012fc <HAL_RCC_GetSysClockFreq+0x138>)
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
 8001244:	2600      	movs	r6, #0
 8001246:	e001      	b.n	800124c <HAL_RCC_GetSysClockFreq+0x88>
  uint32_t sysclockfreq = 0U;
 8001248:	2000      	movs	r0, #0
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
 800124a:	4606      	mov	r6, r0
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 800124c:	68a3      	ldr	r3, [r4, #8]
 800124e:	4a28      	ldr	r2, [pc, #160]	; (80012f0 <HAL_RCC_GetSysClockFreq+0x12c>)
 8001250:	f003 030c 	and.w	r3, r3, #12
 8001254:	2b0c      	cmp	r3, #12
 8001256:	d149      	bne.n	80012ec <HAL_RCC_GetSysClockFreq+0x128>
    /* PLL used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 8001258:	68d1      	ldr	r1, [r2, #12]
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> POSITION_VAL(RCC_PLLCFGR_PLLM)) + 1U ;
 800125a:	68d3      	ldr	r3, [r2, #12]
 800125c:	2070      	movs	r0, #112	; 0x70
 800125e:	fa90 f0a0 	rbit	r0, r0
 8001262:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8001266:	fab0 f080 	clz	r0, r0
 800126a:	fa23 f000 	lsr.w	r0, r3, r0

    switch (pllsource)
 800126e:	f001 0303 	and.w	r3, r1, #3
 8001272:	2b02      	cmp	r3, #2

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> POSITION_VAL(RCC_PLLCFGR_PLLM)) + 1U ;
 8001274:	f100 0501 	add.w	r5, r0, #1
 8001278:	f44f 41fe 	mov.w	r1, #32512	; 0x7f00

    switch (pllsource)
 800127c:	d00c      	beq.n	8001298 <HAL_RCC_GetSysClockFreq+0xd4>
 800127e:	2b03      	cmp	r3, #3
 8001280:	d119      	bne.n	80012b6 <HAL_RCC_GetSysClockFreq+0xf2>
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN));
      break;

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN));
 8001282:	68d3      	ldr	r3, [r2, #12]
 8001284:	fa91 f1a1 	rbit	r1, r1
 8001288:	fab1 f181 	clz	r1, r1
 800128c:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 8001290:	fa23 f101 	lsr.w	r1, r3, r1
 8001294:	4a18      	ldr	r2, [pc, #96]	; (80012f8 <HAL_RCC_GetSysClockFreq+0x134>)
 8001296:	e009      	b.n	80012ac <HAL_RCC_GetSysClockFreq+0xe8>
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> POSITION_VAL(RCC_PLLCFGR_PLLM)) + 1U ;

    switch (pllsource)
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN));
 8001298:	68d3      	ldr	r3, [r2, #12]
 800129a:	fa91 f1a1 	rbit	r1, r1
 800129e:	4a17      	ldr	r2, [pc, #92]	; (80012fc <HAL_RCC_GetSysClockFreq+0x138>)
 80012a0:	fab1 f181 	clz	r1, r1
 80012a4:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 80012a8:	fa23 f101 	lsr.w	r1, r3, r1
      break;

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN));
 80012ac:	fbb2 f0f5 	udiv	r0, r2, r5
 80012b0:	fb00 f301 	mul.w	r3, r0, r1
      break;
 80012b4:	e00b      	b.n	80012ce <HAL_RCC_GetSysClockFreq+0x10a>

    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
    default:
      pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN));
 80012b6:	68d2      	ldr	r2, [r2, #12]
 80012b8:	fa91 f1a1 	rbit	r1, r1
 80012bc:	fab1 f181 	clz	r1, r1
 80012c0:	f402 42fe 	and.w	r2, r2, #32512	; 0x7f00
 80012c4:	40ca      	lsrs	r2, r1
 80012c6:	fbb6 f0f5 	udiv	r0, r6, r5
 80012ca:	fb00 f302 	mul.w	r3, r0, r2
      break;
    }
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> POSITION_VAL(RCC_PLLCFGR_PLLR)) + 1U ) * 2U;
 80012ce:	68e2      	ldr	r2, [r4, #12]
 80012d0:	f04f 60c0 	mov.w	r0, #100663296	; 0x6000000
 80012d4:	fa90 f0a0 	rbit	r0, r0
 80012d8:	fab0 f080 	clz	r0, r0
    sysclockfreq = pllvco/pllr;
 80012dc:	f002 62c0 	and.w	r2, r2, #100663296	; 0x6000000
 80012e0:	fa22 f000 	lsr.w	r0, r2, r0
 80012e4:	3001      	adds	r0, #1
 80012e6:	0040      	lsls	r0, r0, #1
 80012e8:	fbb3 f0f0 	udiv	r0, r3, r0
  }

  return sysclockfreq;
}
 80012ec:	bd70      	pop	{r4, r5, r6, pc}
 80012ee:	bf00      	nop
 80012f0:	40021000 	.word	0x40021000
 80012f4:	08004584 	.word	0x08004584
 80012f8:	007a1200 	.word	0x007a1200
 80012fc:	00f42400 	.word	0x00f42400

08001300 <HAL_RCC_OscConfig>:
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8001300:	6803      	ldr	r3, [r0, #0]
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8001302:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8001306:	06dd      	lsls	r5, r3, #27
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8001308:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 800130a:	f140 808f 	bpl.w	800142c <HAL_RCC_OscConfig+0x12c>
    assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

    /* When the MSI is used as system clock it will not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
 800130e:	4d9e      	ldr	r5, [pc, #632]	; (8001588 <HAL_RCC_OscConfig+0x288>)
 8001310:	68ab      	ldr	r3, [r5, #8]
 8001312:	f013 0f0c 	tst.w	r3, #12
 8001316:	d153      	bne.n	80013c0 <HAL_RCC_OscConfig+0xc0>
    {
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8001318:	682b      	ldr	r3, [r5, #0]
 800131a:	0798      	lsls	r0, r3, #30
 800131c:	d503      	bpl.n	8001326 <HAL_RCC_OscConfig+0x26>
 800131e:	69a3      	ldr	r3, [r4, #24]
 8001320:	2b00      	cmp	r3, #0
 8001322:	f000 8256 	beq.w	80017d2 <HAL_RCC_OscConfig+0x4d2>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device. */
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8001326:	682a      	ldr	r2, [r5, #0]
 8001328:	4b97      	ldr	r3, [pc, #604]	; (8001588 <HAL_RCC_OscConfig+0x288>)
 800132a:	6a20      	ldr	r0, [r4, #32]
 800132c:	0711      	lsls	r1, r2, #28
 800132e:	bf56      	itet	pl
 8001330:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
 8001334:	681b      	ldrmi	r3, [r3, #0]
 8001336:	091b      	lsrpl	r3, r3, #4
 8001338:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800133c:	4283      	cmp	r3, r0
 800133e:	d216      	bcs.n	800136e <HAL_RCC_OscConfig+0x6e>
        {
          /* First increase number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8001340:	f7ff fefe 	bl	8001140 <RCC_SetFlashLatencyFromMSIRange>
 8001344:	2800      	cmp	r0, #0
 8001346:	f040 8244 	bne.w	80017d2 <HAL_RCC_OscConfig+0x4d2>
          {
            return HAL_ERROR;
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800134a:	682b      	ldr	r3, [r5, #0]
 800134c:	f043 0308 	orr.w	r3, r3, #8
 8001350:	602b      	str	r3, [r5, #0]
 8001352:	682b      	ldr	r3, [r5, #0]
 8001354:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8001358:	6a23      	ldr	r3, [r4, #32]
 800135a:	4313      	orrs	r3, r2
 800135c:	602b      	str	r3, [r5, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800135e:	686b      	ldr	r3, [r5, #4]
 8001360:	69e2      	ldr	r2, [r4, #28]
 8001362:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8001366:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800136a:	606b      	str	r3, [r5, #4]
 800136c:	e014      	b.n	8001398 <HAL_RCC_OscConfig+0x98>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800136e:	682b      	ldr	r3, [r5, #0]
 8001370:	f043 0308 	orr.w	r3, r3, #8
 8001374:	602b      	str	r3, [r5, #0]
 8001376:	682b      	ldr	r3, [r5, #0]
 8001378:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800137c:	4303      	orrs	r3, r0
 800137e:	602b      	str	r3, [r5, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8001380:	686b      	ldr	r3, [r5, #4]
 8001382:	69e2      	ldr	r2, [r4, #28]
 8001384:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8001388:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800138c:	606b      	str	r3, [r5, #4]

          /* Decrease number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 800138e:	f7ff fed7 	bl	8001140 <RCC_SetFlashLatencyFromMSIRange>
 8001392:	2800      	cmp	r0, #0
 8001394:	f040 821d 	bne.w	80017d2 <HAL_RCC_OscConfig+0x4d2>
            return HAL_ERROR;
          }          
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8001398:	f7ff ff14 	bl	80011c4 <HAL_RCC_GetSysClockFreq>
 800139c:	68ab      	ldr	r3, [r5, #8]
 800139e:	22f0      	movs	r2, #240	; 0xf0
 80013a0:	fa92 f2a2 	rbit	r2, r2
 80013a4:	fab2 f282 	clz	r2, r2
 80013a8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80013ac:	40d3      	lsrs	r3, r2
 80013ae:	4a77      	ldr	r2, [pc, #476]	; (800158c <HAL_RCC_OscConfig+0x28c>)
 80013b0:	5cd3      	ldrb	r3, [r2, r3]
 80013b2:	40d8      	lsrs	r0, r3
 80013b4:	4b76      	ldr	r3, [pc, #472]	; (8001590 <HAL_RCC_OscConfig+0x290>)
 80013b6:	6018      	str	r0, [r3, #0]
        
        /* Configure the source of time base considering new system clocks settings*/
        HAL_InitTick (TICK_INT_PRIORITY);
 80013b8:	2000      	movs	r0, #0
 80013ba:	f7ff fd17 	bl	8000dec <HAL_InitTick>
 80013be:	e035      	b.n	800142c <HAL_RCC_OscConfig+0x12c>
      }
    }
    else
    {
      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 80013c0:	6983      	ldr	r3, [r0, #24]
 80013c2:	b31b      	cbz	r3, 800140c <HAL_RCC_OscConfig+0x10c>
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 80013c4:	682b      	ldr	r3, [r5, #0]
 80013c6:	f043 0301 	orr.w	r3, r3, #1
 80013ca:	602b      	str	r3, [r5, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();
 80013cc:	f7ff fd36 	bl	8000e3c <HAL_GetTick>
 80013d0:	4606      	mov	r6, r0

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET)
 80013d2:	682a      	ldr	r2, [r5, #0]
 80013d4:	4b6c      	ldr	r3, [pc, #432]	; (8001588 <HAL_RCC_OscConfig+0x288>)
 80013d6:	0792      	lsls	r2, r2, #30
 80013d8:	d406      	bmi.n	80013e8 <HAL_RCC_OscConfig+0xe8>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80013da:	f7ff fd2f 	bl	8000e3c <HAL_GetTick>
 80013de:	1b80      	subs	r0, r0, r6
 80013e0:	2802      	cmp	r0, #2
 80013e2:	d9f6      	bls.n	80013d2 <HAL_RCC_OscConfig+0xd2>
          {
            return HAL_TIMEOUT;
 80013e4:	2003      	movs	r0, #3
 80013e6:	e1f5      	b.n	80017d4 <HAL_RCC_OscConfig+0x4d4>
          }
        }
         /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80013e8:	681a      	ldr	r2, [r3, #0]
 80013ea:	f042 0208 	orr.w	r2, r2, #8
 80013ee:	601a      	str	r2, [r3, #0]
 80013f0:	681a      	ldr	r2, [r3, #0]
 80013f2:	f022 01f0 	bic.w	r1, r2, #240	; 0xf0
 80013f6:	6a22      	ldr	r2, [r4, #32]
 80013f8:	430a      	orrs	r2, r1
 80013fa:	601a      	str	r2, [r3, #0]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80013fc:	685a      	ldr	r2, [r3, #4]
 80013fe:	69e1      	ldr	r1, [r4, #28]
 8001400:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8001404:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8001408:	605a      	str	r2, [r3, #4]
 800140a:	e00f      	b.n	800142c <HAL_RCC_OscConfig+0x12c>

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 800140c:	682b      	ldr	r3, [r5, #0]
 800140e:	f023 0301 	bic.w	r3, r3, #1
 8001412:	602b      	str	r3, [r5, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();
 8001414:	f7ff fd12 	bl	8000e3c <HAL_GetTick>
 8001418:	4606      	mov	r6, r0

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != RESET)
 800141a:	682b      	ldr	r3, [r5, #0]
 800141c:	079f      	lsls	r7, r3, #30
 800141e:	d505      	bpl.n	800142c <HAL_RCC_OscConfig+0x12c>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8001420:	f7ff fd0c 	bl	8000e3c <HAL_GetTick>
 8001424:	1b80      	subs	r0, r0, r6
 8001426:	2802      	cmp	r0, #2
 8001428:	d9f7      	bls.n	800141a <HAL_RCC_OscConfig+0x11a>
 800142a:	e7db      	b.n	80013e4 <HAL_RCC_OscConfig+0xe4>
        }
      }
    }
  }
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800142c:	6823      	ldr	r3, [r4, #0]
 800142e:	07de      	lsls	r6, r3, #31
 8001430:	d403      	bmi.n	800143a <HAL_RCC_OscConfig+0x13a>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001432:	6823      	ldr	r3, [r4, #0]
 8001434:	079d      	lsls	r5, r3, #30
 8001436:	d448      	bmi.n	80014ca <HAL_RCC_OscConfig+0x1ca>
 8001438:	e09f      	b.n	800157a <HAL_RCC_OscConfig+0x27a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || 
 800143a:	4d53      	ldr	r5, [pc, #332]	; (8001588 <HAL_RCC_OscConfig+0x288>)
 800143c:	68ab      	ldr	r3, [r5, #8]
 800143e:	f003 030c 	and.w	r3, r3, #12
 8001442:	2b08      	cmp	r3, #8
 8001444:	d009      	beq.n	800145a <HAL_RCC_OscConfig+0x15a>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8001446:	68ab      	ldr	r3, [r5, #8]
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || 
 8001448:	f003 030c 	and.w	r3, r3, #12
 800144c:	2b0c      	cmp	r3, #12
 800144e:	d10b      	bne.n	8001468 <HAL_RCC_OscConfig+0x168>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8001450:	68eb      	ldr	r3, [r5, #12]
 8001452:	f003 0303 	and.w	r3, r3, #3
 8001456:	2b03      	cmp	r3, #3
 8001458:	d106      	bne.n	8001468 <HAL_RCC_OscConfig+0x168>
    {
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800145a:	682b      	ldr	r3, [r5, #0]
 800145c:	0398      	lsls	r0, r3, #14
 800145e:	d5e8      	bpl.n	8001432 <HAL_RCC_OscConfig+0x132>
 8001460:	6863      	ldr	r3, [r4, #4]
 8001462:	2b00      	cmp	r3, #0
 8001464:	d1e5      	bne.n	8001432 <HAL_RCC_OscConfig+0x132>
 8001466:	e1b4      	b.n	80017d2 <HAL_RCC_OscConfig+0x4d2>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001468:	6863      	ldr	r3, [r4, #4]
 800146a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800146e:	d006      	beq.n	800147e <HAL_RCC_OscConfig+0x17e>
 8001470:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8001474:	d108      	bne.n	8001488 <HAL_RCC_OscConfig+0x188>
 8001476:	682b      	ldr	r3, [r5, #0]
 8001478:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800147c:	602b      	str	r3, [r5, #0]
 800147e:	682b      	ldr	r3, [r5, #0]
 8001480:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001484:	602b      	str	r3, [r5, #0]
 8001486:	e008      	b.n	800149a <HAL_RCC_OscConfig+0x19a>
 8001488:	682a      	ldr	r2, [r5, #0]
 800148a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800148e:	602a      	str	r2, [r5, #0]
 8001490:	682a      	ldr	r2, [r5, #0]
 8001492:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001496:	602a      	str	r2, [r5, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8001498:	b15b      	cbz	r3, 80014b2 <HAL_RCC_OscConfig+0x1b2>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800149a:	f7ff fccf 	bl	8000e3c <HAL_GetTick>
 800149e:	4606      	mov	r6, r0

        /* Wait till HSE is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET)
 80014a0:	682b      	ldr	r3, [r5, #0]
 80014a2:	0399      	lsls	r1, r3, #14
 80014a4:	d4c5      	bmi.n	8001432 <HAL_RCC_OscConfig+0x132>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80014a6:	f7ff fcc9 	bl	8000e3c <HAL_GetTick>
 80014aa:	1b80      	subs	r0, r0, r6
 80014ac:	2864      	cmp	r0, #100	; 0x64
 80014ae:	d9f7      	bls.n	80014a0 <HAL_RCC_OscConfig+0x1a0>
 80014b0:	e798      	b.n	80013e4 <HAL_RCC_OscConfig+0xe4>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80014b2:	f7ff fcc3 	bl	8000e3c <HAL_GetTick>
 80014b6:	4606      	mov	r6, r0

        /* Wait till HSE is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)
 80014b8:	682b      	ldr	r3, [r5, #0]
 80014ba:	039a      	lsls	r2, r3, #14
 80014bc:	d5b9      	bpl.n	8001432 <HAL_RCC_OscConfig+0x132>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80014be:	f7ff fcbd 	bl	8000e3c <HAL_GetTick>
 80014c2:	1b80      	subs	r0, r0, r6
 80014c4:	2864      	cmp	r0, #100	; 0x64
 80014c6:	d9f7      	bls.n	80014b8 <HAL_RCC_OscConfig+0x1b8>
 80014c8:	e78c      	b.n	80013e4 <HAL_RCC_OscConfig+0xe4>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
 80014ca:	4d2f      	ldr	r5, [pc, #188]	; (8001588 <HAL_RCC_OscConfig+0x288>)
 80014cc:	68ab      	ldr	r3, [r5, #8]
 80014ce:	f003 030c 	and.w	r3, r3, #12
 80014d2:	2b04      	cmp	r3, #4
 80014d4:	d009      	beq.n	80014ea <HAL_RCC_OscConfig+0x1ea>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 80014d6:	68ab      	ldr	r3, [r5, #8]
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
 80014d8:	f003 030c 	and.w	r3, r3, #12
 80014dc:	2b0c      	cmp	r3, #12
 80014de:	d11a      	bne.n	8001516 <HAL_RCC_OscConfig+0x216>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 80014e0:	68eb      	ldr	r3, [r5, #12]
 80014e2:	f003 0303 	and.w	r3, r3, #3
 80014e6:	2b02      	cmp	r3, #2
 80014e8:	d115      	bne.n	8001516 <HAL_RCC_OscConfig+0x216>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80014ea:	682b      	ldr	r3, [r5, #0]
 80014ec:	055b      	lsls	r3, r3, #21
 80014ee:	d503      	bpl.n	80014f8 <HAL_RCC_OscConfig+0x1f8>
 80014f0:	68e3      	ldr	r3, [r4, #12]
 80014f2:	2b00      	cmp	r3, #0
 80014f4:	f000 816d 	beq.w	80017d2 <HAL_RCC_OscConfig+0x4d2>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80014f8:	686b      	ldr	r3, [r5, #4]
 80014fa:	f04f 52f8 	mov.w	r2, #520093696	; 0x1f000000
 80014fe:	fa92 f2a2 	rbit	r2, r2
 8001502:	6921      	ldr	r1, [r4, #16]
 8001504:	fab2 f282 	clz	r2, r2
 8001508:	fa01 f202 	lsl.w	r2, r1, r2
 800150c:	f023 53f8 	bic.w	r3, r3, #520093696	; 0x1f000000
 8001510:	4313      	orrs	r3, r2
 8001512:	606b      	str	r3, [r5, #4]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
    {
      /* When HSI is used as system clock it will not be disabled */
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8001514:	e031      	b.n	800157a <HAL_RCC_OscConfig+0x27a>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8001516:	68e3      	ldr	r3, [r4, #12]
 8001518:	b1fb      	cbz	r3, 800155a <HAL_RCC_OscConfig+0x25a>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800151a:	682b      	ldr	r3, [r5, #0]
 800151c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001520:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001522:	f7ff fc8b 	bl	8000e3c <HAL_GetTick>
 8001526:	4606      	mov	r6, r0

        /* Wait till HSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
 8001528:	682b      	ldr	r3, [r5, #0]
 800152a:	4817      	ldr	r0, [pc, #92]	; (8001588 <HAL_RCC_OscConfig+0x288>)
 800152c:	055f      	lsls	r7, r3, #21
 800152e:	d405      	bmi.n	800153c <HAL_RCC_OscConfig+0x23c>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001530:	f7ff fc84 	bl	8000e3c <HAL_GetTick>
 8001534:	1b80      	subs	r0, r0, r6
 8001536:	2802      	cmp	r0, #2
 8001538:	d9f6      	bls.n	8001528 <HAL_RCC_OscConfig+0x228>
 800153a:	e753      	b.n	80013e4 <HAL_RCC_OscConfig+0xe4>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800153c:	6843      	ldr	r3, [r0, #4]
 800153e:	f04f 52f8 	mov.w	r2, #520093696	; 0x1f000000
 8001542:	fa92 f2a2 	rbit	r2, r2
 8001546:	6921      	ldr	r1, [r4, #16]
 8001548:	fab2 f282 	clz	r2, r2
 800154c:	fa01 f202 	lsl.w	r2, r1, r2
 8001550:	f023 53f8 	bic.w	r3, r3, #520093696	; 0x1f000000
 8001554:	4313      	orrs	r3, r2
 8001556:	6043      	str	r3, [r0, #4]
 8001558:	e00f      	b.n	800157a <HAL_RCC_OscConfig+0x27a>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800155a:	682b      	ldr	r3, [r5, #0]
 800155c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001560:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001562:	f7ff fc6b 	bl	8000e3c <HAL_GetTick>
 8001566:	4606      	mov	r6, r0

        /* Wait till HSI is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != RESET)
 8001568:	682b      	ldr	r3, [r5, #0]
 800156a:	0558      	lsls	r0, r3, #21
 800156c:	d505      	bpl.n	800157a <HAL_RCC_OscConfig+0x27a>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800156e:	f7ff fc65 	bl	8000e3c <HAL_GetTick>
 8001572:	1b80      	subs	r0, r0, r6
 8001574:	2802      	cmp	r0, #2
 8001576:	d9f7      	bls.n	8001568 <HAL_RCC_OscConfig+0x268>
 8001578:	e734      	b.n	80013e4 <HAL_RCC_OscConfig+0xe4>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800157a:	6823      	ldr	r3, [r4, #0]
 800157c:	0719      	lsls	r1, r3, #28
 800157e:	d409      	bmi.n	8001594 <HAL_RCC_OscConfig+0x294>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8001580:	6823      	ldr	r3, [r4, #0]
 8001582:	075a      	lsls	r2, r3, #29
 8001584:	d42f      	bmi.n	80015e6 <HAL_RCC_OscConfig+0x2e6>
 8001586:	e097      	b.n	80016b8 <HAL_RCC_OscConfig+0x3b8>
 8001588:	40021000 	.word	0x40021000
 800158c:	08004569 	.word	0x08004569
 8001590:	20000008 	.word	0x20000008
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8001594:	6963      	ldr	r3, [r4, #20]
 8001596:	4d91      	ldr	r5, [pc, #580]	; (80017dc <HAL_RCC_OscConfig+0x4dc>)
 8001598:	b193      	cbz	r3, 80015c0 <HAL_RCC_OscConfig+0x2c0>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800159a:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 800159e:	f043 0301 	orr.w	r3, r3, #1
 80015a2:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80015a6:	f7ff fc49 	bl	8000e3c <HAL_GetTick>
 80015aa:	4606      	mov	r6, r0

      /* Wait till LSI is ready */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == RESET)
 80015ac:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 80015b0:	079b      	lsls	r3, r3, #30
 80015b2:	d4e5      	bmi.n	8001580 <HAL_RCC_OscConfig+0x280>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80015b4:	f7ff fc42 	bl	8000e3c <HAL_GetTick>
 80015b8:	1b80      	subs	r0, r0, r6
 80015ba:	2802      	cmp	r0, #2
 80015bc:	d9f6      	bls.n	80015ac <HAL_RCC_OscConfig+0x2ac>
 80015be:	e711      	b.n	80013e4 <HAL_RCC_OscConfig+0xe4>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 80015c0:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 80015c4:	f023 0301 	bic.w	r3, r3, #1
 80015c8:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80015cc:	f7ff fc36 	bl	8000e3c <HAL_GetTick>
 80015d0:	4606      	mov	r6, r0

      /* Wait till LSI is disabled */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != RESET)
 80015d2:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 80015d6:	079f      	lsls	r7, r3, #30
 80015d8:	d5d2      	bpl.n	8001580 <HAL_RCC_OscConfig+0x280>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80015da:	f7ff fc2f 	bl	8000e3c <HAL_GetTick>
 80015de:	1b80      	subs	r0, r0, r6
 80015e0:	2802      	cmp	r0, #2
 80015e2:	d9f6      	bls.n	80015d2 <HAL_RCC_OscConfig+0x2d2>
 80015e4:	e6fe      	b.n	80013e4 <HAL_RCC_OscConfig+0xe4>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 80015e6:	4d7d      	ldr	r5, [pc, #500]	; (80017dc <HAL_RCC_OscConfig+0x4dc>)
 80015e8:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80015ea:	00d8      	lsls	r0, r3, #3
 80015ec:	d40a      	bmi.n	8001604 <HAL_RCC_OscConfig+0x304>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80015ee:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80015f0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80015f4:	65ab      	str	r3, [r5, #88]	; 0x58
 80015f6:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80015f8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80015fc:	9301      	str	r3, [sp, #4]
 80015fe:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8001600:	2701      	movs	r7, #1
 8001602:	e000      	b.n	8001606 <HAL_RCC_OscConfig+0x306>
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
  {
    FlagStatus       pwrclkchanged = RESET;
 8001604:	2700      	movs	r7, #0
    {
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8001606:	4e76      	ldr	r6, [pc, #472]	; (80017e0 <HAL_RCC_OscConfig+0x4e0>)
 8001608:	6833      	ldr	r3, [r6, #0]
 800160a:	05d9      	lsls	r1, r3, #23
 800160c:	d503      	bpl.n	8001616 <HAL_RCC_OscConfig+0x316>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800160e:	68a3      	ldr	r3, [r4, #8]
 8001610:	2b01      	cmp	r3, #1
 8001612:	d111      	bne.n	8001638 <HAL_RCC_OscConfig+0x338>
 8001614:	e018      	b.n	8001648 <HAL_RCC_OscConfig+0x348>
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8001616:	6833      	ldr	r3, [r6, #0]
 8001618:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800161c:	6033      	str	r3, [r6, #0]
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800161e:	f7ff fc0d 	bl	8000e3c <HAL_GetTick>
 8001622:	4680      	mov	r8, r0

      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8001624:	6833      	ldr	r3, [r6, #0]
 8001626:	05da      	lsls	r2, r3, #23
 8001628:	d4f1      	bmi.n	800160e <HAL_RCC_OscConfig+0x30e>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800162a:	f7ff fc07 	bl	8000e3c <HAL_GetTick>
 800162e:	ebc8 0000 	rsb	r0, r8, r0
 8001632:	2802      	cmp	r0, #2
 8001634:	d9f6      	bls.n	8001624 <HAL_RCC_OscConfig+0x324>
 8001636:	e6d5      	b.n	80013e4 <HAL_RCC_OscConfig+0xe4>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001638:	2b05      	cmp	r3, #5
 800163a:	d10c      	bne.n	8001656 <HAL_RCC_OscConfig+0x356>
 800163c:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 8001640:	f043 0304 	orr.w	r3, r3, #4
 8001644:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
 8001648:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800164c:	f043 0301 	orr.w	r3, r3, #1
 8001650:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
 8001654:	e00c      	b.n	8001670 <HAL_RCC_OscConfig+0x370>
 8001656:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 800165a:	f022 0201 	bic.w	r2, r2, #1
 800165e:	f8c5 2090 	str.w	r2, [r5, #144]	; 0x90
 8001662:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 8001666:	f022 0204 	bic.w	r2, r2, #4
 800166a:	f8c5 2090 	str.w	r2, [r5, #144]	; 0x90

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 800166e:	b173      	cbz	r3, 800168e <HAL_RCC_OscConfig+0x38e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001670:	f7ff fbe4 	bl	8000e3c <HAL_GetTick>

      /* Wait till LSE is ready */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001674:	f241 3888 	movw	r8, #5000	; 0x1388

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001678:	4606      	mov	r6, r0

      /* Wait till LSE is ready */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
 800167a:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800167e:	079b      	lsls	r3, r3, #30
 8001680:	d40e      	bmi.n	80016a0 <HAL_RCC_OscConfig+0x3a0>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001682:	f7ff fbdb 	bl	8000e3c <HAL_GetTick>
 8001686:	1b80      	subs	r0, r0, r6
 8001688:	4540      	cmp	r0, r8
 800168a:	d9f6      	bls.n	800167a <HAL_RCC_OscConfig+0x37a>
 800168c:	e6aa      	b.n	80013e4 <HAL_RCC_OscConfig+0xe4>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800168e:	f7ff fbd5 	bl	8000e3c <HAL_GetTick>

      /* Wait till LSE is disabled */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001692:	f241 3888 	movw	r8, #5000	; 0x1388
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001696:	4606      	mov	r6, r0

      /* Wait till LSE is disabled */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != RESET)
 8001698:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800169c:	0798      	lsls	r0, r3, #30
 800169e:	d405      	bmi.n	80016ac <HAL_RCC_OscConfig+0x3ac>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 80016a0:	b157      	cbz	r7, 80016b8 <HAL_RCC_OscConfig+0x3b8>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 80016a2:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80016a4:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80016a8:	65ab      	str	r3, [r5, #88]	; 0x58
 80016aa:	e005      	b.n	80016b8 <HAL_RCC_OscConfig+0x3b8>
      tickstart = HAL_GetTick();

      /* Wait till LSE is disabled */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80016ac:	f7ff fbc6 	bl	8000e3c <HAL_GetTick>
 80016b0:	1b80      	subs	r0, r0, r6
 80016b2:	4540      	cmp	r0, r8
 80016b4:	d9f0      	bls.n	8001698 <HAL_RCC_OscConfig+0x398>
 80016b6:	e695      	b.n	80013e4 <HAL_RCC_OscConfig+0xe4>
      __HAL_RCC_PWR_CLK_DISABLE();
    }
  }
#if defined(RCC_HSI48_SUPPORT)
  /*------------------------------ HSI48 Configuration -----------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 80016b8:	6823      	ldr	r3, [r4, #0]
 80016ba:	0699      	lsls	r1, r3, #26
 80016bc:	d402      	bmi.n	80016c4 <HAL_RCC_OscConfig+0x3c4>
#endif /* RCC_HSI48_SUPPORT */
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 80016be:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80016c0:	bb4a      	cbnz	r2, 8001716 <HAL_RCC_OscConfig+0x416>
 80016c2:	e05f      	b.n	8001784 <HAL_RCC_OscConfig+0x484>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the LSI State */
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 80016c4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80016c6:	4d45      	ldr	r5, [pc, #276]	; (80017dc <HAL_RCC_OscConfig+0x4dc>)
 80016c8:	b193      	cbz	r3, 80016f0 <HAL_RCC_OscConfig+0x3f0>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 80016ca:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 80016ce:	f043 0301 	orr.w	r3, r3, #1
 80016d2:	f8c5 3098 	str.w	r3, [r5, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80016d6:	f7ff fbb1 	bl	8000e3c <HAL_GetTick>
 80016da:	4606      	mov	r6, r0

      /* Wait till HSI48 is ready */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == RESET)
 80016dc:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 80016e0:	079a      	lsls	r2, r3, #30
 80016e2:	d4ec      	bmi.n	80016be <HAL_RCC_OscConfig+0x3be>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 80016e4:	f7ff fbaa 	bl	8000e3c <HAL_GetTick>
 80016e8:	1b80      	subs	r0, r0, r6
 80016ea:	2802      	cmp	r0, #2
 80016ec:	d9f6      	bls.n	80016dc <HAL_RCC_OscConfig+0x3dc>
 80016ee:	e679      	b.n	80013e4 <HAL_RCC_OscConfig+0xe4>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
 80016f0:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 80016f4:	f023 0301 	bic.w	r3, r3, #1
 80016f8:	f8c5 3098 	str.w	r3, [r5, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80016fc:	f7ff fb9e 	bl	8000e3c <HAL_GetTick>
 8001700:	4606      	mov	r6, r0

      /* Wait till HSI48 is disabled */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != RESET)
 8001702:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 8001706:	079b      	lsls	r3, r3, #30
 8001708:	d5d9      	bpl.n	80016be <HAL_RCC_OscConfig+0x3be>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800170a:	f7ff fb97 	bl	8000e3c <HAL_GetTick>
 800170e:	1b80      	subs	r0, r0, r6
 8001710:	2802      	cmp	r0, #2
 8001712:	d9f6      	bls.n	8001702 <HAL_RCC_OscConfig+0x402>
 8001714:	e666      	b.n	80013e4 <HAL_RCC_OscConfig+0xe4>
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8001716:	4d31      	ldr	r5, [pc, #196]	; (80017dc <HAL_RCC_OscConfig+0x4dc>)
 8001718:	68ab      	ldr	r3, [r5, #8]
 800171a:	f003 030c 	and.w	r3, r3, #12
 800171e:	2b0c      	cmp	r3, #12
 8001720:	d057      	beq.n	80017d2 <HAL_RCC_OscConfig+0x4d2>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001722:	682b      	ldr	r3, [r5, #0]
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    {
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8001724:	2a02      	cmp	r2, #2
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001726:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800172a:	602b      	str	r3, [r5, #0]
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    {
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 800172c:	d138      	bne.n	80017a0 <HAL_RCC_OscConfig+0x4a0>

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800172e:	f7ff fb85 	bl	8000e3c <HAL_GetTick>
 8001732:	4606      	mov	r6, r0

        /* Wait till PLL is ready */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
 8001734:	682b      	ldr	r3, [r5, #0]
 8001736:	4829      	ldr	r0, [pc, #164]	; (80017dc <HAL_RCC_OscConfig+0x4dc>)
 8001738:	019f      	lsls	r7, r3, #6
 800173a:	d425      	bmi.n	8001788 <HAL_RCC_OscConfig+0x488>
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800173c:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 800173e:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8001740:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8001742:	06f6      	lsls	r6, r6, #27
 8001744:	ea46 2103 	orr.w	r1, r6, r3, lsl #8
 8001748:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800174a:	3a01      	subs	r2, #1
 800174c:	430b      	orrs	r3, r1
 800174e:	ea43 1102 	orr.w	r1, r3, r2, lsl #4
 8001752:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001754:	085b      	lsrs	r3, r3, #1
 8001756:	3b01      	subs	r3, #1
 8001758:	ea41 5243 	orr.w	r2, r1, r3, lsl #21
 800175c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800175e:	085b      	lsrs	r3, r3, #1
 8001760:	3b01      	subs	r3, #1
 8001762:	ea42 6343 	orr.w	r3, r2, r3, lsl #25
 8001766:	60c3      	str	r3, [r0, #12]
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8001768:	6803      	ldr	r3, [r0, #0]
 800176a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800176e:	6003      	str	r3, [r0, #0]

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8001770:	68c3      	ldr	r3, [r0, #12]
 8001772:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001776:	60c3      	str	r3, [r0, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001778:	f7ff fb60 	bl	8000e3c <HAL_GetTick>
 800177c:	4604      	mov	r4, r0

        /* Wait till PLL is ready */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 800177e:	682b      	ldr	r3, [r5, #0]
 8001780:	0199      	lsls	r1, r3, #6
 8001782:	d507      	bpl.n	8001794 <HAL_RCC_OscConfig+0x494>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8001784:	2000      	movs	r0, #0
 8001786:	e025      	b.n	80017d4 <HAL_RCC_OscConfig+0x4d4>
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001788:	f7ff fb58 	bl	8000e3c <HAL_GetTick>
 800178c:	1b80      	subs	r0, r0, r6
 800178e:	2802      	cmp	r0, #2
 8001790:	d9d0      	bls.n	8001734 <HAL_RCC_OscConfig+0x434>
 8001792:	e627      	b.n	80013e4 <HAL_RCC_OscConfig+0xe4>
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001794:	f7ff fb52 	bl	8000e3c <HAL_GetTick>
 8001798:	1b00      	subs	r0, r0, r4
 800179a:	2802      	cmp	r0, #2
 800179c:	d9ef      	bls.n	800177e <HAL_RCC_OscConfig+0x47e>
 800179e:	e621      	b.n	80013e4 <HAL_RCC_OscConfig+0xe4>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Disable all PLL outputs to save power if no PLLs on */
        if((READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == RESET)
 80017a0:	682b      	ldr	r3, [r5, #0]
 80017a2:	011a      	lsls	r2, r3, #4
           && 
           (READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == RESET)
#endif /* RCC_PLLSAI2_SUPPORT */
          )
        {  
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 80017a4:	bf5e      	ittt	pl
 80017a6:	68eb      	ldrpl	r3, [r5, #12]
 80017a8:	f023 0303 	bicpl.w	r3, r3, #3
 80017ac:	60eb      	strpl	r3, [r5, #12]
        }
        
#if defined(RCC_PLLSAI2_SUPPORT)
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
#else
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI2CLK);
 80017ae:	68eb      	ldr	r3, [r5, #12]
 80017b0:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 80017b4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80017b8:	60eb      	str	r3, [r5, #12]
#endif /* RCC_PLLSAI2_SUPPORT */

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80017ba:	f7ff fb3f 	bl	8000e3c <HAL_GetTick>
 80017be:	4604      	mov	r4, r0

        /* Wait till PLL is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
 80017c0:	682b      	ldr	r3, [r5, #0]
 80017c2:	019b      	lsls	r3, r3, #6
 80017c4:	d5de      	bpl.n	8001784 <HAL_RCC_OscConfig+0x484>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80017c6:	f7ff fb39 	bl	8000e3c <HAL_GetTick>
 80017ca:	1b00      	subs	r0, r0, r4
 80017cc:	2802      	cmp	r0, #2
 80017ce:	d9f7      	bls.n	80017c0 <HAL_RCC_OscConfig+0x4c0>
 80017d0:	e608      	b.n	80013e4 <HAL_RCC_OscConfig+0xe4>
        }
      }
    }
    else
    {
      return HAL_ERROR;
 80017d2:	2001      	movs	r0, #1
    }
  }
  return HAL_OK;
}
 80017d4:	b002      	add	sp, #8
 80017d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80017da:	bf00      	nop
 80017dc:	40021000 	.word	0x40021000
 80017e0:	40007000 	.word	0x40007000

080017e4 <HAL_RCC_ClockConfig>:
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 80017e4:	4a57      	ldr	r2, [pc, #348]	; (8001944 <HAL_RCC_ClockConfig+0x160>)
 80017e6:	6813      	ldr	r3, [r2, #0]
 80017e8:	f003 0307 	and.w	r3, r3, #7
 80017ec:	428b      	cmp	r3, r1
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 80017ee:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80017f2:	4605      	mov	r5, r0
 80017f4:	460e      	mov	r6, r1
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 80017f6:	d30a      	bcc.n	800180e <HAL_RCC_ClockConfig+0x2a>
      return HAL_ERROR;
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80017f8:	6829      	ldr	r1, [r5, #0]
 80017fa:	0788      	lsls	r0, r1, #30
 80017fc:	d514      	bpl.n	8001828 <HAL_RCC_ClockConfig+0x44>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80017fe:	4852      	ldr	r0, [pc, #328]	; (8001948 <HAL_RCC_ClockConfig+0x164>)
 8001800:	6883      	ldr	r3, [r0, #8]
 8001802:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8001806:	68ab      	ldr	r3, [r5, #8]
 8001808:	4313      	orrs	r3, r2
 800180a:	6083      	str	r3, [r0, #8]
 800180c:	e00c      	b.n	8001828 <HAL_RCC_ClockConfig+0x44>

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800180e:	6813      	ldr	r3, [r2, #0]
 8001810:	f023 0307 	bic.w	r3, r3, #7
 8001814:	430b      	orrs	r3, r1
 8001816:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8001818:	6813      	ldr	r3, [r2, #0]
 800181a:	f003 0307 	and.w	r3, r3, #7
 800181e:	4299      	cmp	r1, r3
 8001820:	d0ea      	beq.n	80017f8 <HAL_RCC_ClockConfig+0x14>
    {
      return HAL_ERROR;
 8001822:	2001      	movs	r0, #1
 8001824:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001828:	07ca      	lsls	r2, r1, #31
 800182a:	d406      	bmi.n	800183a <HAL_RCC_ClockConfig+0x56>
      }
    }
  }
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 800182c:	4a45      	ldr	r2, [pc, #276]	; (8001944 <HAL_RCC_ClockConfig+0x160>)
 800182e:	6813      	ldr	r3, [r2, #0]
 8001830:	f003 0307 	and.w	r3, r3, #7
 8001834:	429e      	cmp	r6, r3
 8001836:	d351      	bcc.n	80018dc <HAL_RCC_ClockConfig+0xf8>
 8001838:	e05a      	b.n	80018f0 <HAL_RCC_ClockConfig+0x10c>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800183a:	686b      	ldr	r3, [r5, #4]
 800183c:	4c42      	ldr	r4, [pc, #264]	; (8001948 <HAL_RCC_ClockConfig+0x164>)
 800183e:	2b02      	cmp	r3, #2
    {
      /* Check the HSE ready flag */
      if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET)
 8001840:	6822      	ldr	r2, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001842:	d102      	bne.n	800184a <HAL_RCC_ClockConfig+0x66>
    {
      /* Check the HSE ready flag */
      if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET)
 8001844:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8001848:	e00a      	b.n	8001860 <HAL_RCC_ClockConfig+0x7c>
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800184a:	2b03      	cmp	r3, #3
 800184c:	d102      	bne.n	8001854 <HAL_RCC_ClockConfig+0x70>
    {
      /* Check the PLL ready flag */
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 800184e:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8001852:	e005      	b.n	8001860 <HAL_RCC_ClockConfig+0x7c>
      {
        return HAL_ERROR;
      }
    }
    /* MSI is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8001854:	b913      	cbnz	r3, 800185c <HAL_RCC_ClockConfig+0x78>
    {
      /* Check the MSI ready flag */
      if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET)
 8001856:	f012 0f02 	tst.w	r2, #2
 800185a:	e001      	b.n	8001860 <HAL_RCC_ClockConfig+0x7c>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
 800185c:	f412 6f80 	tst.w	r2, #1024	; 0x400
 8001860:	d0df      	beq.n	8001822 <HAL_RCC_ClockConfig+0x3e>
      {
        return HAL_ERROR;
      }
    }
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8001862:	68a2      	ldr	r2, [r4, #8]
 8001864:	f022 0203 	bic.w	r2, r2, #3
 8001868:	4313      	orrs	r3, r2
 800186a:	60a3      	str	r3, [r4, #8]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800186c:	f7ff fae6 	bl	8000e3c <HAL_GetTick>

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001870:	686b      	ldr	r3, [r5, #4]
 8001872:	2b02      	cmp	r3, #2
      }
    }
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001874:	4607      	mov	r7, r0

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
      {
        if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001876:	f241 3888 	movw	r8, #5000	; 0x1388
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800187a:	d10c      	bne.n	8001896 <HAL_RCC_ClockConfig+0xb2>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 800187c:	68a3      	ldr	r3, [r4, #8]
 800187e:	f003 030c 	and.w	r3, r3, #12
 8001882:	2b08      	cmp	r3, #8
 8001884:	d0d2      	beq.n	800182c <HAL_RCC_ClockConfig+0x48>
      {
        if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001886:	f7ff fad9 	bl	8000e3c <HAL_GetTick>
 800188a:	1bc0      	subs	r0, r0, r7
 800188c:	4540      	cmp	r0, r8
 800188e:	d9f5      	bls.n	800187c <HAL_RCC_ClockConfig+0x98>
        {
          return HAL_TIMEOUT;
 8001890:	2003      	movs	r0, #3
 8001892:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001896:	2b03      	cmp	r3, #3
 8001898:	d10a      	bne.n	80018b0 <HAL_RCC_ClockConfig+0xcc>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800189a:	68a3      	ldr	r3, [r4, #8]
 800189c:	f003 030c 	and.w	r3, r3, #12
 80018a0:	2b0c      	cmp	r3, #12
 80018a2:	d0c3      	beq.n	800182c <HAL_RCC_ClockConfig+0x48>
      {
        if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80018a4:	f7ff faca 	bl	8000e3c <HAL_GetTick>
 80018a8:	1bc0      	subs	r0, r0, r7
 80018aa:	4540      	cmp	r0, r8
 80018ac:	d9f5      	bls.n	800189a <HAL_RCC_ClockConfig+0xb6>
 80018ae:	e7ef      	b.n	8001890 <HAL_RCC_ClockConfig+0xac>
        {
          return HAL_TIMEOUT;
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 80018b0:	b973      	cbnz	r3, 80018d0 <HAL_RCC_ClockConfig+0xec>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
 80018b2:	68a3      	ldr	r3, [r4, #8]
 80018b4:	f013 0f0c 	tst.w	r3, #12
 80018b8:	d0b8      	beq.n	800182c <HAL_RCC_ClockConfig+0x48>
      {
        if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80018ba:	f7ff fabf 	bl	8000e3c <HAL_GetTick>
 80018be:	1bc0      	subs	r0, r0, r7
 80018c0:	4540      	cmp	r0, r8
 80018c2:	d9f6      	bls.n	80018b2 <HAL_RCC_ClockConfig+0xce>
 80018c4:	e7e4      	b.n	8001890 <HAL_RCC_ClockConfig+0xac>
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
      {
        if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80018c6:	f7ff fab9 	bl	8000e3c <HAL_GetTick>
 80018ca:	1bc0      	subs	r0, r0, r7
 80018cc:	4540      	cmp	r0, r8
 80018ce:	d8df      	bhi.n	8001890 <HAL_RCC_ClockConfig+0xac>
        }
      }
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 80018d0:	68a3      	ldr	r3, [r4, #8]
 80018d2:	f003 030c 	and.w	r3, r3, #12
 80018d6:	2b04      	cmp	r3, #4
 80018d8:	d1f5      	bne.n	80018c6 <HAL_RCC_ClockConfig+0xe2>
 80018da:	e7a7      	b.n	800182c <HAL_RCC_ClockConfig+0x48>
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80018dc:	6813      	ldr	r3, [r2, #0]
 80018de:	f023 0307 	bic.w	r3, r3, #7
 80018e2:	4333      	orrs	r3, r6
 80018e4:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80018e6:	6813      	ldr	r3, [r2, #0]
 80018e8:	f003 0307 	and.w	r3, r3, #7
 80018ec:	429e      	cmp	r6, r3
 80018ee:	d198      	bne.n	8001822 <HAL_RCC_ClockConfig+0x3e>
      return HAL_ERROR;
    }
  }
  
  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80018f0:	6829      	ldr	r1, [r5, #0]
 80018f2:	4c15      	ldr	r4, [pc, #84]	; (8001948 <HAL_RCC_ClockConfig+0x164>)
 80018f4:	f011 0f04 	tst.w	r1, #4
 80018f8:	d005      	beq.n	8001906 <HAL_RCC_ClockConfig+0x122>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80018fa:	68a3      	ldr	r3, [r4, #8]
 80018fc:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 8001900:	68eb      	ldr	r3, [r5, #12]
 8001902:	4313      	orrs	r3, r2
 8001904:	60a3      	str	r3, [r4, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001906:	070b      	lsls	r3, r1, #28
 8001908:	d506      	bpl.n	8001918 <HAL_RCC_ClockConfig+0x134>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 800190a:	68a3      	ldr	r3, [r4, #8]
 800190c:	692a      	ldr	r2, [r5, #16]
 800190e:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8001912:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8001916:	60a3      	str	r3, [r4, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8001918:	f7ff fc54 	bl	80011c4 <HAL_RCC_GetSysClockFreq>
 800191c:	68a3      	ldr	r3, [r4, #8]
 800191e:	22f0      	movs	r2, #240	; 0xf0
 8001920:	fa92 f2a2 	rbit	r2, r2
 8001924:	fab2 f282 	clz	r2, r2
 8001928:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800192c:	40d3      	lsrs	r3, r2
 800192e:	4a07      	ldr	r2, [pc, #28]	; (800194c <HAL_RCC_ClockConfig+0x168>)
 8001930:	5cd3      	ldrb	r3, [r2, r3]
 8001932:	40d8      	lsrs	r0, r3
 8001934:	4b06      	ldr	r3, [pc, #24]	; (8001950 <HAL_RCC_ClockConfig+0x16c>)
 8001936:	6018      	str	r0, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8001938:	2000      	movs	r0, #0
 800193a:	f7ff fa57 	bl	8000dec <HAL_InitTick>

  return HAL_OK;
 800193e:	2000      	movs	r0, #0
}
 8001940:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001944:	40022000 	.word	0x40022000
 8001948:	40021000 	.word	0x40021000
 800194c:	08004569 	.word	0x08004569
 8001950:	20000008 	.word	0x20000008

08001954 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 8001954:	4b01      	ldr	r3, [pc, #4]	; (800195c <HAL_RCC_GetHCLKFreq+0x8>)
 8001956:	6818      	ldr	r0, [r3, #0]
 8001958:	4770      	bx	lr
 800195a:	bf00      	nop
 800195c:	20000008 	.word	0x20000008

08001960 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 8001960:	4b08      	ldr	r3, [pc, #32]	; (8001984 <HAL_RCC_GetPCLK1Freq+0x24>)
 8001962:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 8001966:	689b      	ldr	r3, [r3, #8]
 8001968:	fa92 f2a2 	rbit	r2, r2
 800196c:	fab2 f282 	clz	r2, r2
 8001970:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8001974:	40d3      	lsrs	r3, r2
 8001976:	4a04      	ldr	r2, [pc, #16]	; (8001988 <HAL_RCC_GetPCLK1Freq+0x28>)
 8001978:	5cd3      	ldrb	r3, [r2, r3]
 800197a:	4a04      	ldr	r2, [pc, #16]	; (800198c <HAL_RCC_GetPCLK1Freq+0x2c>)
 800197c:	6810      	ldr	r0, [r2, #0]
}
 800197e:	40d8      	lsrs	r0, r3
 8001980:	4770      	bx	lr
 8001982:	bf00      	nop
 8001984:	40021000 	.word	0x40021000
 8001988:	08004579 	.word	0x08004579
 800198c:	20000008 	.word	0x20000008

08001990 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 8001990:	4b08      	ldr	r3, [pc, #32]	; (80019b4 <HAL_RCC_GetPCLK2Freq+0x24>)
 8001992:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001996:	689b      	ldr	r3, [r3, #8]
 8001998:	fa92 f2a2 	rbit	r2, r2
 800199c:	fab2 f282 	clz	r2, r2
 80019a0:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
 80019a4:	40d3      	lsrs	r3, r2
 80019a6:	4a04      	ldr	r2, [pc, #16]	; (80019b8 <HAL_RCC_GetPCLK2Freq+0x28>)
 80019a8:	5cd3      	ldrb	r3, [r2, r3]
 80019aa:	4a04      	ldr	r2, [pc, #16]	; (80019bc <HAL_RCC_GetPCLK2Freq+0x2c>)
 80019ac:	6810      	ldr	r0, [r2, #0]
}
 80019ae:	40d8      	lsrs	r0, r3
 80019b0:	4770      	bx	lr
 80019b2:	bf00      	nop
 80019b4:	40021000 	.word	0x40021000
 80019b8:	08004579 	.word	0x08004579
 80019bc:	20000008 	.word	0x20000008

080019c0 <RCCEx_PLLSAI1_Config>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *PllSai1, uint32_t Divider)
{
 80019c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));
  
  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 80019c2:	4b5a      	ldr	r3, [pc, #360]	; (8001b2c <RCCEx_PLLSAI1_Config+0x16c>)
 80019c4:	68da      	ldr	r2, [r3, #12]
 80019c6:	f012 0f03 	tst.w	r2, #3
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *PllSai1, uint32_t Divider)
{
 80019ca:	4604      	mov	r4, r0
 80019cc:	460e      	mov	r6, r1
 80019ce:	461d      	mov	r5, r3
 80019d0:	6800      	ldr	r0, [r0, #0]
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));
  
  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 80019d2:	d013      	beq.n	80019fc <RCCEx_PLLSAI1_Config+0x3c>
  {
    /* PLL clock source and divider M already set, check that no request for change  */ 
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
 80019d4:	68da      	ldr	r2, [r3, #12]
 80019d6:	f002 0203 	and.w	r2, r2, #3
 80019da:	4282      	cmp	r2, r0
 80019dc:	d124      	bne.n	8001a28 <RCCEx_PLLSAI1_Config+0x68>
       || 
 80019de:	b31a      	cbz	r2, 8001a28 <RCCEx_PLLSAI1_Config+0x68>
       (PllSai1->PLLSAI1Source == RCC_PLLSOURCE_NONE)
       || 
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> POSITION_VAL(RCC_PLLCFGR_PLLM)) + 1U) != PllSai1->PLLSAI1M)
 80019e0:	68da      	ldr	r2, [r3, #12]
 80019e2:	2370      	movs	r3, #112	; 0x70
 80019e4:	fa93 f3a3 	rbit	r3, r3
 80019e8:	fab3 f183 	clz	r1, r3
  {
    /* PLL clock source and divider M already set, check that no request for change  */ 
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
       || 
       (PllSai1->PLLSAI1Source == RCC_PLLSOURCE_NONE)
       || 
 80019ec:	f002 0370 	and.w	r3, r2, #112	; 0x70
 80019f0:	40cb      	lsrs	r3, r1
 80019f2:	6862      	ldr	r2, [r4, #4]
 80019f4:	3301      	adds	r3, #1
 80019f6:	4293      	cmp	r3, r2
 80019f8:	d116      	bne.n	8001a28 <RCCEx_PLLSAI1_Config+0x68>
 80019fa:	e025      	b.n	8001a48 <RCCEx_PLLSAI1_Config+0x88>
    }
  }
  else
  {
    /* Check PLLSAI1 clock source availability */
    switch(PllSai1->PLLSAI1Source)
 80019fc:	2802      	cmp	r0, #2
 80019fe:	d008      	beq.n	8001a12 <RCCEx_PLLSAI1_Config+0x52>
 8001a00:	2803      	cmp	r0, #3
 8001a02:	d00a      	beq.n	8001a1a <RCCEx_PLLSAI1_Config+0x5a>
 8001a04:	2801      	cmp	r0, #1
 8001a06:	d10f      	bne.n	8001a28 <RCCEx_PLLSAI1_Config+0x68>
    {
    case RCC_PLLSOURCE_MSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 8001a08:	681b      	ldr	r3, [r3, #0]
 8001a0a:	079f      	lsls	r7, r3, #30
 8001a0c:	f140 808d 	bpl.w	8001b2a <RCCEx_PLLSAI1_Config+0x16a>
 8001a10:	e00c      	b.n	8001a2c <RCCEx_PLLSAI1_Config+0x6c>
      {
        status = HAL_ERROR;
      }
      break;
    case RCC_PLLSOURCE_HSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 8001a12:	681b      	ldr	r3, [r3, #0]
 8001a14:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8001a18:	e005      	b.n	8001a26 <RCCEx_PLLSAI1_Config+0x66>
      {
        status = HAL_ERROR;
      }
      break;
    case RCC_PLLSOURCE_HSE:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY) && HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8001a1a:	681a      	ldr	r2, [r3, #0]
 8001a1c:	0391      	lsls	r1, r2, #14
 8001a1e:	d405      	bmi.n	8001a2c <RCCEx_PLLSAI1_Config+0x6c>
 8001a20:	681b      	ldr	r3, [r3, #0]
 8001a22:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 8001a26:	d101      	bne.n	8001a2c <RCCEx_PLLSAI1_Config+0x6c>
 8001a28:	2001      	movs	r0, #1
 8001a2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
    
    if(status == HAL_OK)
    {
      /* Set PLLSAI1 clock source and divider M */
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai1->PLLSAI1Source | (PllSai1->PLLSAI1M - 1U) << POSITION_VAL(RCC_PLLCFGR_PLLM));
 8001a2c:	68e9      	ldr	r1, [r5, #12]
 8001a2e:	2370      	movs	r3, #112	; 0x70
 8001a30:	fa93 f3a3 	rbit	r3, r3
 8001a34:	fab3 f283 	clz	r2, r3
 8001a38:	6863      	ldr	r3, [r4, #4]
 8001a3a:	3b01      	subs	r3, #1
 8001a3c:	4093      	lsls	r3, r2
 8001a3e:	f021 0273 	bic.w	r2, r1, #115	; 0x73
 8001a42:	4310      	orrs	r0, r2
 8001a44:	4318      	orrs	r0, r3
 8001a46:	60e8      	str	r0, [r5, #12]
  }
  
  if(status == HAL_OK)
  {
    /* Disable the PLLSAI1 */
    __HAL_RCC_PLLSAI1_DISABLE();
 8001a48:	682b      	ldr	r3, [r5, #0]
 8001a4a:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8001a4e:	602b      	str	r3, [r5, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001a50:	f7ff f9f4 	bl	8000e3c <HAL_GetTick>
 8001a54:	4607      	mov	r7, r0

    /* Wait till PLLSAI1 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != RESET)
 8001a56:	682b      	ldr	r3, [r5, #0]
 8001a58:	4934      	ldr	r1, [pc, #208]	; (8001b2c <RCCEx_PLLSAI1_Config+0x16c>)
 8001a5a:	011a      	lsls	r2, r3, #4
 8001a5c:	d506      	bpl.n	8001a6c <RCCEx_PLLSAI1_Config+0xac>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8001a5e:	f7ff f9ed 	bl	8000e3c <HAL_GetTick>
 8001a62:	1bc0      	subs	r0, r0, r7
 8001a64:	2802      	cmp	r0, #2
 8001a66:	d9f6      	bls.n	8001a56 <RCCEx_PLLSAI1_Config+0x96>
      {
        status = HAL_TIMEOUT;
 8001a68:	2003      	movs	r0, #3
 8001a6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001a6c:	f44f 43fe 	mov.w	r3, #32512	; 0x7f00
 8001a70:	68a7      	ldr	r7, [r4, #8]
      }
    }

    if(status == HAL_OK)    
    {
      if(Divider == DIVIDER_P_UPDATE)
 8001a72:	b9b6      	cbnz	r6, 8001aa2 <RCCEx_PLLSAI1_Config+0xe2>
      {
        assert_param(IS_RCC_PLLSAI1P_VALUE(PllSai1->PLLSAI1P));
        /* Configure the PLLSAI1 Division factor P and Multiplication factor N*/
#if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
        MODIFY_REG(RCC->PLLSAI1CFGR, 
 8001a74:	6908      	ldr	r0, [r1, #16]
 8001a76:	fa93 f2a3 	rbit	r2, r3
 8001a7a:	f04f 4678 	mov.w	r6, #4160749568	; 0xf8000000
 8001a7e:	fab2 f282 	clz	r2, r2
 8001a82:	fa96 f6a6 	rbit	r6, r6
 8001a86:	fa07 f302 	lsl.w	r3, r7, r2
 8001a8a:	68e2      	ldr	r2, [r4, #12]
 8001a8c:	fab6 f686 	clz	r6, r6
 8001a90:	40b2      	lsls	r2, r6
 8001a92:	4313      	orrs	r3, r2
 8001a94:	f020 4278 	bic.w	r2, r0, #4160749568	; 0xf8000000
 8001a98:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
 8001a9c:	431a      	orrs	r2, r3
 8001a9e:	610a      	str	r2, [r1, #16]
 8001aa0:	e02d      	b.n	8001afe <RCCEx_PLLSAI1_Config+0x13e>
                   RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1P, 
                   (PllSai1->PLLSAI1N << POSITION_VAL(RCC_PLLSAI1CFGR_PLLSAI1N)) | 
                   ((PllSai1->PLLSAI1P >> 4U) << POSITION_VAL(RCC_PLLSAI1CFGR_PLLSAI1P)));
#endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */
      }
      else if(Divider == DIVIDER_Q_UPDATE)
 8001aa2:	2e01      	cmp	r6, #1
      {
        assert_param(IS_RCC_PLLSAI1Q_VALUE(PllSai1->PLLSAI1Q));
        /* Configure the PLLSAI1 Division factor Q and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR, 
 8001aa4:	6908      	ldr	r0, [r1, #16]
                   RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1P, 
                   (PllSai1->PLLSAI1N << POSITION_VAL(RCC_PLLSAI1CFGR_PLLSAI1N)) | 
                   ((PllSai1->PLLSAI1P >> 4U) << POSITION_VAL(RCC_PLLSAI1CFGR_PLLSAI1P)));
#endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */
      }
      else if(Divider == DIVIDER_Q_UPDATE)
 8001aa6:	d113      	bne.n	8001ad0 <RCCEx_PLLSAI1_Config+0x110>
 8001aa8:	fa93 f2a3 	rbit	r2, r3
 8001aac:	f44f 03c0 	mov.w	r3, #6291456	; 0x600000
      {
        assert_param(IS_RCC_PLLSAI1Q_VALUE(PllSai1->PLLSAI1Q));
        /* Configure the PLLSAI1 Division factor Q and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR, 
 8001ab0:	fab2 f282 	clz	r2, r2
 8001ab4:	fa93 f3a3 	rbit	r3, r3
 8001ab8:	6926      	ldr	r6, [r4, #16]
 8001aba:	0876      	lsrs	r6, r6, #1
 8001abc:	fab3 f383 	clz	r3, r3
 8001ac0:	3e01      	subs	r6, #1
 8001ac2:	409e      	lsls	r6, r3
 8001ac4:	fa07 f302 	lsl.w	r3, r7, r2
 8001ac8:	4333      	orrs	r3, r6
 8001aca:	f420 02c0 	bic.w	r2, r0, #6291456	; 0x600000
 8001ace:	e012      	b.n	8001af6 <RCCEx_PLLSAI1_Config+0x136>
 8001ad0:	fa93 f2a3 	rbit	r2, r3
 8001ad4:	f04f 63c0 	mov.w	r3, #100663296	; 0x6000000
      }
      else
      {
        assert_param(IS_RCC_PLLSAI1R_VALUE(PllSai1->PLLSAI1R));
        /* Configure the PLLSAI1 Division factor R and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR, 
 8001ad8:	fab2 f282 	clz	r2, r2
 8001adc:	fa93 f3a3 	rbit	r3, r3
 8001ae0:	6966      	ldr	r6, [r4, #20]
 8001ae2:	0876      	lsrs	r6, r6, #1
 8001ae4:	fab3 f383 	clz	r3, r3
 8001ae8:	3e01      	subs	r6, #1
 8001aea:	409e      	lsls	r6, r3
 8001aec:	fa07 f302 	lsl.w	r3, r7, r2
 8001af0:	4333      	orrs	r3, r6
 8001af2:	f020 62c0 	bic.w	r2, r0, #100663296	; 0x6000000
 8001af6:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
 8001afa:	4313      	orrs	r3, r2
 8001afc:	610b      	str	r3, [r1, #16]
                   (PllSai1->PLLSAI1N << POSITION_VAL(RCC_PLLSAI1CFGR_PLLSAI1N)) | 
                   (((PllSai1->PLLSAI1R >> 1U) - 1U) << POSITION_VAL(RCC_PLLSAI1CFGR_PLLSAI1R)));
      }

      /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
      __HAL_RCC_PLLSAI1_ENABLE();
 8001afe:	682b      	ldr	r3, [r5, #0]
 8001b00:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8001b04:	602b      	str	r3, [r5, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001b06:	f7ff f999 	bl	8000e3c <HAL_GetTick>
 8001b0a:	4606      	mov	r6, r0

      /* Wait till PLLSAI1 is ready */
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == RESET)
 8001b0c:	682b      	ldr	r3, [r5, #0]
 8001b0e:	4a07      	ldr	r2, [pc, #28]	; (8001b2c <RCCEx_PLLSAI1_Config+0x16c>)
 8001b10:	011b      	lsls	r3, r3, #4
 8001b12:	d405      	bmi.n	8001b20 <RCCEx_PLLSAI1_Config+0x160>
      {
        if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8001b14:	f7ff f992 	bl	8000e3c <HAL_GetTick>
 8001b18:	1b80      	subs	r0, r0, r6
 8001b1a:	2802      	cmp	r0, #2
 8001b1c:	d9f6      	bls.n	8001b0c <RCCEx_PLLSAI1_Config+0x14c>
 8001b1e:	e7a3      	b.n	8001a68 <RCCEx_PLLSAI1_Config+0xa8>
      }

      if(status == HAL_OK)    
      {
        /* Configure the PLLSAI1 Clock output(s) */
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 8001b20:	6911      	ldr	r1, [r2, #16]
 8001b22:	69a3      	ldr	r3, [r4, #24]
 8001b24:	430b      	orrs	r3, r1
 8001b26:	6113      	str	r3, [r2, #16]
 8001b28:	2000      	movs	r0, #0
      }
    }
  }
  
  return status;
}
 8001b2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001b2c:	40021000 	.word	0x40021000

08001b30 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8001b30:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8001b34:	6805      	ldr	r5, [r0, #0]
 8001b36:	f415 6500 	ands.w	r5, r5, #2048	; 0x800
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8001b3a:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8001b3c:	d01f      	beq.n	8001b7e <HAL_RCCEx_PeriphCLKConfig+0x4e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(PeriphClkInit->Sai1ClockSelection));

    switch(PeriphClkInit->Sai1ClockSelection)
 8001b3e:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
 8001b40:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8001b44:	d004      	beq.n	8001b50 <HAL_RCCEx_PeriphCLKConfig+0x20>
 8001b46:	f5b1 0f40 	cmp.w	r1, #12582912	; 0xc00000
 8001b4a:	d00c      	beq.n	8001b66 <HAL_RCCEx_PeriphCLKConfig+0x36>
 8001b4c:	b9b1      	cbnz	r1, 8001b7c <HAL_RCCEx_PeriphCLKConfig+0x4c>
 8001b4e:	e005      	b.n	8001b5c <HAL_RCCEx_PeriphCLKConfig+0x2c>
    case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
      /* Enable SAI Clock output generated form System PLL . */
#if defined(RCC_PLLSAI2_SUPPORT)
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
#else
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI2CLK);
 8001b50:	4a96      	ldr	r2, [pc, #600]	; (8001dac <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001b52:	68d3      	ldr	r3, [r2, #12]
 8001b54:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001b58:	60d3      	str	r3, [r2, #12]
#endif /* RCC_PLLSAI2_SUPPORT */
      /* SAI1 clock source config set later after clock selection check */
      break;
 8001b5a:	e004      	b.n	8001b66 <HAL_RCCEx_PeriphCLKConfig+0x36>

    case RCC_SAI1CLKSOURCE_PLLSAI1:  /* PLLSAI1 is used as clock source for SAI1*/
      /* PLLSAI1 input clock, parameters M, N & P configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8001b5c:	3004      	adds	r0, #4
 8001b5e:	f7ff ff2f 	bl	80019c0 <RCCEx_PLLSAI1_Config>
    default:
      ret = HAL_ERROR;
      break;
    }

    if(ret == HAL_OK)
 8001b62:	4605      	mov	r5, r0
 8001b64:	b958      	cbnz	r0, 8001b7e <HAL_RCCEx_PeriphCLKConfig+0x4e>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8001b66:	4991      	ldr	r1, [pc, #580]	; (8001dac <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001b68:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8001b6c:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 8001b70:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001b72:	4313      	orrs	r3, r2
 8001b74:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 8001b78:	2500      	movs	r5, #0
 8001b7a:	e000      	b.n	8001b7e <HAL_RCCEx_PeriphCLKConfig+0x4e>
    case RCC_SAI1CLKSOURCE_PIN:      /* External clock is used as source of SAI1 clock*/
      /* SAI1 clock source config set later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8001b7c:	2501      	movs	r5, #1
    }
  }
#endif /* SAI2 */

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8001b7e:	6823      	ldr	r3, [r4, #0]
 8001b80:	039e      	lsls	r6, r3, #14
 8001b82:	d55a      	bpl.n	8001c3a <HAL_RCCEx_PeriphCLKConfig+0x10a>
    
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8001b84:	4e89      	ldr	r6, [pc, #548]	; (8001dac <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001b86:	6db3      	ldr	r3, [r6, #88]	; 0x58
 8001b88:	00d8      	lsls	r0, r3, #3
 8001b8a:	d40a      	bmi.n	8001ba2 <HAL_RCCEx_PeriphCLKConfig+0x72>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8001b8c:	6db3      	ldr	r3, [r6, #88]	; 0x58
 8001b8e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001b92:	65b3      	str	r3, [r6, #88]	; 0x58
 8001b94:	6db3      	ldr	r3, [r6, #88]	; 0x58
 8001b96:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001b9a:	9301      	str	r3, [sp, #4]
 8001b9c:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8001b9e:	2701      	movs	r7, #1
 8001ba0:	e000      	b.n	8001ba4 <HAL_RCCEx_PeriphCLKConfig+0x74>
#endif /* SAI2 */

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
  {
    FlagStatus       pwrclkchanged = RESET;
 8001ba2:	2700      	movs	r7, #0
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }
      
    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8001ba4:	f8df 8208 	ldr.w	r8, [pc, #520]	; 8001db0 <HAL_RCCEx_PeriphCLKConfig+0x280>
 8001ba8:	f8d8 3000 	ldr.w	r3, [r8]
 8001bac:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001bb0:	f8c8 3000 	str.w	r3, [r8]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8001bb4:	f7ff f942 	bl	8000e3c <HAL_GetTick>
 8001bb8:	4681      	mov	r9, r0

    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8001bba:	f8d8 3000 	ldr.w	r3, [r8]
 8001bbe:	05d9      	lsls	r1, r3, #23
 8001bc0:	d406      	bmi.n	8001bd0 <HAL_RCCEx_PeriphCLKConfig+0xa0>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001bc2:	f7ff f93b 	bl	8000e3c <HAL_GetTick>
 8001bc6:	ebc9 0000 	rsb	r0, r9, r0
 8001bca:	2802      	cmp	r0, #2
 8001bcc:	d9f5      	bls.n	8001bba <HAL_RCCEx_PeriphCLKConfig+0x8a>
 8001bce:	e02e      	b.n	8001c2e <HAL_RCCEx_PeriphCLKConfig+0xfe>
        ret = HAL_TIMEOUT;
        break;
      }
    }

    if(ret == HAL_OK)
 8001bd0:	bb75      	cbnz	r5, 8001c30 <HAL_RCCEx_PeriphCLKConfig+0x100>
    { 
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8001bd2:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
 8001bd6:	4a75      	ldr	r2, [pc, #468]	; (8001dac <HAL_RCCEx_PeriphCLKConfig+0x27c>)
      
      if((tmpregister != RCC_RTCCLKSOURCE_NO_CLK) && (tmpregister != PeriphClkInit->RTCClockSelection))
 8001bd8:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8001bdc:	d014      	beq.n	8001c08 <HAL_RCCEx_PeriphCLKConfig+0xd8>
 8001bde:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8001be0:	428b      	cmp	r3, r1
 8001be2:	d011      	beq.n	8001c08 <HAL_RCCEx_PeriphCLKConfig+0xd8>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8001be4:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 8001be8:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
 8001bec:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 8001bf0:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 8001bf4:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
      
      if((tmpregister != RCC_RTCCLKSOURCE_NO_CLK) && (tmpregister != PeriphClkInit->RTCClockSelection))
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8001bf8:	f423 7340 	bic.w	r3, r3, #768	; 0x300
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
        __HAL_RCC_BACKUPRESET_RELEASE();
 8001bfc:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 8001c00:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
 8001c04:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8001c08:	07da      	lsls	r2, r3, #31
 8001c0a:	f140 80c2 	bpl.w	8001d92 <HAL_RCCEx_PeriphCLKConfig+0x262>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001c0e:	f7ff f915 	bl	8000e3c <HAL_GetTick>

        /* Wait till LSE is ready */
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001c12:	f241 3988 	movw	r9, #5000	; 0x1388

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001c16:	4680      	mov	r8, r0

        /* Wait till LSE is ready */
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
 8001c18:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
 8001c1c:	079b      	lsls	r3, r3, #30
 8001c1e:	f100 80b8 	bmi.w	8001d92 <HAL_RCCEx_PeriphCLKConfig+0x262>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001c22:	f7ff f90b 	bl	8000e3c <HAL_GetTick>
 8001c26:	ebc8 0000 	rsb	r0, r8, r0
 8001c2a:	4548      	cmp	r0, r9
 8001c2c:	d9f4      	bls.n	8001c18 <HAL_RCCEx_PeriphCLKConfig+0xe8>

    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
      {
        ret = HAL_TIMEOUT;
 8001c2e:	2503      	movs	r5, #3
      /* set overall return value */
      status = ret;
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8001c30:	b11f      	cbz	r7, 8001c3a <HAL_RCCEx_PeriphCLKConfig+0x10a>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8001c32:	6db3      	ldr	r3, [r6, #88]	; 0x58
 8001c34:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8001c38:	65b3      	str	r3, [r6, #88]	; 0x58
    }
  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8001c3a:	6823      	ldr	r3, [r4, #0]
 8001c3c:	07df      	lsls	r7, r3, #31
 8001c3e:	d508      	bpl.n	8001c52 <HAL_RCCEx_PeriphCLKConfig+0x122>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8001c40:	485a      	ldr	r0, [pc, #360]	; (8001dac <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001c42:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8001c46:	f022 0103 	bic.w	r1, r2, #3
 8001c4a:	6a22      	ldr	r2, [r4, #32]
 8001c4c:	430a      	orrs	r2, r1
 8001c4e:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- USART2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8001c52:	079e      	lsls	r6, r3, #30
 8001c54:	d508      	bpl.n	8001c68 <HAL_RCCEx_PeriphCLKConfig+0x138>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8001c56:	4855      	ldr	r0, [pc, #340]	; (8001dac <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001c58:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8001c5c:	f022 010c 	bic.w	r1, r2, #12
 8001c60:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001c62:	430a      	orrs	r2, r1
 8001c64:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

#endif /* UART5 */

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8001c68:	0698      	lsls	r0, r3, #26
 8001c6a:	d508      	bpl.n	8001c7e <HAL_RCCEx_PeriphCLKConfig+0x14e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8001c6c:	484f      	ldr	r0, [pc, #316]	; (8001dac <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001c6e:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8001c72:	f422 6140 	bic.w	r1, r2, #3072	; 0xc00
 8001c76:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8001c78:	430a      	orrs	r2, r1
 8001c7a:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- LPTIM1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8001c7e:	0599      	lsls	r1, r3, #22
 8001c80:	d508      	bpl.n	8001c94 <HAL_RCCEx_PeriphCLKConfig+0x164>
  {
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8001c82:	484a      	ldr	r0, [pc, #296]	; (8001dac <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001c84:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8001c88:	f422 2140 	bic.w	r1, r2, #786432	; 0xc0000
 8001c8c:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8001c8e:	430a      	orrs	r2, r1
 8001c90:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- LPTIM2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8001c94:	055a      	lsls	r2, r3, #21
 8001c96:	d508      	bpl.n	8001caa <HAL_RCCEx_PeriphCLKConfig+0x17a>
  {
    assert_param(IS_RCC_LPTIM2CLK(PeriphClkInit->Lptim2ClockSelection));
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8001c98:	4844      	ldr	r0, [pc, #272]	; (8001dac <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001c9a:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8001c9e:	f422 1140 	bic.w	r1, r2, #3145728	; 0x300000
 8001ca2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8001ca4:	430a      	orrs	r2, r1
 8001ca6:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8001caa:	065f      	lsls	r7, r3, #25
 8001cac:	d508      	bpl.n	8001cc0 <HAL_RCCEx_PeriphCLKConfig+0x190>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8001cae:	483f      	ldr	r0, [pc, #252]	; (8001dac <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001cb0:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8001cb4:	f422 5140 	bic.w	r1, r2, #12288	; 0x3000
 8001cb8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001cba:	430a      	orrs	r2, r1
 8001cbc:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

#endif /* I2C2 */

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8001cc0:	05de      	lsls	r6, r3, #23
 8001cc2:	d508      	bpl.n	8001cd6 <HAL_RCCEx_PeriphCLKConfig+0x1a6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8001cc4:	4839      	ldr	r0, [pc, #228]	; (8001dac <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001cc6:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8001cca:	f422 3140 	bic.w	r1, r2, #196608	; 0x30000
 8001cce:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8001cd0:	430a      	orrs	r2, r1
 8001cd2:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
#endif /* I2C4 */

#if defined(USB_OTG_FS) || defined(USB)

  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8001cd6:	0498      	lsls	r0, r3, #18
 8001cd8:	d51a      	bpl.n	8001d10 <HAL_RCCEx_PeriphCLKConfig+0x1e0>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8001cda:	4a34      	ldr	r2, [pc, #208]	; (8001dac <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001cdc:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8001cde:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8001ce2:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 8001ce6:	430b      	orrs	r3, r1

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8001ce8:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000

  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8001cec:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8001cf0:	d104      	bne.n	8001cfc <HAL_RCCEx_PeriphCLKConfig+0x1cc>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8001cf2:	68d3      	ldr	r3, [r2, #12]
 8001cf4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8001cf8:	60d3      	str	r3, [r2, #12]
 8001cfa:	e009      	b.n	8001d10 <HAL_RCCEx_PeriphCLKConfig+0x1e0>
    }
    else
    {
      if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 8001cfc:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 8001d00:	d106      	bne.n	8001d10 <HAL_RCCEx_PeriphCLKConfig+0x1e0>
      {
        /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8001d02:	2101      	movs	r1, #1
 8001d04:	1d20      	adds	r0, r4, #4
 8001d06:	f7ff fe5b 	bl	80019c0 <RCCEx_PLLSAI1_Config>
      
        if(ret != HAL_OK)
 8001d0a:	2800      	cmp	r0, #0
 8001d0c:	bf18      	it	ne
 8001d0e:	4605      	movne	r5, r0
  }

#endif /* SDMMC1 */

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8001d10:	6823      	ldr	r3, [r4, #0]
 8001d12:	0359      	lsls	r1, r3, #13
 8001d14:	d51a      	bpl.n	8001d4c <HAL_RCCEx_PeriphCLKConfig+0x21c>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8001d16:	4a25      	ldr	r2, [pc, #148]	; (8001dac <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001d18:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8001d1a:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8001d1e:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 8001d22:	430b      	orrs	r3, r1

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8001d24:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8001d28:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8001d2c:	d104      	bne.n	8001d38 <HAL_RCCEx_PeriphCLKConfig+0x208>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8001d2e:	68d3      	ldr	r3, [r2, #12]
 8001d30:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8001d34:	60d3      	str	r3, [r2, #12]
 8001d36:	e009      	b.n	8001d4c <HAL_RCCEx_PeriphCLKConfig+0x21c>
    }
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 8001d38:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 8001d3c:	d106      	bne.n	8001d4c <HAL_RCCEx_PeriphCLKConfig+0x21c>
    {
      /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8001d3e:	2101      	movs	r1, #1
 8001d40:	1d20      	adds	r0, r4, #4
 8001d42:	f7ff fe3d 	bl	80019c0 <RCCEx_PLLSAI1_Config>
      
      if(ret != HAL_OK)
 8001d46:	2800      	cmp	r0, #0
 8001d48:	bf18      	it	ne
 8001d4a:	4605      	movne	r5, r0
      }
    }
  }

  /*-------------------------- ADC clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8001d4c:	6823      	ldr	r3, [r4, #0]
 8001d4e:	045a      	lsls	r2, r3, #17
 8001d50:	d512      	bpl.n	8001d78 <HAL_RCCEx_PeriphCLKConfig+0x248>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8001d52:	4916      	ldr	r1, [pc, #88]	; (8001dac <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001d54:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8001d56:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8001d5a:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 8001d5e:	4313      	orrs	r3, r2
    
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8001d60:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8001d64:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8001d68:	d106      	bne.n	8001d78 <HAL_RCCEx_PeriphCLKConfig+0x248>
    {
      /* PLLSAI1 input clock, parameters M, N & R configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 8001d6a:	2102      	movs	r1, #2
 8001d6c:	1d20      	adds	r0, r4, #4
 8001d6e:	f7ff fe27 	bl	80019c0 <RCCEx_PLLSAI1_Config>

      if(ret != HAL_OK)
 8001d72:	2800      	cmp	r0, #0
 8001d74:	bf18      	it	ne
 8001d76:	4605      	movne	r5, r0
  }

#if defined(SWPMI1)

  /*-------------------------- SWPMI1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 8001d78:	6823      	ldr	r3, [r4, #0]
 8001d7a:	041b      	lsls	r3, r3, #16
 8001d7c:	d512      	bpl.n	8001da4 <HAL_RCCEx_PeriphCLKConfig+0x274>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));

    /* Configure the SWPMI1 clock source */
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
 8001d7e:	490b      	ldr	r1, [pc, #44]	; (8001dac <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001d80:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8001d84:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
 8001d88:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8001d8a:	4313      	orrs	r3, r2
 8001d8c:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
  }

#endif /* DFSDM1_Filter0 */

  return status;
 8001d90:	e008      	b.n	8001da4 <HAL_RCCEx_PeriphCLKConfig+0x274>
      }
      
      if(ret == HAL_OK)
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8001d92:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
 8001d96:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8001d9a:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8001d9c:	4313      	orrs	r3, r2
 8001d9e:	f8c6 3090 	str.w	r3, [r6, #144]	; 0x90
 8001da2:	e745      	b.n	8001c30 <HAL_RCCEx_PeriphCLKConfig+0x100>
  }

#endif /* DFSDM1_Filter0 */

  return status;
}
 8001da4:	4628      	mov	r0, r5
 8001da6:	b003      	add	sp, #12
 8001da8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8001dac:	40021000 	.word	0x40021000
 8001db0:	40007000 	.word	0x40007000

08001db4 <SPI_WaitFifoStateUntilTimeout.part.1>:
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
           on both master and slave sides in order to resynchronize the master
           and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8001db4:	6803      	ldr	r3, [r0, #0]
 8001db6:	685a      	ldr	r2, [r3, #4]
 8001db8:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 8001dbc:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8001dbe:	6842      	ldr	r2, [r0, #4]
 8001dc0:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
 8001dc4:	d10a      	bne.n	8001ddc <SPI_WaitFifoStateUntilTimeout.part.1+0x28>
 8001dc6:	6882      	ldr	r2, [r0, #8]
 8001dc8:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 8001dcc:	d002      	beq.n	8001dd4 <SPI_WaitFifoStateUntilTimeout.part.1+0x20>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8001dce:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8001dd2:	d103      	bne.n	8001ddc <SPI_WaitFifoStateUntilTimeout.part.1+0x28>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 8001dd4:	681a      	ldr	r2, [r3, #0]
 8001dd6:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001dda:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8001ddc:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8001dde:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8001de2:	d107      	bne.n	8001df4 <SPI_WaitFifoStateUntilTimeout.part.1+0x40>
        {
          SPI_RESET_CRC(hspi);
 8001de4:	681a      	ldr	r2, [r3, #0]
 8001de6:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8001dea:	601a      	str	r2, [r3, #0]
 8001dec:	681a      	ldr	r2, [r3, #0]
 8001dee:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8001df2:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 8001df4:	2301      	movs	r3, #1
 8001df6:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8001dfa:	2300      	movs	r3, #0
 8001dfc:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
      }
    }
  }

  return HAL_OK;
}
 8001e00:	2003      	movs	r0, #3
 8001e02:	4770      	bx	lr

08001e04 <SPI_WaitFlagStateUntilTimeout.constprop.10>:
  * @param State: flag state to check
  * @param Timeout: Timeout duration
  * @param Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State,
 8001e04:	b570      	push	{r4, r5, r6, lr}
 8001e06:	4605      	mov	r5, r0
 8001e08:	460c      	mov	r4, r1
 8001e0a:	4616      	mov	r6, r2
                                                       uint32_t Timeout, uint32_t Tickstart)
{
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8001e0c:	682a      	ldr	r2, [r5, #0]
 8001e0e:	6893      	ldr	r3, [r2, #8]
 8001e10:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8001e14:	b16b      	cbz	r3, 8001e32 <SPI_WaitFlagStateUntilTimeout.constprop.10+0x2e>
  {
    if (Timeout != HAL_MAX_DELAY)
 8001e16:	1c63      	adds	r3, r4, #1
 8001e18:	d0f9      	beq.n	8001e0e <SPI_WaitFlagStateUntilTimeout.constprop.10+0xa>
    {
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 8001e1a:	b924      	cbnz	r4, 8001e26 <SPI_WaitFlagStateUntilTimeout.constprop.10+0x22>
 8001e1c:	4628      	mov	r0, r5
      }
    }
  }

  return HAL_OK;
}
 8001e1e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8001e22:	f7ff bfc7 	b.w	8001db4 <SPI_WaitFifoStateUntilTimeout.part.1>
{
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
  {
    if (Timeout != HAL_MAX_DELAY)
    {
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 8001e26:	f7ff f809 	bl	8000e3c <HAL_GetTick>
 8001e2a:	1b80      	subs	r0, r0, r6
 8001e2c:	4284      	cmp	r4, r0
 8001e2e:	d8ed      	bhi.n	8001e0c <SPI_WaitFlagStateUntilTimeout.constprop.10+0x8>
 8001e30:	e7f4      	b.n	8001e1c <SPI_WaitFlagStateUntilTimeout.constprop.10+0x18>
      }
    }
  }

  return HAL_OK;
}
 8001e32:	2000      	movs	r0, #0
 8001e34:	bd70      	pop	{r4, r5, r6, pc}

08001e36 <SPI_WaitFifoStateUntilTimeout.constprop.11>:
  * @param State: Fifo state to check
  * @param Timeout: Timeout duration
  * @param Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
 8001e36:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8001e38:	4606      	mov	r6, r0
 8001e3a:	460c      	mov	r4, r1
 8001e3c:	4615      	mov	r5, r2
 8001e3e:	461f      	mov	r7, r3
                                                       uint32_t Timeout, uint32_t Tickstart)
{
  __IO uint8_t tmpreg;

  while ((hspi->Instance->SR & Fifo) != State)
 8001e40:	6831      	ldr	r1, [r6, #0]
 8001e42:	6888      	ldr	r0, [r1, #8]
 8001e44:	4020      	ands	r0, r4
 8001e46:	d015      	beq.n	8001e74 <SPI_WaitFifoStateUntilTimeout.constprop.11+0x3e>
  {
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 8001e48:	f5b4 6fc0 	cmp.w	r4, #1536	; 0x600
    {
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 8001e4c:	bf01      	itttt	eq
 8001e4e:	7b0a      	ldrbeq	r2, [r1, #12]
 8001e50:	b2d2      	uxtbeq	r2, r2
 8001e52:	f88d 2007 	strbeq.w	r2, [sp, #7]
      /* To avoid GCC warning */
      UNUSED(tmpreg);
 8001e56:	f89d 3007 	ldrbeq.w	r3, [sp, #7]
    }

    if (Timeout != HAL_MAX_DELAY)
 8001e5a:	1c6b      	adds	r3, r5, #1
 8001e5c:	d0f1      	beq.n	8001e42 <SPI_WaitFifoStateUntilTimeout.constprop.11+0xc>
    {
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 8001e5e:	b91d      	cbnz	r5, 8001e68 <SPI_WaitFifoStateUntilTimeout.constprop.11+0x32>
 8001e60:	4630      	mov	r0, r6
 8001e62:	f7ff ffa7 	bl	8001db4 <SPI_WaitFifoStateUntilTimeout.part.1>
 8001e66:	e005      	b.n	8001e74 <SPI_WaitFifoStateUntilTimeout.constprop.11+0x3e>
 8001e68:	f7fe ffe8 	bl	8000e3c <HAL_GetTick>
 8001e6c:	1bc0      	subs	r0, r0, r7
 8001e6e:	4285      	cmp	r5, r0
 8001e70:	d8e6      	bhi.n	8001e40 <SPI_WaitFifoStateUntilTimeout.constprop.11+0xa>
 8001e72:	e7f5      	b.n	8001e60 <SPI_WaitFifoStateUntilTimeout.constprop.11+0x2a>
      }
    }
  }

  return HAL_OK;
}
 8001e74:	b003      	add	sp, #12
 8001e76:	bdf0      	pop	{r4, r5, r6, r7, pc}

08001e78 <SPI_EndRxTxTransaction>:
  * @param  Timeout: Timeout duration
  * @param  Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8001e78:	b570      	push	{r4, r5, r6, lr}
  /* Control if the TX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001e7a:	4613      	mov	r3, r2
  * @param  Timeout: Timeout duration
  * @param  Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8001e7c:	460d      	mov	r5, r1
 8001e7e:	4616      	mov	r6, r2
  /* Control if the TX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001e80:	460a      	mov	r2, r1
 8001e82:	f44f 51c0 	mov.w	r1, #6144	; 0x1800
  * @param  Timeout: Timeout duration
  * @param  Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8001e86:	4604      	mov	r4, r0
  /* Control if the TX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001e88:	f7ff ffd5 	bl	8001e36 <SPI_WaitFifoStateUntilTimeout.constprop.11>
 8001e8c:	b968      	cbnz	r0, 8001eaa <SPI_EndRxTxTransaction+0x32>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }
  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8001e8e:	4632      	mov	r2, r6
 8001e90:	4629      	mov	r1, r5
 8001e92:	4620      	mov	r0, r4
 8001e94:	f7ff ffb6 	bl	8001e04 <SPI_WaitFlagStateUntilTimeout.constprop.10>
 8001e98:	b938      	cbnz	r0, 8001eaa <SPI_EndRxTxTransaction+0x32>

  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
  {
    /* Empty the FRLVL fifo */
    if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001e9a:	4633      	mov	r3, r6
 8001e9c:	462a      	mov	r2, r5
 8001e9e:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 8001ea2:	4620      	mov	r0, r4
 8001ea4:	f7ff ffc7 	bl	8001e36 <SPI_WaitFifoStateUntilTimeout.constprop.11>
 8001ea8:	b120      	cbz	r0, 8001eb4 <SPI_EndRxTxTransaction+0x3c>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8001eaa:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8001eac:	f043 0320 	orr.w	r3, r3, #32
 8001eb0:	6623      	str	r3, [r4, #96]	; 0x60
      return HAL_TIMEOUT;
 8001eb2:	2003      	movs	r0, #3
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }
  return HAL_OK;
}
 8001eb4:	bd70      	pop	{r4, r5, r6, pc}

08001eb6 <HAL_SPI_Init>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8001eb6:	b570      	push	{r4, r5, r6, lr}
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 8001eb8:	4604      	mov	r4, r0
 8001eba:	2800      	cmp	r0, #0
 8001ebc:	d04b      	beq.n	8001f56 <HAL_SPI_Init+0xa0>
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8001ebe:	2300      	movs	r3, #0
 8001ec0:	6283      	str	r3, [r0, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 8001ec2:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
 8001ec6:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001eca:	b91b      	cbnz	r3, 8001ed4 <HAL_SPI_Init+0x1e>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 8001ecc:	f880 205c 	strb.w	r2, [r0, #92]	; 0x5c

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 8001ed0:	f000 ff46 	bl	8002d60 <HAL_SPI_MspInit>
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8001ed4:	2302      	movs	r3, #2

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001ed6:	6820      	ldr	r0, [r4, #0]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8001ed8:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001edc:	6803      	ldr	r3, [r0, #0]

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001ede:	68e2      	ldr	r2, [r4, #12]
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001ee0:	f023 0340 	bic.w	r3, r3, #64	; 0x40

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001ee4:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001ee8:	6003      	str	r3, [r0, #0]
 8001eea:	f04f 0300 	mov.w	r3, #0

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001eee:	d903      	bls.n	8001ef8 <HAL_SPI_Init+0x42>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8001ef0:	4619      	mov	r1, r3
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8001ef2:	f5b2 6f70 	cmp.w	r2, #3840	; 0xf00
 8001ef6:	e001      	b.n	8001efc <HAL_SPI_Init+0x46>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
  }
  else
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 8001ef8:	f44f 5180 	mov.w	r1, #4096	; 0x1000

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8001efc:	bf18      	it	ne
 8001efe:	62a3      	strne	r3, [r4, #40]	; 0x28
  }

  /* Align the CRC Length on the data size */
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8001f00:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001f02:	b92b      	cbnz	r3, 8001f10 <HAL_SPI_Init+0x5a>
  {
    /* CRC Length aligned on the data size : value set by default */
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001f04:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 8001f08:	bf8c      	ite	hi
 8001f0a:	2302      	movhi	r3, #2
    }
    else
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 8001f0c:	2301      	movls	r3, #1
 8001f0e:	6323      	str	r3, [r4, #48]	; 0x30
  }

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8001f10:	68a5      	ldr	r5, [r4, #8]
 8001f12:	6866      	ldr	r6, [r4, #4]
 8001f14:	69a3      	ldr	r3, [r4, #24]
 8001f16:	432e      	orrs	r6, r5
 8001f18:	6925      	ldr	r5, [r4, #16]
 8001f1a:	432e      	orrs	r6, r5
 8001f1c:	6965      	ldr	r5, [r4, #20]
 8001f1e:	432e      	orrs	r6, r5
 8001f20:	69e5      	ldr	r5, [r4, #28]
 8001f22:	432e      	orrs	r6, r5
 8001f24:	6a25      	ldr	r5, [r4, #32]
 8001f26:	432e      	orrs	r6, r5
 8001f28:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 8001f2a:	432e      	orrs	r6, r5
 8001f2c:	f403 7500 	and.w	r5, r3, #512	; 0x200
 8001f30:	4335      	orrs	r5, r6
 8001f32:	6005      	str	r5, [r0, #0]
    hspi->Instance->CR1 |= SPI_CR1_CRCL;
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo Threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8001f34:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8001f36:	432a      	orrs	r2, r5
 8001f38:	6b65      	ldr	r5, [r4, #52]	; 0x34
 8001f3a:	0c1b      	lsrs	r3, r3, #16
 8001f3c:	4315      	orrs	r5, r2
 8001f3e:	f003 0204 	and.w	r2, r3, #4
 8001f42:	ea45 0302 	orr.w	r3, r5, r2
 8001f46:	430b      	orrs	r3, r1
 8001f48:	6043      	str	r3, [r0, #4]
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8001f4a:	2000      	movs	r0, #0
  hspi->State     = HAL_SPI_STATE_READY;
 8001f4c:	2301      	movs	r3, #1
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8001f4e:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 8001f50:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d

  return HAL_OK;
 8001f54:	bd70      	pop	{r4, r5, r6, pc}
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
  {
    return HAL_ERROR;
 8001f56:	2001      	movs	r0, #1

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  hspi->State     = HAL_SPI_STATE_READY;

  return HAL_OK;
}
 8001f58:	bd70      	pop	{r4, r5, r6, pc}

08001f5a <HAL_SPI_Transmit>:
  * @param  Size: amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8001f5a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8001f5e:	461e      	mov	r6, r3

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001f60:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
 8001f64:	2b01      	cmp	r3, #1
  * @param  Size: amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8001f66:	4604      	mov	r4, r0
 8001f68:	460d      	mov	r5, r1
 8001f6a:	4690      	mov	r8, r2

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001f6c:	f000 80b1 	beq.w	80020d2 <HAL_SPI_Transmit+0x178>
 8001f70:	2301      	movs	r3, #1
 8001f72:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8001f76:	f7fe ff61 	bl	8000e3c <HAL_GetTick>
 8001f7a:	4607      	mov	r7, r0

  if (hspi->State != HAL_SPI_STATE_READY)
 8001f7c:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
 8001f80:	b2c0      	uxtb	r0, r0
 8001f82:	2801      	cmp	r0, #1
 8001f84:	f040 809d 	bne.w	80020c2 <HAL_SPI_Transmit+0x168>
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if ((pData == NULL) || (Size == 0U))
 8001f88:	2d00      	cmp	r5, #0
 8001f8a:	f000 809b 	beq.w	80020c4 <HAL_SPI_Transmit+0x16a>
 8001f8e:	f1b8 0f00 	cmp.w	r8, #0
 8001f92:	f000 8097 	beq.w	80020c4 <HAL_SPI_Transmit+0x16a>
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8001f96:	2303      	movs	r3, #3
 8001f98:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8001f9c:	2300      	movs	r3, #0
 8001f9e:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8001fa0:	6423      	str	r3, [r4, #64]	; 0x40
  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;
 8001fa2:	f8a4 803e 	strh.w	r8, [r4, #62]	; 0x3e

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
  hspi->RxXferSize  = 0U;
 8001fa6:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
  hspi->RxXferCount = 0U;
 8001faa:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
  hspi->TxISR       = NULL;
 8001fae:	6523      	str	r3, [r4, #80]	; 0x50
  hspi->RxISR       = NULL;
 8001fb0:	64e3      	str	r3, [r4, #76]	; 0x4c

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8001fb2:	68a3      	ldr	r3, [r4, #8]
 8001fb4:	6820      	ldr	r0, [r4, #0]
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8001fb6:	63a5      	str	r5, [r4, #56]	; 0x38
  hspi->RxXferCount = 0U;
  hspi->TxISR       = NULL;
  hspi->RxISR       = NULL;

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8001fb8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  {
    SPI_1LINE_TX(hspi);
 8001fbc:	bf08      	it	eq
 8001fbe:	6803      	ldreq	r3, [r0, #0]

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
 8001fc0:	f8a4 803c 	strh.w	r8, [r4, #60]	; 0x3c
  hspi->RxISR       = NULL;

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_TX(hspi);
 8001fc4:	bf04      	itt	eq
 8001fc6:	f443 4380 	orreq.w	r3, r3, #16384	; 0x4000
 8001fca:	6003      	streq	r3, [r0, #0]
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8001fcc:	6803      	ldr	r3, [r0, #0]
 8001fce:	065b      	lsls	r3, r3, #25
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 8001fd0:	bf5e      	ittt	pl
 8001fd2:	6803      	ldrpl	r3, [r0, #0]
 8001fd4:	f043 0340 	orrpl.w	r3, r3, #64	; 0x40
 8001fd8:	6003      	strpl	r3, [r0, #0]
  }

  /* Transmit data in 16 Bit mode */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001fda:	68e3      	ldr	r3, [r4, #12]
 8001fdc:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8001fe0:	6863      	ldr	r3, [r4, #4]
 8001fe2:	d921      	bls.n	8002028 <HAL_SPI_Transmit+0xce>
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
 8001fe4:	b11b      	cbz	r3, 8001fee <HAL_SPI_Transmit+0x94>
 8001fe6:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8001fe8:	b29b      	uxth	r3, r3
 8001fea:	2b01      	cmp	r3, #1
 8001fec:	d10a      	bne.n	8002004 <HAL_SPI_Transmit+0xaa>
    {
      hspi->Instance->DR = *((uint16_t *)pData);
 8001fee:	f835 3b02 	ldrh.w	r3, [r5], #2
 8001ff2:	60c3      	str	r3, [r0, #12]
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
      {
        hspi->Instance->DR = *((uint16_t *)pData);
        pData += sizeof(uint16_t);
        hspi->TxXferCount--;
 8001ff4:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8001ff6:	3b01      	subs	r3, #1
 8001ff8:	b29b      	uxth	r3, r3
 8001ffa:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8001ffc:	e002      	b.n	8002004 <HAL_SPI_Transmit+0xaa>
      }
      else
      {
        /* Timeout management */
        if ((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout)))
 8001ffe:	b18e      	cbz	r6, 8002024 <HAL_SPI_Transmit+0xca>
 8002000:	1c71      	adds	r1, r6, #1
 8002002:	d10a      	bne.n	800201a <HAL_SPI_Transmit+0xc0>
      hspi->Instance->DR = *((uint16_t *)pData);
      pData += sizeof(uint16_t);
      hspi->TxXferCount--;
    }
    /* Transmit data in 16 Bit mode */
    while (hspi->TxXferCount > 0U)
 8002004:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002006:	b29b      	uxth	r3, r3
 8002008:	b1b3      	cbz	r3, 8002038 <HAL_SPI_Transmit+0xde>
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 800200a:	6823      	ldr	r3, [r4, #0]
 800200c:	689a      	ldr	r2, [r3, #8]
 800200e:	0790      	lsls	r0, r2, #30
 8002010:	d5f5      	bpl.n	8001ffe <HAL_SPI_Transmit+0xa4>
      {
        hspi->Instance->DR = *((uint16_t *)pData);
 8002012:	f835 2b02 	ldrh.w	r2, [r5], #2
 8002016:	60da      	str	r2, [r3, #12]
 8002018:	e7ec      	b.n	8001ff4 <HAL_SPI_Transmit+0x9a>
        hspi->TxXferCount--;
      }
      else
      {
        /* Timeout management */
        if ((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout)))
 800201a:	f7fe ff0f 	bl	8000e3c <HAL_GetTick>
 800201e:	1bc0      	subs	r0, r0, r7
 8002020:	4286      	cmp	r6, r0
 8002022:	d8ef      	bhi.n	8002004 <HAL_SPI_Transmit+0xaa>
        {
          errorcode = HAL_TIMEOUT;
 8002024:	2003      	movs	r0, #3
 8002026:	e04d      	b.n	80020c4 <HAL_SPI_Transmit+0x16a>
    }
  }
  /* Transmit data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
 8002028:	b183      	cbz	r3, 800204c <HAL_SPI_Transmit+0xf2>
 800202a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800202c:	b29b      	uxth	r3, r3
 800202e:	2b01      	cmp	r3, #1
 8002030:	d00c      	beq.n	800204c <HAL_SPI_Transmit+0xf2>
      {
        *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
        hspi->TxXferCount--;
      }
    }
    while (hspi->TxXferCount > 0U)
 8002032:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002034:	b29b      	uxth	r3, r3
 8002036:	b9a3      	cbnz	r3, 8002062 <HAL_SPI_Transmit+0x108>
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8002038:	463a      	mov	r2, r7
 800203a:	4631      	mov	r1, r6
 800203c:	4620      	mov	r0, r4
 800203e:	f7ff ff1b 	bl	8001e78 <SPI_EndRxTxTransaction>
 8002042:	2800      	cmp	r0, #0
 8002044:	d02f      	beq.n	80020a6 <HAL_SPI_Transmit+0x14c>
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8002046:	2320      	movs	r3, #32
 8002048:	6623      	str	r3, [r4, #96]	; 0x60
 800204a:	e02c      	b.n	80020a6 <HAL_SPI_Transmit+0x14c>
  /* Transmit data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
    {
      if (hspi->TxXferCount > 1U)
 800204c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800204e:	b29b      	uxth	r3, r3
 8002050:	2b01      	cmp	r3, #1
 8002052:	d903      	bls.n	800205c <HAL_SPI_Transmit+0x102>
      {
        /* write on the data register in packing mode */
        hspi->Instance->DR = *((uint16_t *)pData);
 8002054:	f835 3b02 	ldrh.w	r3, [r5], #2
 8002058:	60c3      	str	r3, [r0, #12]
 800205a:	e00d      	b.n	8002078 <HAL_SPI_Transmit+0x11e>
        pData += sizeof(uint16_t);
        hspi->TxXferCount -= 2U;
      }
      else
      {
        *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
 800205c:	782b      	ldrb	r3, [r5, #0]
 800205e:	7303      	strb	r3, [r0, #12]
 8002060:	e011      	b.n	8002086 <HAL_SPI_Transmit+0x12c>
      }
    }
    while (hspi->TxXferCount > 0U)
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002062:	6823      	ldr	r3, [r4, #0]
 8002064:	689a      	ldr	r2, [r3, #8]
 8002066:	0792      	lsls	r2, r2, #30
 8002068:	d513      	bpl.n	8002092 <HAL_SPI_Transmit+0x138>
      {
        if (hspi->TxXferCount > 1U)
 800206a:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 800206c:	b292      	uxth	r2, r2
 800206e:	2a01      	cmp	r2, #1
 8002070:	d907      	bls.n	8002082 <HAL_SPI_Transmit+0x128>
        {
          /* write on the data register in packing mode */
          hspi->Instance->DR = *((uint16_t *)pData);
 8002072:	f835 2b02 	ldrh.w	r2, [r5], #2
 8002076:	60da      	str	r2, [r3, #12]
          pData += sizeof(uint16_t);
          hspi->TxXferCount -= 2U;
 8002078:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800207a:	3b02      	subs	r3, #2
 800207c:	b29b      	uxth	r3, r3
 800207e:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8002080:	e7d7      	b.n	8002032 <HAL_SPI_Transmit+0xd8>
        }
        else
        {
          *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
 8002082:	782a      	ldrb	r2, [r5, #0]
 8002084:	731a      	strb	r2, [r3, #12]
          hspi->TxXferCount--;
 8002086:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002088:	3b01      	subs	r3, #1
 800208a:	b29b      	uxth	r3, r3
 800208c:	87e3      	strh	r3, [r4, #62]	; 0x3e
          pData += sizeof(uint16_t);
          hspi->TxXferCount -= 2U;
        }
        else
        {
          *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
 800208e:	3501      	adds	r5, #1
 8002090:	e7cf      	b.n	8002032 <HAL_SPI_Transmit+0xd8>
        }
      }
      else
      {
        /* Timeout management */
        if ((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout)))
 8002092:	2e00      	cmp	r6, #0
 8002094:	d0c6      	beq.n	8002024 <HAL_SPI_Transmit+0xca>
 8002096:	1c73      	adds	r3, r6, #1
 8002098:	d0cb      	beq.n	8002032 <HAL_SPI_Transmit+0xd8>
 800209a:	f7fe fecf 	bl	8000e3c <HAL_GetTick>
 800209e:	1bc0      	subs	r0, r0, r7
 80020a0:	4286      	cmp	r6, r0
 80020a2:	d8c6      	bhi.n	8002032 <HAL_SPI_Transmit+0xd8>
 80020a4:	e7be      	b.n	8002024 <HAL_SPI_Transmit+0xca>
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 80020a6:	68a3      	ldr	r3, [r4, #8]
 80020a8:	b933      	cbnz	r3, 80020b8 <HAL_SPI_Transmit+0x15e>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80020aa:	9301      	str	r3, [sp, #4]
 80020ac:	6823      	ldr	r3, [r4, #0]
 80020ae:	68da      	ldr	r2, [r3, #12]
 80020b0:	9201      	str	r2, [sp, #4]
 80020b2:	689b      	ldr	r3, [r3, #8]
 80020b4:	9301      	str	r3, [sp, #4]
 80020b6:	9b01      	ldr	r3, [sp, #4]
  }

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 80020b8:	6e20      	ldr	r0, [r4, #96]	; 0x60
  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();

  if (hspi->State != HAL_SPI_STATE_READY)
  {
    errorcode = HAL_BUSY;
 80020ba:	3000      	adds	r0, #0
 80020bc:	bf18      	it	ne
 80020be:	2001      	movne	r0, #1
 80020c0:	e000      	b.n	80020c4 <HAL_SPI_Transmit+0x16a>
 80020c2:	2002      	movs	r0, #2
  {
    errorcode = HAL_ERROR;
  }

error:
  hspi->State = HAL_SPI_STATE_READY;
 80020c4:	2301      	movs	r3, #1
 80020c6:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 80020ca:	2300      	movs	r3, #0
 80020cc:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  return errorcode;
 80020d0:	e000      	b.n	80020d4 <HAL_SPI_Transmit+0x17a>

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 80020d2:	2002      	movs	r0, #2
error:
  hspi->State = HAL_SPI_STATE_READY;
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 80020d4:	b002      	add	sp, #8
 80020d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

080020dc <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart: UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 80020dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80020de:	4604      	mov	r4, r0
   *  set the M bits according to huart->Init.WordLength value
   *  set PCE and PS bits according to huart->Init.Parity value
   *  set TE and RE bits according to huart->Init.Mode value
   *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 80020e0:	6805      	ldr	r5, [r0, #0]
 80020e2:	6923      	ldr	r3, [r4, #16]
 80020e4:	68a2      	ldr	r2, [r4, #8]
   *  the UART Word Length, Parity, Mode and oversampling:
   *  set the M bits according to huart->Init.WordLength value
   *  set PCE and PS bits according to huart->Init.Parity value
   *  set TE and RE bits according to huart->Init.Mode value
   *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80020e6:	69c1      	ldr	r1, [r0, #28]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 80020e8:	6828      	ldr	r0, [r5, #0]
 80020ea:	431a      	orrs	r2, r3
 80020ec:	6963      	ldr	r3, [r4, #20]
 80020ee:	4313      	orrs	r3, r2
 80020f0:	ea43 0201 	orr.w	r2, r3, r1
 80020f4:	4b7d      	ldr	r3, [pc, #500]	; (80022ec <UART_SetConfig+0x210>)
 80020f6:	4003      	ands	r3, r0
 80020f8:	4313      	orrs	r3, r2
 80020fa:	602b      	str	r3, [r5, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
   * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80020fc:	686b      	ldr	r3, [r5, #4]
 80020fe:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
 8002102:	68e3      	ldr	r3, [r4, #12]
 8002104:	4313      	orrs	r3, r2
   * - UART HardWare Flow Control: set CTSE and RTSE bits according
   *   to huart->Init.HwFlowCtl value
   * - one-bit sampling method versus three samples' majority rule according
   *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8002106:	4a7a      	ldr	r2, [pc, #488]	; (80022f0 <UART_SetConfig+0x214>)
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
   * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8002108:	606b      	str	r3, [r5, #4]
   * - UART HardWare Flow Control: set CTSE and RTSE bits according
   *   to huart->Init.HwFlowCtl value
   * - one-bit sampling method versus three samples' majority rule according
   *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800210a:	4295      	cmp	r5, r2
  {
    tmpreg |= huart->Init.OneBitSampling;
 800210c:	bf18      	it	ne
 800210e:	6a22      	ldrne	r2, [r4, #32]
  /* Configure
   * - UART HardWare Flow Control: set CTSE and RTSE bits according
   *   to huart->Init.HwFlowCtl value
   * - one-bit sampling method versus three samples' majority rule according
   *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8002110:	69a3      	ldr	r3, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
  {
    tmpreg |= huart->Init.OneBitSampling;
 8002112:	bf18      	it	ne
 8002114:	4313      	orrne	r3, r2
  }
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 8002116:	68aa      	ldr	r2, [r5, #8]
 8002118:	f422 6230 	bic.w	r2, r2, #2816	; 0xb00
 800211c:	4313      	orrs	r3, r2
 800211e:	60ab      	str	r3, [r5, #8]

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8002120:	4b74      	ldr	r3, [pc, #464]	; (80022f4 <UART_SetConfig+0x218>)
 8002122:	429d      	cmp	r5, r3
 8002124:	d107      	bne.n	8002136 <UART_SetConfig+0x5a>
 8002126:	f503 4358 	add.w	r3, r3, #55296	; 0xd800
 800212a:	4a73      	ldr	r2, [pc, #460]	; (80022f8 <UART_SetConfig+0x21c>)
 800212c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8002130:	f003 0303 	and.w	r3, r3, #3
 8002134:	e009      	b.n	800214a <UART_SetConfig+0x6e>
 8002136:	4b71      	ldr	r3, [pc, #452]	; (80022fc <UART_SetConfig+0x220>)
 8002138:	429d      	cmp	r5, r3
 800213a:	d10b      	bne.n	8002154 <UART_SetConfig+0x78>
 800213c:	f503 33e6 	add.w	r3, r3, #117760	; 0x1cc00
 8002140:	4a6f      	ldr	r2, [pc, #444]	; (8002300 <UART_SetConfig+0x224>)
 8002142:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8002146:	f003 030c 	and.w	r3, r3, #12
        }
      }  /*   if ( (tmpreg < (3 * huart->Init.BaudRate) ) || (tmpreg > (4096 * huart->Init.BaudRate) )) */
    } /* if (tmpreg != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800214a:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800214e:	5cd3      	ldrb	r3, [r2, r3]
 8002150:	d065      	beq.n	800221e <UART_SetConfig+0x142>
 8002152:	e099      	b.n	8002288 <UART_SetConfig+0x1ac>
    tmpreg |= huart->Init.OneBitSampling;
  }
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8002154:	4b66      	ldr	r3, [pc, #408]	; (80022f0 <UART_SetConfig+0x214>)
 8002156:	429d      	cmp	r5, r3
 8002158:	f040 8089 	bne.w	800226e <UART_SetConfig+0x192>
 800215c:	f503 33c8 	add.w	r3, r3, #102400	; 0x19000
 8002160:	f8d3 5088 	ldr.w	r5, [r3, #136]	; 0x88
 8002164:	f405 6540 	and.w	r5, r5, #3072	; 0xc00
 8002168:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 800216c:	d014      	beq.n	8002198 <UART_SetConfig+0xbc>
 800216e:	d805      	bhi.n	800217c <UART_SetConfig+0xa0>
 8002170:	2d00      	cmp	r5, #0
 8002172:	f040 80b7 	bne.w	80022e4 <UART_SetConfig+0x208>
    tmpreg = 0;

    switch (clocksource)
    {
    case UART_CLOCKSOURCE_PCLK1:
      tmpreg = HAL_RCC_GetPCLK1Freq();
 8002176:	f7ff fbf3 	bl	8001960 <HAL_RCC_GetPCLK1Freq>
      break;
 800217a:	e010      	b.n	800219e <UART_SetConfig+0xc2>
    tmpreg |= huart->Init.OneBitSampling;
  }
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 800217c:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 8002180:	d007      	beq.n	8002192 <UART_SetConfig+0xb6>
 8002182:	f5b5 6f40 	cmp.w	r5, #3072	; 0xc00
 8002186:	f040 80ad 	bne.w	80022e4 <UART_SetConfig+0x208>
 800218a:	2508      	movs	r5, #8
      break;
    case UART_CLOCKSOURCE_SYSCLK:
      tmpreg = HAL_RCC_GetSysClockFreq();
      break;
    case UART_CLOCKSOURCE_LSE:
      tmpreg = (uint32_t) LSE_VALUE;
 800218c:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8002190:	e008      	b.n	80021a4 <UART_SetConfig+0xc8>
    tmpreg |= huart->Init.OneBitSampling;
  }
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8002192:	2502      	movs	r5, #2
    {
    case UART_CLOCKSOURCE_PCLK1:
      tmpreg = HAL_RCC_GetPCLK1Freq();
      break;
    case UART_CLOCKSOURCE_HSI:
      tmpreg = (uint32_t) HSI_VALUE;
 8002194:	485b      	ldr	r0, [pc, #364]	; (8002304 <UART_SetConfig+0x228>)
 8002196:	e005      	b.n	80021a4 <UART_SetConfig+0xc8>
      break;
    case UART_CLOCKSOURCE_SYSCLK:
      tmpreg = HAL_RCC_GetSysClockFreq();
 8002198:	f7ff f814 	bl	80011c4 <HAL_RCC_GetSysClockFreq>
      break;
 800219c:	2504      	movs	r5, #4
        ret = HAL_ERROR;
      break;
    }

    /* if proper clock source reported */
    if (tmpreg != 0)
 800219e:	2800      	cmp	r0, #0
 80021a0:	f000 809e 	beq.w	80022e0 <UART_SetConfig+0x204>
    {
      /* ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ( (tmpreg < (3 * huart->Init.BaudRate) ) ||
 80021a4:	6862      	ldr	r2, [r4, #4]
 80021a6:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 80021aa:	4283      	cmp	r3, r0
 80021ac:	f200 809a 	bhi.w	80022e4 <UART_SetConfig+0x208>
 80021b0:	ebb0 3f02 	cmp.w	r0, r2, lsl #12
 80021b4:	f200 8096 	bhi.w	80022e4 <UART_SetConfig+0x208>
      {
        ret = HAL_ERROR;
      }
      else
      {
        switch (clocksource)
 80021b8:	2d08      	cmp	r5, #8
 80021ba:	d827      	bhi.n	800220c <UART_SetConfig+0x130>
 80021bc:	e8df f005 	tbb	[pc, r5]
 80021c0:	26082605 	.word	0x26082605
 80021c4:	2626260e 	.word	0x2626260e
 80021c8:	1b          	.byte	0x1b
 80021c9:	00          	.byte	0x00
        {
        case UART_CLOCKSOURCE_PCLK1:
          tmpreg = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 80021ca:	f7ff fbc9 	bl	8001960 <HAL_RCC_GetPCLK1Freq>
 80021ce:	e007      	b.n	80021e0 <UART_SetConfig+0x104>
          break;
        case UART_CLOCKSOURCE_HSI:
          tmpreg = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate));
 80021d0:	484d      	ldr	r0, [pc, #308]	; (8002308 <UART_SetConfig+0x22c>)
 80021d2:	0855      	lsrs	r5, r2, #1
 80021d4:	2300      	movs	r3, #0
 80021d6:	2100      	movs	r1, #0
 80021d8:	1940      	adds	r0, r0, r5
 80021da:	e011      	b.n	8002200 <UART_SetConfig+0x124>
          break;
        case UART_CLOCKSOURCE_SYSCLK:
          tmpreg = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 80021dc:	f7fe fff2 	bl	80011c4 <HAL_RCC_GetSysClockFreq>
 80021e0:	6862      	ldr	r2, [r4, #4]
 80021e2:	f44f 7180 	mov.w	r1, #256	; 0x100
 80021e6:	0856      	lsrs	r6, r2, #1
 80021e8:	2700      	movs	r7, #0
 80021ea:	fbe1 6700 	umlal	r6, r7, r1, r0
 80021ee:	2300      	movs	r3, #0
 80021f0:	4630      	mov	r0, r6
 80021f2:	4639      	mov	r1, r7
 80021f4:	e006      	b.n	8002204 <UART_SetConfig+0x128>
          break;
        case UART_CLOCKSOURCE_LSE:
          tmpreg = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate));
 80021f6:	0850      	lsrs	r0, r2, #1
 80021f8:	2100      	movs	r1, #0
 80021fa:	2300      	movs	r3, #0
 80021fc:	f510 0000 	adds.w	r0, r0, #8388608	; 0x800000
 8002200:	f141 0100 	adc.w	r1, r1, #0
 8002204:	f7fe fc66 	bl	8000ad4 <__aeabi_uldivmod>
          break;
 8002208:	2200      	movs	r2, #0
 800220a:	e000      	b.n	800220e <UART_SetConfig+0x132>
        case UART_CLOCKSOURCE_UNDEFINED:
        default:
          ret = HAL_ERROR;
 800220c:	2201      	movs	r2, #1
          break;
        }
   
        if ((tmpreg >= UART_LPUART_BRR_MIN) && (tmpreg <= UART_LPUART_BRR_MAX))
 800220e:	4b3f      	ldr	r3, [pc, #252]	; (800230c <UART_SetConfig+0x230>)
 8002210:	f5a0 7140 	sub.w	r1, r0, #768	; 0x300
 8002214:	4299      	cmp	r1, r3
 8002216:	d865      	bhi.n	80022e4 <UART_SetConfig+0x208>
        {
           huart->Instance->BRR = tmpreg;
 8002218:	6823      	ldr	r3, [r4, #0]
 800221a:	60d8      	str	r0, [r3, #12]
 800221c:	e063      	b.n	80022e6 <UART_SetConfig+0x20a>
    } /* if (tmpreg != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
  {
    switch (clocksource)
 800221e:	2b08      	cmp	r3, #8
 8002220:	d828      	bhi.n	8002274 <UART_SetConfig+0x198>
 8002222:	e8df f003 	tbb	[pc, r3]
 8002226:	0805      	.short	0x0805
 8002228:	2712270b 	.word	0x2712270b
 800222c:	2727      	.short	0x2727
 800222e:	1b          	.byte	0x1b
 800222f:	00          	.byte	0x00
    {
    case UART_CLOCKSOURCE_PCLK1:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8002230:	f7ff fb96 	bl	8001960 <HAL_RCC_GetPCLK1Freq>
 8002234:	e00b      	b.n	800224e <UART_SetConfig+0x172>
      break;
    case UART_CLOCKSOURCE_PCLK2:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 8002236:	f7ff fbab 	bl	8001990 <HAL_RCC_GetPCLK2Freq>
 800223a:	e008      	b.n	800224e <UART_SetConfig+0x172>
      break;
    case UART_CLOCKSOURCE_HSI:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 800223c:	6860      	ldr	r0, [r4, #4]
 800223e:	0842      	lsrs	r2, r0, #1
 8002240:	f102 73f4 	add.w	r3, r2, #31981568	; 0x1e80000
 8002244:	f503 4390 	add.w	r3, r3, #18432	; 0x4800
 8002248:	e00c      	b.n	8002264 <UART_SetConfig+0x188>
      break;
    case UART_CLOCKSOURCE_SYSCLK:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800224a:	f7fe ffbb 	bl	80011c4 <HAL_RCC_GetSysClockFreq>
 800224e:	6863      	ldr	r3, [r4, #4]
 8002250:	085a      	lsrs	r2, r3, #1
 8002252:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 8002256:	fbb0 f3f3 	udiv	r3, r0, r3
 800225a:	e005      	b.n	8002268 <UART_SetConfig+0x18c>
      break;
    case UART_CLOCKSOURCE_LSE:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 800225c:	6860      	ldr	r0, [r4, #4]
 800225e:	0843      	lsrs	r3, r0, #1
 8002260:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8002264:	fbb3 f3f0 	udiv	r3, r3, r0
 8002268:	b29b      	uxth	r3, r3
{
  uint32_t tmpreg                     = 0x00000000;
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
  uint16_t brrtemp                    = 0x0000;
  uint16_t usartdiv                   = 0x0000;
  HAL_StatusTypeDef ret               = HAL_OK;
 800226a:	2200      	movs	r2, #0
    case UART_CLOCKSOURCE_SYSCLK:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
      break;
    case UART_CLOCKSOURCE_LSE:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
      break;
 800226c:	e004      	b.n	8002278 <UART_SetConfig+0x19c>
        }
      }  /*   if ( (tmpreg < (3 * huart->Init.BaudRate) ) || (tmpreg > (4096 * huart->Init.BaudRate) )) */
    } /* if (tmpreg != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800226e:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8002272:	d137      	bne.n	80022e4 <UART_SetConfig+0x208>
    case UART_CLOCKSOURCE_LSE:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
      break;
    case UART_CLOCKSOURCE_UNDEFINED:
    default:
        ret = HAL_ERROR;
 8002274:	2201      	movs	r2, #1
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
  uint32_t tmpreg                     = 0x00000000;
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
  uint16_t brrtemp                    = 0x0000;
  uint16_t usartdiv                   = 0x0000;
 8002276:	2300      	movs	r3, #0
        ret = HAL_ERROR;
      break;
    }

    brrtemp = usartdiv & 0xFFF0;
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000F) >> 1U);
 8002278:	f3c3 0042 	ubfx	r0, r3, #1, #3
    huart->Instance->BRR = brrtemp;
 800227c:	6821      	ldr	r1, [r4, #0]
        ret = HAL_ERROR;
      break;
    }

    brrtemp = usartdiv & 0xFFF0;
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000F) >> 1U);
 800227e:	f023 030f 	bic.w	r3, r3, #15
    huart->Instance->BRR = brrtemp;
 8002282:	4303      	orrs	r3, r0
 8002284:	60cb      	str	r3, [r1, #12]
 8002286:	e02e      	b.n	80022e6 <UART_SetConfig+0x20a>
  }
  else
  {
    switch (clocksource)
 8002288:	2b08      	cmp	r3, #8
 800228a:	d82b      	bhi.n	80022e4 <UART_SetConfig+0x208>
 800228c:	e8df f003 	tbb	[pc, r3]
 8002290:	2a0b0805 	.word	0x2a0b0805
 8002294:	2a2a2a14 	.word	0x2a2a2a14
 8002298:	1e          	.byte	0x1e
 8002299:	00          	.byte	0x00
    {
    case UART_CLOCKSOURCE_PCLK1:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 800229a:	f7ff fb61 	bl	8001960 <HAL_RCC_GetPCLK1Freq>
 800229e:	e00d      	b.n	80022bc <UART_SetConfig+0x1e0>
      break;
    case UART_CLOCKSOURCE_PCLK2:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 80022a0:	f7ff fb76 	bl	8001990 <HAL_RCC_GetPCLK2Freq>
 80022a4:	e00a      	b.n	80022bc <UART_SetConfig+0x1e0>
      break;
    case UART_CLOCKSOURCE_HSI:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 80022a6:	6861      	ldr	r1, [r4, #4]
 80022a8:	084a      	lsrs	r2, r1, #1
 80022aa:	f502 0374 	add.w	r3, r2, #15990784	; 0xf40000
 80022ae:	f503 5310 	add.w	r3, r3, #9216	; 0x2400
 80022b2:	fbb3 f3f1 	udiv	r3, r3, r1
 80022b6:	e00f      	b.n	80022d8 <UART_SetConfig+0x1fc>
      break;
    case UART_CLOCKSOURCE_SYSCLK:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 80022b8:	f7fe ff84 	bl	80011c4 <HAL_RCC_GetSysClockFreq>
 80022bc:	6863      	ldr	r3, [r4, #4]
 80022be:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 80022c2:	fbb0 f0f3 	udiv	r0, r0, r3
 80022c6:	b280      	uxth	r0, r0
 80022c8:	60e8      	str	r0, [r5, #12]
 80022ca:	e007      	b.n	80022dc <UART_SetConfig+0x200>
      break;
    case UART_CLOCKSOURCE_LSE:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 80022cc:	6862      	ldr	r2, [r4, #4]
 80022ce:	0853      	lsrs	r3, r2, #1
 80022d0:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
 80022d4:	fbb3 f3f2 	udiv	r3, r3, r2
 80022d8:	b29b      	uxth	r3, r3
 80022da:	60eb      	str	r3, [r5, #12]
{
  uint32_t tmpreg                     = 0x00000000;
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
  uint16_t brrtemp                    = 0x0000;
  uint16_t usartdiv                   = 0x0000;
  HAL_StatusTypeDef ret               = HAL_OK;
 80022dc:	2200      	movs	r2, #0
    case UART_CLOCKSOURCE_SYSCLK:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
      break;
    case UART_CLOCKSOURCE_LSE:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
      break;
 80022de:	e002      	b.n	80022e6 <UART_SetConfig+0x20a>
 80022e0:	4602      	mov	r2, r0
 80022e2:	e000      	b.n	80022e6 <UART_SetConfig+0x20a>
    case UART_CLOCKSOURCE_UNDEFINED:
    default:
        ret = HAL_ERROR;
 80022e4:	2201      	movs	r2, #1
    }
  }

  return ret;

}
 80022e6:	4610      	mov	r0, r2
 80022e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80022ea:	bf00      	nop
 80022ec:	efff69f3 	.word	0xefff69f3
 80022f0:	40008000 	.word	0x40008000
 80022f4:	40013800 	.word	0x40013800
 80022f8:	08004048 	.word	0x08004048
 80022fc:	40004400 	.word	0x40004400
 8002300:	0800404c 	.word	0x0800404c
 8002304:	00f42400 	.word	0x00f42400
 8002308:	f4240000 	.word	0xf4240000
 800230c:	000ffcff 	.word	0x000ffcff

08002310 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8002310:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8002312:	07da      	lsls	r2, r3, #31
  * @brief Configure the UART peripheral advanced features.
  * @param huart: UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 8002314:	b510      	push	{r4, lr}
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8002316:	d506      	bpl.n	8002326 <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8002318:	6804      	ldr	r4, [r0, #0]
 800231a:	6862      	ldr	r2, [r4, #4]
 800231c:	f422 3100 	bic.w	r1, r2, #131072	; 0x20000
 8002320:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8002322:	430a      	orrs	r2, r1
 8002324:	6062      	str	r2, [r4, #4]
  }

  /* if required, configure RX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8002326:	079c      	lsls	r4, r3, #30
 8002328:	d506      	bpl.n	8002338 <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800232a:	6804      	ldr	r4, [r0, #0]
 800232c:	6862      	ldr	r2, [r4, #4]
 800232e:	f422 3180 	bic.w	r1, r2, #65536	; 0x10000
 8002332:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8002334:	430a      	orrs	r2, r1
 8002336:	6062      	str	r2, [r4, #4]
  }

  /* if required, configure data inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8002338:	0759      	lsls	r1, r3, #29
 800233a:	d506      	bpl.n	800234a <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800233c:	6804      	ldr	r4, [r0, #0]
 800233e:	6862      	ldr	r2, [r4, #4]
 8002340:	f422 2180 	bic.w	r1, r2, #262144	; 0x40000
 8002344:	6b02      	ldr	r2, [r0, #48]	; 0x30
 8002346:	430a      	orrs	r2, r1
 8002348:	6062      	str	r2, [r4, #4]
  }

  /* if required, configure RX/TX pins swap */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800234a:	071a      	lsls	r2, r3, #28
 800234c:	d506      	bpl.n	800235c <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800234e:	6804      	ldr	r4, [r0, #0]
 8002350:	6862      	ldr	r2, [r4, #4]
 8002352:	f422 4100 	bic.w	r1, r2, #32768	; 0x8000
 8002356:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8002358:	430a      	orrs	r2, r1
 800235a:	6062      	str	r2, [r4, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800235c:	06dc      	lsls	r4, r3, #27
 800235e:	d506      	bpl.n	800236e <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8002360:	6804      	ldr	r4, [r0, #0]
 8002362:	68a2      	ldr	r2, [r4, #8]
 8002364:	f422 5180 	bic.w	r1, r2, #4096	; 0x1000
 8002368:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800236a:	430a      	orrs	r2, r1
 800236c:	60a2      	str	r2, [r4, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800236e:	0699      	lsls	r1, r3, #26
 8002370:	d506      	bpl.n	8002380 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8002372:	6804      	ldr	r4, [r0, #0]
 8002374:	68a2      	ldr	r2, [r4, #8]
 8002376:	f422 5100 	bic.w	r1, r2, #8192	; 0x2000
 800237a:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 800237c:	430a      	orrs	r2, r1
 800237e:	60a2      	str	r2, [r4, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8002380:	065a      	lsls	r2, r3, #25
 8002382:	d50f      	bpl.n	80023a4 <UART_AdvFeatureConfig+0x94>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8002384:	6801      	ldr	r1, [r0, #0]
 8002386:	6c04      	ldr	r4, [r0, #64]	; 0x40
 8002388:	684a      	ldr	r2, [r1, #4]
 800238a:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 800238e:	4322      	orrs	r2, r4
    /* set auto Baudrate detection parameters if detection is enabled */
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8002390:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
  /* if required, configure auto Baud rate detection scheme */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8002394:	604a      	str	r2, [r1, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8002396:	d105      	bne.n	80023a4 <UART_AdvFeatureConfig+0x94>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8002398:	684a      	ldr	r2, [r1, #4]
 800239a:	f422 04c0 	bic.w	r4, r2, #6291456	; 0x600000
 800239e:	6c42      	ldr	r2, [r0, #68]	; 0x44
 80023a0:	4322      	orrs	r2, r4
 80023a2:	604a      	str	r2, [r1, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 80023a4:	061b      	lsls	r3, r3, #24
 80023a6:	d506      	bpl.n	80023b6 <UART_AdvFeatureConfig+0xa6>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 80023a8:	6801      	ldr	r1, [r0, #0]
 80023aa:	684b      	ldr	r3, [r1, #4]
 80023ac:	f423 2200 	bic.w	r2, r3, #524288	; 0x80000
 80023b0:	6c83      	ldr	r3, [r0, #72]	; 0x48
 80023b2:	4313      	orrs	r3, r2
 80023b4:	604b      	str	r3, [r1, #4]
 80023b6:	bd10      	pop	{r4, pc}

080023b8 <UART_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
{
 80023b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80023bc:	9d06      	ldr	r5, [sp, #24]
 80023be:	4604      	mov	r4, r0
 80023c0:	460f      	mov	r7, r1
 80023c2:	4616      	mov	r6, r2
 80023c4:	4698      	mov	r8, r3
  /* Wait until flag is set */
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80023c6:	6821      	ldr	r1, [r4, #0]
 80023c8:	69ca      	ldr	r2, [r1, #28]
 80023ca:	ea37 0302 	bics.w	r3, r7, r2
 80023ce:	bf0c      	ite	eq
 80023d0:	2201      	moveq	r2, #1
 80023d2:	2200      	movne	r2, #0
 80023d4:	42b2      	cmp	r2, r6
 80023d6:	d11d      	bne.n	8002414 <UART_WaitOnFlagUntilTimeout+0x5c>
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 80023d8:	1c6b      	adds	r3, r5, #1
 80023da:	d0f5      	beq.n	80023c8 <UART_WaitOnFlagUntilTimeout+0x10>
    {
      if((Timeout == 0) || ((HAL_GetTick()-Tickstart) > Timeout))
 80023dc:	b99d      	cbnz	r5, 8002406 <UART_WaitOnFlagUntilTimeout+0x4e>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80023de:	6823      	ldr	r3, [r4, #0]
 80023e0:	681a      	ldr	r2, [r3, #0]
 80023e2:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 80023e6:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80023e8:	689a      	ldr	r2, [r3, #8]
 80023ea:	f022 0201 	bic.w	r2, r2, #1
 80023ee:	609a      	str	r2, [r3, #8]

        huart->gState  = HAL_UART_STATE_READY;
 80023f0:	2320      	movs	r3, #32
 80023f2:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
        huart->RxState = HAL_UART_STATE_READY;
 80023f6:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a

        /* Process Unlocked */
        __HAL_UNLOCK(huart);
 80023fa:	2300      	movs	r3, #0
 80023fc:	f884 3068 	strb.w	r3, [r4, #104]	; 0x68
 8002400:	2003      	movs	r0, #3
 8002402:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0) || ((HAL_GetTick()-Tickstart) > Timeout))
 8002406:	f7fe fd19 	bl	8000e3c <HAL_GetTick>
 800240a:	ebc8 0000 	rsb	r0, r8, r0
 800240e:	4285      	cmp	r5, r0
 8002410:	d2d9      	bcs.n	80023c6 <UART_WaitOnFlagUntilTimeout+0xe>
 8002412:	e7e4      	b.n	80023de <UART_WaitOnFlagUntilTimeout+0x26>
        __HAL_UNLOCK(huart);
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 8002414:	2000      	movs	r0, #0
}
 8002416:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800241a <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 800241a:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800241c:	4604      	mov	r4, r0
  uint32_t tickstart = 0;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800241e:	2600      	movs	r6, #0
 8002420:	66c6      	str	r6, [r0, #108]	; 0x6c

  /* Init tickstart for timeout managment*/
  tickstart = HAL_GetTick();
 8002422:	f7fe fd0b 	bl	8000e3c <HAL_GetTick>

  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8002426:	6823      	ldr	r3, [r4, #0]
 8002428:	681b      	ldr	r3, [r3, #0]
 800242a:	071a      	lsls	r2, r3, #28

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;

  /* Init tickstart for timeout managment*/
  tickstart = HAL_GetTick();
 800242c:	4605      	mov	r5, r0

  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800242e:	d404      	bmi.n	800243a <UART_CheckIdleState+0x20>
      /* Timeout occurred */
      return HAL_TIMEOUT;
    }
  }
  /* Check if the Receiver is enabled */
  if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8002430:	6823      	ldr	r3, [r4, #0]
 8002432:	681b      	ldr	r3, [r3, #0]
 8002434:	075b      	lsls	r3, r3, #29
 8002436:	d51a      	bpl.n	800246e <UART_CheckIdleState+0x54>
 8002438:	e00d      	b.n	8002456 <UART_CheckIdleState+0x3c>

  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
  {
    /* Wait until TEACK flag is set */
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800243a:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800243e:	9300      	str	r3, [sp, #0]
 8002440:	4632      	mov	r2, r6
 8002442:	4603      	mov	r3, r0
 8002444:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8002448:	4620      	mov	r0, r4
 800244a:	f7ff ffb5 	bl	80023b8 <UART_WaitOnFlagUntilTimeout>
 800244e:	2800      	cmp	r0, #0
 8002450:	d0ee      	beq.n	8002430 <UART_CheckIdleState+0x16>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 8002452:	2003      	movs	r0, #3
 8002454:	e013      	b.n	800247e <UART_CheckIdleState+0x64>
  }
  /* Check if the Receiver is enabled */
  if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
  {
    /* Wait until REACK flag is set */
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8002456:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800245a:	9300      	str	r3, [sp, #0]
 800245c:	2200      	movs	r2, #0
 800245e:	462b      	mov	r3, r5
 8002460:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8002464:	4620      	mov	r0, r4
 8002466:	f7ff ffa7 	bl	80023b8 <UART_WaitOnFlagUntilTimeout>
 800246a:	2800      	cmp	r0, #0
 800246c:	d1f1      	bne.n	8002452 <UART_CheckIdleState+0x38>
      return HAL_TIMEOUT;
    }
  }

  /* Initialize the UART State */
  huart->gState  = HAL_UART_STATE_READY;
 800246e:	2320      	movs	r3, #32
  huart->RxState = HAL_UART_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8002470:	2000      	movs	r0, #0
      return HAL_TIMEOUT;
    }
  }

  /* Initialize the UART State */
  huart->gState  = HAL_UART_STATE_READY;
 8002472:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
  huart->RxState = HAL_UART_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8002476:	f884 0068 	strb.w	r0, [r4, #104]	; 0x68
    }
  }

  /* Initialize the UART State */
  huart->gState  = HAL_UART_STATE_READY;
  huart->RxState = HAL_UART_STATE_READY;
 800247a:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a

  /* Process Unlocked */
  __HAL_UNLOCK(huart);

  return HAL_OK;
}
 800247e:	b002      	add	sp, #8
 8002480:	bd70      	pop	{r4, r5, r6, pc}

08002482 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart: UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 8002482:	b510      	push	{r4, lr}
  /* Check the UART handle allocation */
  if(huart == NULL)
 8002484:	4604      	mov	r4, r0
 8002486:	b360      	cbz	r0, 80024e2 <HAL_UART_Init+0x60>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if(huart->gState == HAL_UART_STATE_RESET)
 8002488:	f890 3069 	ldrb.w	r3, [r0, #105]	; 0x69
 800248c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002490:	b91b      	cbnz	r3, 800249a <HAL_UART_Init+0x18>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8002492:	f880 2068 	strb.w	r2, [r0, #104]	; 0x68

    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 8002496:	f000 fc89 	bl	8002dac <HAL_UART_MspInit>
  }

  huart->gState = HAL_UART_STATE_BUSY;

  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 800249a:	6822      	ldr	r2, [r4, #0]

    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
  }

  huart->gState = HAL_UART_STATE_BUSY;
 800249c:	2324      	movs	r3, #36	; 0x24
 800249e:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69

  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 80024a2:	6813      	ldr	r3, [r2, #0]
 80024a4:	f023 0301 	bic.w	r3, r3, #1
 80024a8:	6013      	str	r3, [r2, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 80024aa:	4620      	mov	r0, r4
 80024ac:	f7ff fe16 	bl	80020dc <UART_SetConfig>
 80024b0:	2801      	cmp	r0, #1
 80024b2:	d016      	beq.n	80024e2 <HAL_UART_Init+0x60>
  {
    return HAL_ERROR;
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 80024b4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80024b6:	b113      	cbz	r3, 80024be <HAL_UART_Init+0x3c>
  {
    UART_AdvFeatureConfig(huart);
 80024b8:	4620      	mov	r0, r4
 80024ba:	f7ff ff29 	bl	8002310 <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80024be:	6823      	ldr	r3, [r4, #0]
 80024c0:	685a      	ldr	r2, [r3, #4]
 80024c2:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 80024c6:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80024c8:	689a      	ldr	r2, [r3, #8]
 80024ca:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 80024ce:	609a      	str	r2, [r3, #8]

  /* Enable the Peripheral */
  __HAL_UART_ENABLE(huart);
 80024d0:	681a      	ldr	r2, [r3, #0]
 80024d2:	f042 0201 	orr.w	r2, r2, #1

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 80024d6:	4620      	mov	r0, r4
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));

  /* Enable the Peripheral */
  __HAL_UART_ENABLE(huart);
 80024d8:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
}
 80024da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  /* Enable the Peripheral */
  __HAL_UART_ENABLE(huart);

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 80024de:	f7ff bf9c 	b.w	800241a <UART_CheckIdleState>
}
 80024e2:	2001      	movs	r0, #1
 80024e4:	bd10      	pop	{r4, pc}

080024e6 <commandList>:
static uint16_t _fg = ST7735_GREEN;
static uint16_t _bg = ST7735_BLACK;

// Companion code to the above tables.  Reads and issues
// a series of LCD commands stored in PROGMEM byte array.
static void commandList(const uint8_t *addr) {
 80024e6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t  numCommands, numArgs;
	uint16_t ms;

	numCommands = *addr++;   // Number of commands to follow
 80024ea:	7806      	ldrb	r6, [r0, #0]
 80024ec:	1c44      	adds	r4, r0, #1
	while(numCommands--) {                 // For each command...
 80024ee:	b32e      	cbz	r6, 800253c <commandList+0x56>
		lcd7735_sendCmd(*addr++); //   Read, issue command
 80024f0:	4627      	mov	r7, r4
 80024f2:	f817 0b02 	ldrb.w	r0, [r7], #2
 80024f6:	f000 faf7 	bl	8002ae8 <lcd7735_sendCmd>
		numArgs  = *addr++;    //   Number of args to follow
 80024fa:	7865      	ldrb	r5, [r4, #1]
 80024fc:	f025 087f 	bic.w	r8, r5, #127	; 0x7f
		ms       = numArgs & DELAY;          //   If hibit set, delay follows args
		numArgs &= ~DELAY;                   //   Mask out delay bit
 8002500:	f005 057f 	and.w	r5, r5, #127	; 0x7f
 8002504:	fa5f f888 	uxtb.w	r8, r8
 8002508:	462c      	mov	r4, r5
	uint16_t ms;

	numCommands = *addr++;   // Number of commands to follow
	while(numCommands--) {                 // For each command...
		lcd7735_sendCmd(*addr++); //   Read, issue command
		numArgs  = *addr++;    //   Number of args to follow
 800250a:	46b9      	mov	r9, r7
		ms       = numArgs & DELAY;          //   If hibit set, delay follows args
		numArgs &= ~DELAY;                   //   Mask out delay bit
		while(numArgs--) {                   //   For each argument...
 800250c:	3c01      	subs	r4, #1
 800250e:	b2e4      	uxtb	r4, r4
 8002510:	2cff      	cmp	r4, #255	; 0xff
 8002512:	d004      	beq.n	800251e <commandList+0x38>
			lcd7735_sendData(*addr++);  //     Read, issue argument
 8002514:	f819 0b01 	ldrb.w	r0, [r9], #1
 8002518:	f000 faee 	bl	8002af8 <lcd7735_sendData>
 800251c:	e7f6      	b.n	800250c <commandList+0x26>
 800251e:	197c      	adds	r4, r7, r5
		}

		if(ms) {
 8002520:	f1b8 0f00 	cmp.w	r8, #0
 8002524:	d007      	beq.n	8002536 <commandList+0x50>
			ms = *addr++; // Read post-command delay time (ms)
 8002526:	5d78      	ldrb	r0, [r7, r5]
			if(ms == 255) ms = 500;     // If 255, delay for 500 ms
 8002528:	28ff      	cmp	r0, #255	; 0xff
			HAL_Delay(ms);
 800252a:	bf08      	it	eq
 800252c:	f44f 70fa 	moveq.w	r0, #500	; 0x1f4
		while(numArgs--) {                   //   For each argument...
			lcd7735_sendData(*addr++);  //     Read, issue argument
		}

		if(ms) {
			ms = *addr++; // Read post-command delay time (ms)
 8002530:	3401      	adds	r4, #1
			if(ms == 255) ms = 500;     // If 255, delay for 500 ms
			HAL_Delay(ms);
 8002532:	f7fe fc89 	bl	8000e48 <HAL_Delay>
 8002536:	3e01      	subs	r6, #1
 8002538:	b2f6      	uxtb	r6, r6
 800253a:	e7d8      	b.n	80024ee <commandList+0x8>
		}
	}
}
 800253c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08002540 <commonInit>:

// Initialization code common to both 'B' and 'R' type displays
static void commonInit(const uint8_t *cmdList) {
 8002540:	b570      	push	{r4, r5, r6, lr}
	// toggle RST low to reset; CS low so it'll listen to us
	LCD_CS0;
 8002542:	4c0c      	ldr	r4, [pc, #48]	; (8002574 <commonInit+0x34>)
 8002544:	2302      	movs	r3, #2
#ifdef LCD_SOFT_RESET
	lcd7735_sendCmd(ST7735_SWRESET);
	delay_ms(500);
#else
	LCD_RST1;
 8002546:	2510      	movs	r5, #16
}

// Initialization code common to both 'B' and 'R' type displays
static void commonInit(const uint8_t *cmdList) {
	// toggle RST low to reset; CS low so it'll listen to us
	LCD_CS0;
 8002548:	62a3      	str	r3, [r4, #40]	; 0x28
		}
	}
}

// Initialization code common to both 'B' and 'R' type displays
static void commonInit(const uint8_t *cmdList) {
 800254a:	4606      	mov	r6, r0
	LCD_CS0;
#ifdef LCD_SOFT_RESET
	lcd7735_sendCmd(ST7735_SWRESET);
	delay_ms(500);
#else
	LCD_RST1;
 800254c:	61a5      	str	r5, [r4, #24]
	HAL_Delay(100);
 800254e:	2064      	movs	r0, #100	; 0x64
 8002550:	f7fe fc7a 	bl	8000e48 <HAL_Delay>
	LCD_RST0;
	HAL_Delay(100);
 8002554:	2064      	movs	r0, #100	; 0x64
	lcd7735_sendCmd(ST7735_SWRESET);
	delay_ms(500);
#else
	LCD_RST1;
	HAL_Delay(100);
	LCD_RST0;
 8002556:	62a5      	str	r5, [r4, #40]	; 0x28
	HAL_Delay(100);
 8002558:	f7fe fc76 	bl	8000e48 <HAL_Delay>
	LCD_RST1;
 800255c:	61a5      	str	r5, [r4, #24]
	HAL_Delay(100);
 800255e:	2064      	movs	r0, #100	; 0x64
 8002560:	f7fe fc72 	bl	8000e48 <HAL_Delay>
#endif    
	if(cmdList) commandList(cmdList);
 8002564:	b126      	cbz	r6, 8002570 <commonInit+0x30>
 8002566:	4630      	mov	r0, r6
}
 8002568:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	LCD_RST0;
	HAL_Delay(100);
	LCD_RST1;
	HAL_Delay(100);
#endif    
	if(cmdList) commandList(cmdList);
 800256c:	f7ff bfbb 	b.w	80024e6 <commandList>
 8002570:	bd70      	pop	{r4, r5, r6, pc}
 8002572:	bf00      	nop
 8002574:	48000400 	.word	0x48000400

08002578 <lcd7735_initR>:
	commonInit(Bcmd);
}


// Initialization for ST7735R screens (green or red tabs)
void lcd7735_initR(uint8_t options) {
 8002578:	b510      	push	{r4, lr}
 800257a:	4604      	mov	r4, r0
	HAL_Delay(50);
 800257c:	2032      	movs	r0, #50	; 0x32
 800257e:	f7fe fc63 	bl	8000e48 <HAL_Delay>
	commonInit(Rcmd1);
 8002582:	480f      	ldr	r0, [pc, #60]	; (80025c0 <lcd7735_initR+0x48>)
 8002584:	f7ff ffdc 	bl	8002540 <commonInit>
	if(options == INITR_GREENTAB) {
 8002588:	b94c      	cbnz	r4, 800259e <lcd7735_initR+0x26>
		commandList(Rcmd2green);
 800258a:	480e      	ldr	r0, [pc, #56]	; (80025c4 <lcd7735_initR+0x4c>)
 800258c:	f7ff ffab 	bl	80024e6 <commandList>
		colstart = 2;
 8002590:	4b0d      	ldr	r3, [pc, #52]	; (80025c8 <lcd7735_initR+0x50>)
 8002592:	2202      	movs	r2, #2
 8002594:	601a      	str	r2, [r3, #0]
		rowstart = 1;
 8002596:	4b0d      	ldr	r3, [pc, #52]	; (80025cc <lcd7735_initR+0x54>)
 8002598:	2201      	movs	r2, #1
 800259a:	601a      	str	r2, [r3, #0]
 800259c:	e002      	b.n	80025a4 <lcd7735_initR+0x2c>
	} else {
		// colstart, rowstart left at default '0' values
		commandList(Rcmd2red);
 800259e:	480c      	ldr	r0, [pc, #48]	; (80025d0 <lcd7735_initR+0x58>)
 80025a0:	f7ff ffa1 	bl	80024e6 <commandList>
	}
	commandList(Rcmd3);
 80025a4:	480b      	ldr	r0, [pc, #44]	; (80025d4 <lcd7735_initR+0x5c>)
 80025a6:	f7ff ff9e 	bl	80024e6 <commandList>

	// if black, change MADCTL color filter
	if (options == INITR_BLACKTAB) {
 80025aa:	2c02      	cmp	r4, #2
 80025ac:	d107      	bne.n	80025be <lcd7735_initR+0x46>
		lcd7735_sendCmd(ST7735_MADCTL);
 80025ae:	2036      	movs	r0, #54	; 0x36
 80025b0:	f000 fa9a 	bl	8002ae8 <lcd7735_sendCmd>
		lcd7735_sendData(0xC0);
 80025b4:	20c0      	movs	r0, #192	; 0xc0
	}

	//  tabcolor = options;
}
 80025b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	commandList(Rcmd3);

	// if black, change MADCTL color filter
	if (options == INITR_BLACKTAB) {
		lcd7735_sendCmd(ST7735_MADCTL);
		lcd7735_sendData(0xC0);
 80025ba:	f000 ba9d 	b.w	8002af8 <lcd7735_sendData>
 80025be:	bd10      	pop	{r4, pc}
 80025c0:	080044d1 	.word	0x080044d1
 80025c4:	08004538 	.word	0x08004538
 80025c8:	20000040 	.word	0x20000040
 80025cc:	20000038 	.word	0x20000038
 80025d0:	08004545 	.word	0x08004545
 80025d4:	0800450d 	.word	0x0800450d

080025d8 <lcd7735_setAddrWindow>:

	//  tabcolor = options;
}


void lcd7735_setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
 80025d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80025dc:	4680      	mov	r8, r0
	lcd7735_sendCmd(ST7735_CASET);		// Column addr set
	lcd7735_sendData(0x00);
	lcd7735_sendData(x0+colstart);     // XSTART 
 80025de:	4c18      	ldr	r4, [pc, #96]	; (8002640 <lcd7735_setAddrWindow+0x68>)
	//  tabcolor = options;
}


void lcd7735_setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	lcd7735_sendCmd(ST7735_CASET);		// Column addr set
 80025e0:	202a      	movs	r0, #42	; 0x2a

	//  tabcolor = options;
}


void lcd7735_setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
 80025e2:	460e      	mov	r6, r1
 80025e4:	4617      	mov	r7, r2
 80025e6:	461d      	mov	r5, r3
	lcd7735_sendCmd(ST7735_CASET);		// Column addr set
 80025e8:	f000 fa7e 	bl	8002ae8 <lcd7735_sendCmd>
	lcd7735_sendData(0x00);
 80025ec:	2000      	movs	r0, #0
 80025ee:	f000 fa83 	bl	8002af8 <lcd7735_sendData>
	lcd7735_sendData(x0+colstart);     // XSTART 
 80025f2:	6820      	ldr	r0, [r4, #0]
 80025f4:	4440      	add	r0, r8
 80025f6:	b2c0      	uxtb	r0, r0
 80025f8:	f000 fa7e 	bl	8002af8 <lcd7735_sendData>
	lcd7735_sendData(0x00);
 80025fc:	2000      	movs	r0, #0
 80025fe:	f000 fa7b 	bl	8002af8 <lcd7735_sendData>
	lcd7735_sendData(x1+colstart);     // XEND
 8002602:	6820      	ldr	r0, [r4, #0]

	lcd7735_sendCmd(ST7735_RASET); // Row addr set
	lcd7735_sendData(0x00);
	lcd7735_sendData(y0+rowstart);     // YSTART
 8002604:	4c0f      	ldr	r4, [pc, #60]	; (8002644 <lcd7735_setAddrWindow+0x6c>)
void lcd7735_setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	lcd7735_sendCmd(ST7735_CASET);		// Column addr set
	lcd7735_sendData(0x00);
	lcd7735_sendData(x0+colstart);     // XSTART 
	lcd7735_sendData(0x00);
	lcd7735_sendData(x1+colstart);     // XEND
 8002606:	4438      	add	r0, r7
 8002608:	b2c0      	uxtb	r0, r0
 800260a:	f000 fa75 	bl	8002af8 <lcd7735_sendData>

	lcd7735_sendCmd(ST7735_RASET); // Row addr set
 800260e:	202b      	movs	r0, #43	; 0x2b
 8002610:	f000 fa6a 	bl	8002ae8 <lcd7735_sendCmd>
	lcd7735_sendData(0x00);
 8002614:	2000      	movs	r0, #0
 8002616:	f000 fa6f 	bl	8002af8 <lcd7735_sendData>
	lcd7735_sendData(y0+rowstart);     // YSTART
 800261a:	6820      	ldr	r0, [r4, #0]
 800261c:	4430      	add	r0, r6
 800261e:	b2c0      	uxtb	r0, r0
 8002620:	f000 fa6a 	bl	8002af8 <lcd7735_sendData>
	lcd7735_sendData(0x00);
 8002624:	2000      	movs	r0, #0
 8002626:	f000 fa67 	bl	8002af8 <lcd7735_sendData>
	lcd7735_sendData(y1+rowstart);     // YEND
 800262a:	6820      	ldr	r0, [r4, #0]
 800262c:	4428      	add	r0, r5
 800262e:	b2c0      	uxtb	r0, r0
 8002630:	f000 fa62 	bl	8002af8 <lcd7735_sendData>

	lcd7735_sendCmd(ST7735_RAMWR); // write to RAM
 8002634:	202c      	movs	r0, #44	; 0x2c
}
 8002636:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	lcd7735_sendData(0x00);
	lcd7735_sendData(y0+rowstart);     // YSTART
	lcd7735_sendData(0x00);
	lcd7735_sendData(y1+rowstart);     // YEND

	lcd7735_sendCmd(ST7735_RAMWR); // write to RAM
 800263a:	f000 ba55 	b.w	8002ae8 <lcd7735_sendCmd>
 800263e:	bf00      	nop
 8002640:	20000040 	.word	0x20000040
 8002644:	20000038 	.word	0x20000038

08002648 <lcd7735_pushColor>:
}
void lcd7735_pushColor(uint16_t color) {
 8002648:	b510      	push	{r4, lr}
	LCD_DC1;  
 800264a:	4b06      	ldr	r3, [pc, #24]	; (8002664 <lcd7735_pushColor+0x1c>)
 800264c:	2201      	movs	r2, #1
	lcd7735_sendData(0x00);
	lcd7735_sendData(y1+rowstart);     // YEND

	lcd7735_sendCmd(ST7735_RAMWR); // write to RAM
}
void lcd7735_pushColor(uint16_t color) {
 800264e:	4604      	mov	r4, r0
	LCD_DC1;  
 8002650:	619a      	str	r2, [r3, #24]
	putpix(color);
 8002652:	0a00      	lsrs	r0, r0, #8
 8002654:	f000 fa3a 	bl	8002acc <lcd7735_senddata>
 8002658:	b2e0      	uxtb	r0, r4
}
 800265a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

	lcd7735_sendCmd(ST7735_RAMWR); // write to RAM
}
void lcd7735_pushColor(uint16_t color) {
	LCD_DC1;  
	putpix(color);
 800265e:	f000 ba35 	b.w	8002acc <lcd7735_senddata>
 8002662:	bf00      	nop
 8002664:	48000400 	.word	0x48000400

08002668 <lcd7735_fillRect>:
	lcd7735_setAddrWindow(x,y,x+1,y+1);
	lcd7735_pushColor(color);
}

// fill a rectangle
void lcd7735_fillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {	
 8002668:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800266c:	461c      	mov	r4, r3
	// rudimentary clipping (drawChar w/big text requires this)
	if((x >= _width) || (y >= _height)) return;
 800266e:	4b1d      	ldr	r3, [pc, #116]	; (80026e4 <lcd7735_fillRect+0x7c>)
	lcd7735_setAddrWindow(x,y,x+1,y+1);
	lcd7735_pushColor(color);
}

// fill a rectangle
void lcd7735_fillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {	
 8002670:	f8bd 6018 	ldrh.w	r6, [sp, #24]
 8002674:	4615      	mov	r5, r2
	// rudimentary clipping (drawChar w/big text requires this)
	if((x >= _width) || (y >= _height)) return;
 8002676:	881a      	ldrh	r2, [r3, #0]
 8002678:	4290      	cmp	r0, r2
 800267a:	da31      	bge.n	80026e0 <lcd7735_fillRect+0x78>
 800267c:	4b1a      	ldr	r3, [pc, #104]	; (80026e8 <lcd7735_fillRect+0x80>)
 800267e:	881b      	ldrh	r3, [r3, #0]
 8002680:	4299      	cmp	r1, r3
 8002682:	da2d      	bge.n	80026e0 <lcd7735_fillRect+0x78>
	if((x + w - 1) >= _width)  w = _width  - x;
 8002684:	182f      	adds	r7, r5, r0
 8002686:	42ba      	cmp	r2, r7
 8002688:	bfb8      	it	lt
 800268a:	1a15      	sublt	r5, r2, r0
	if((y + h - 1) >= _height) h = _height - y;
 800268c:	eb04 0201 	add.w	r2, r4, r1

// fill a rectangle
void lcd7735_fillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {	
	// rudimentary clipping (drawChar w/big text requires this)
	if((x >= _width) || (y >= _height)) return;
	if((x + w - 1) >= _width)  w = _width  - x;
 8002690:	bfb8      	it	lt
 8002692:	b22d      	sxthlt	r5, r5
	if((y + h - 1) >= _height) h = _height - y;
 8002694:	4293      	cmp	r3, r2
 8002696:	bfb8      	it	lt
 8002698:	1a5c      	sublt	r4, r3, r1

	lcd7735_setAddrWindow(x, y, x+w-1, y+h-1);
 800269a:	b2c0      	uxtb	r0, r0
 800269c:	b2c9      	uxtb	r1, r1
// fill a rectangle
void lcd7735_fillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {	
	// rudimentary clipping (drawChar w/big text requires this)
	if((x >= _width) || (y >= _height)) return;
	if((x + w - 1) >= _width)  w = _width  - x;
	if((y + h - 1) >= _height) h = _height - y;
 800269e:	bfb8      	it	lt
 80026a0:	b224      	sxthlt	r4, r4

	lcd7735_setAddrWindow(x, y, x+w-1, y+h-1);
 80026a2:	1e4b      	subs	r3, r1, #1
 80026a4:	1e42      	subs	r2, r0, #1
 80026a6:	4423      	add	r3, r4
 80026a8:	442a      	add	r2, r5
 80026aa:	b2db      	uxtb	r3, r3
 80026ac:	b2d2      	uxtb	r2, r2
 80026ae:	f7ff ff93 	bl	80025d8 <lcd7735_setAddrWindow>

	LCD_DC1;
 80026b2:	4b0e      	ldr	r3, [pc, #56]	; (80026ec <lcd7735_fillRect+0x84>)
 80026b4:	2201      	movs	r2, #1
 80026b6:	619a      	str	r2, [r3, #24]
	for(y=h; y>0; y--) {
		for(x=w; x>0; x--) {
			putpix(color);
 80026b8:	ea4f 2816 	mov.w	r8, r6, lsr #8
 80026bc:	b2f7      	uxtb	r7, r6
	if((y + h - 1) >= _height) h = _height - y;

	lcd7735_setAddrWindow(x, y, x+w-1, y+h-1);

	LCD_DC1;
	for(y=h; y>0; y--) {
 80026be:	2c00      	cmp	r4, #0
 80026c0:	dd0e      	ble.n	80026e0 <lcd7735_fillRect+0x78>
 80026c2:	462e      	mov	r6, r5
		for(x=w; x>0; x--) {
 80026c4:	2e00      	cmp	r6, #0
 80026c6:	dd08      	ble.n	80026da <lcd7735_fillRect+0x72>
			putpix(color);
 80026c8:	4640      	mov	r0, r8
 80026ca:	f000 f9ff 	bl	8002acc <lcd7735_senddata>
 80026ce:	3e01      	subs	r6, #1
 80026d0:	4638      	mov	r0, r7
 80026d2:	f000 f9fb 	bl	8002acc <lcd7735_senddata>
 80026d6:	b236      	sxth	r6, r6
 80026d8:	e7f4      	b.n	80026c4 <lcd7735_fillRect+0x5c>
 80026da:	3c01      	subs	r4, #1
 80026dc:	b224      	sxth	r4, r4
 80026de:	e7ee      	b.n	80026be <lcd7735_fillRect+0x56>
 80026e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80026e4:	20000002 	.word	0x20000002
 80026e8:	20000000 	.word	0x20000000
 80026ec:	48000400 	.word	0x48000400

080026f0 <lcd7735_setFont>:
			}
	}
}

void lcd7735_setFont(uint8_t* font) {
	cfont.font=font;
 80026f0:	4b05      	ldr	r3, [pc, #20]	; (8002708 <lcd7735_setFont+0x18>)
	cfont.x_size=font[0];
 80026f2:	7802      	ldrb	r2, [r0, #0]
 80026f4:	711a      	strb	r2, [r3, #4]
	cfont.y_size=font[1];
 80026f6:	7842      	ldrb	r2, [r0, #1]
 80026f8:	715a      	strb	r2, [r3, #5]
	cfont.offset=font[2];
 80026fa:	7882      	ldrb	r2, [r0, #2]
 80026fc:	719a      	strb	r2, [r3, #6]
	cfont.numchars=font[3];
 80026fe:	78c2      	ldrb	r2, [r0, #3]
			}
	}
}

void lcd7735_setFont(uint8_t* font) {
	cfont.font=font;
 8002700:	6018      	str	r0, [r3, #0]
	cfont.x_size=font[0];
	cfont.y_size=font[1];
	cfont.offset=font[2];
	cfont.numchars=font[3];
 8002702:	811a      	strh	r2, [r3, #8]
 8002704:	4770      	bx	lr
 8002706:	bf00      	nop
 8002708:	20000028 	.word	0x20000028

0800270c <printChar>:
}

void printChar(uint8_t c, int x, int y) {
 800270c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t i,ch,fz;
	uint16_t j;
	uint16_t temp; 
	int zz;

	if( cfont.x_size < 8 ) 
 8002710:	4d4f      	ldr	r5, [pc, #316]	; (8002850 <printChar+0x144>)
		fz = cfont.x_size;
	else
		fz = cfont.x_size/8;
	if (!_transparent) {
 8002712:	4b50      	ldr	r3, [pc, #320]	; (8002854 <printChar+0x148>)
	uint8_t i,ch,fz;
	uint16_t j;
	uint16_t temp; 
	int zz;

	if( cfont.x_size < 8 ) 
 8002714:	f895 e004 	ldrb.w	lr, [r5, #4]
		fz = cfont.x_size;
	else
		fz = cfont.x_size/8;
	if (!_transparent) {
 8002718:	f893 8000 	ldrb.w	r8, [r3]
	uint8_t i,ch,fz;
	uint16_t j;
	uint16_t temp; 
	int zz;

	if( cfont.x_size < 8 ) 
 800271c:	f1be 0f07 	cmp.w	lr, #7
	cfont.y_size=font[1];
	cfont.offset=font[2];
	cfont.numchars=font[3];
}

void printChar(uint8_t c, int x, int y) {
 8002720:	b087      	sub	sp, #28
 8002722:	4604      	mov	r4, r0
 8002724:	460f      	mov	r7, r1
	int zz;

	if( cfont.x_size < 8 ) 
		fz = cfont.x_size;
	else
		fz = cfont.x_size/8;
 8002726:	bf8c      	ite	hi
 8002728:	ea4f 06de 	movhi.w	r6, lr, lsr #3
 800272c:	4676      	movls	r6, lr
	if (!_transparent) {
 800272e:	f1b8 0f00 	cmp.w	r8, #0
 8002732:	d137      	bne.n	80027a4 <printChar+0x98>
		lcd7735_setAddrWindow(x,y,x+cfont.x_size-1,y+cfont.y_size-1);
 8002734:	796b      	ldrb	r3, [r5, #5]

		temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
		for(j=0;j<((fz)*cfont.y_size);j++) {
 8002736:	4f46      	ldr	r7, [pc, #280]	; (8002850 <printChar+0x144>)
	if( cfont.x_size < 8 ) 
		fz = cfont.x_size;
	else
		fz = cfont.x_size/8;
	if (!_transparent) {
		lcd7735_setAddrWindow(x,y,x+cfont.x_size-1,y+cfont.y_size-1);
 8002738:	b2c8      	uxtb	r0, r1
 800273a:	f10e 3eff 	add.w	lr, lr, #4294967295
 800273e:	b2d1      	uxtb	r1, r2
 8002740:	3b01      	subs	r3, #1
 8002742:	eb00 020e 	add.w	r2, r0, lr
 8002746:	440b      	add	r3, r1
 8002748:	b2db      	uxtb	r3, r3
 800274a:	b2d2      	uxtb	r2, r2
 800274c:	f7ff ff44 	bl	80025d8 <lcd7735_setAddrWindow>

		temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
 8002750:	79a8      	ldrb	r0, [r5, #6]
 8002752:	1a20      	subs	r0, r4, r0
 8002754:	796c      	ldrb	r4, [r5, #5]
 8002756:	fb14 f400 	smulbb	r4, r4, r0
 800275a:	fb14 f406 	smulbb	r4, r4, r6
 800275e:	3404      	adds	r4, #4
 8002760:	b2a4      	uxth	r4, r4
		for(j=0;j<((fz)*cfont.y_size);j++) {
 8002762:	796b      	ldrb	r3, [r5, #5]
 8002764:	fa1f f288 	uxth.w	r2, r8
 8002768:	fb16 f303 	smulbb	r3, r6, r3
 800276c:	eb04 0108 	add.w	r1, r4, r8
 8002770:	429a      	cmp	r2, r3
 8002772:	b289      	uxth	r1, r1
 8002774:	da68      	bge.n	8002848 <printChar+0x13c>
			ch = cfont.font[temp];
 8002776:	683b      	ldr	r3, [r7, #0]
			for(i=0;i<8;i++) {   
				if((ch&(1<<(7-i)))!=0)   
				{
					lcd7735_pushColor(_fg);
 8002778:	f8df b0e0 	ldr.w	fp, [pc, #224]	; 800285c <printChar+0x150>
	if (!_transparent) {
		lcd7735_setAddrWindow(x,y,x+cfont.x_size-1,y+cfont.y_size-1);

		temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
		for(j=0;j<((fz)*cfont.y_size);j++) {
			ch = cfont.font[temp];
 800277c:	f813 a001 	ldrb.w	sl, [r3, r1]
 8002780:	f04f 0907 	mov.w	r9, #7
			for(i=0;i<8;i++) {   
				if((ch&(1<<(7-i)))!=0)   
 8002784:	fa4a f209 	asr.w	r2, sl, r9
 8002788:	07d2      	lsls	r2, r2, #31
				{
					lcd7735_pushColor(_fg);
				} 
				else
				{
					lcd7735_pushColor(_bg);
 800278a:	bf56      	itet	pl
 800278c:	4b32      	ldrpl	r3, [pc, #200]	; (8002858 <printChar+0x14c>)
		for(j=0;j<((fz)*cfont.y_size);j++) {
			ch = cfont.font[temp];
			for(i=0;i<8;i++) {   
				if((ch&(1<<(7-i)))!=0)   
				{
					lcd7735_pushColor(_fg);
 800278e:	f8bb 0000 	ldrhmi.w	r0, [fp]
				} 
				else
				{
					lcd7735_pushColor(_bg);
 8002792:	8818      	ldrhpl	r0, [r3, #0]
 8002794:	f7ff ff58 	bl	8002648 <lcd7735_pushColor>
		lcd7735_setAddrWindow(x,y,x+cfont.x_size-1,y+cfont.y_size-1);

		temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
		for(j=0;j<((fz)*cfont.y_size);j++) {
			ch = cfont.font[temp];
			for(i=0;i<8;i++) {   
 8002798:	f119 39ff 	adds.w	r9, r9, #4294967295
 800279c:	d2f2      	bcs.n	8002784 <printChar+0x78>
 800279e:	f108 0801 	add.w	r8, r8, #1
 80027a2:	e7de      	b.n	8002762 <printChar+0x56>
				}   
			}
			temp++;
		}
	} else {
		temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
 80027a4:	79a8      	ldrb	r0, [r5, #6]
 80027a6:	b2b3      	uxth	r3, r6
 80027a8:	1a20      	subs	r0, r4, r0
 80027aa:	9301      	str	r3, [sp, #4]
 80027ac:	796c      	ldrb	r4, [r5, #5]
 80027ae:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 80027b2:	fb14 f400 	smulbb	r4, r4, r0
 80027b6:	fb14 f403 	smulbb	r4, r4, r3
			for (zz=0; zz<(fz); zz++)
			{
				ch = cfont.font[temp+zz]; 
				for(i=0;i<8;i++)
				{   
					lcd7735_setAddrWindow(x+i+(zz*8),y+j,x+i+(zz*8)+1,y+j+1);
 80027ba:	b2d3      	uxtb	r3, r2
				}   
			}
			temp++;
		}
	} else {
		temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
 80027bc:	3404      	adds	r4, #4
			for (zz=0; zz<(fz); zz++)
			{
				ch = cfont.font[temp+zz]; 
				for(i=0;i<8;i++)
				{   
					lcd7735_setAddrWindow(x+i+(zz*8),y+j,x+i+(zz*8)+1,y+j+1);
 80027be:	9302      	str	r3, [sp, #8]
 80027c0:	3301      	adds	r3, #1
				}   
			}
			temp++;
		}
	} else {
		temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
 80027c2:	b2a4      	uxth	r4, r4
		for(j=0;j<cfont.y_size;j++) 
 80027c4:	f04f 0900 	mov.w	r9, #0
			for (zz=0; zz<(fz); zz++)
			{
				ch = cfont.font[temp+zz]; 
				for(i=0;i<8;i++)
				{   
					lcd7735_setAddrWindow(x+i+(zz*8),y+j,x+i+(zz*8)+1,y+j+1);
 80027c8:	9305      	str	r3, [sp, #20]
			}
			temp++;
		}
	} else {
		temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
		for(j=0;j<cfont.y_size;j++) 
 80027ca:	4b21      	ldr	r3, [pc, #132]	; (8002850 <printChar+0x144>)
 80027cc:	795a      	ldrb	r2, [r3, #5]
 80027ce:	fa1f f389 	uxth.w	r3, r9
 80027d2:	429a      	cmp	r2, r3
 80027d4:	d938      	bls.n	8002848 <printChar+0x13c>
 80027d6:	2500      	movs	r5, #0
		{
			for (zz=0; zz<(fz); zz++)
 80027d8:	42b5      	cmp	r5, r6
 80027da:	da2f      	bge.n	800283c <printChar+0x130>
			{
				ch = cfont.font[temp+zz]; 
 80027dc:	4b1c      	ldr	r3, [pc, #112]	; (8002850 <printChar+0x144>)
 80027de:	681b      	ldr	r3, [r3, #0]
 80027e0:	4423      	add	r3, r4
 80027e2:	fa5f fb89 	uxtb.w	fp, r9
 80027e6:	5d5b      	ldrb	r3, [r3, r5]
 80027e8:	9303      	str	r3, [sp, #12]
				for(i=0;i<8;i++)
				{   
					lcd7735_setAddrWindow(x+i+(zz*8),y+j,x+i+(zz*8)+1,y+j+1);
 80027ea:	9b05      	ldr	r3, [sp, #20]
 80027ec:	445b      	add	r3, fp
 80027ee:	eb07 0ac5 	add.w	sl, r7, r5, lsl #3
 80027f2:	b2db      	uxtb	r3, r3
 80027f4:	fa5f fa8a 	uxtb.w	sl, sl
 80027f8:	f04f 0807 	mov.w	r8, #7
 80027fc:	9304      	str	r3, [sp, #16]
 80027fe:	9b02      	ldr	r3, [sp, #8]
 8002800:	fa5f f088 	uxtb.w	r0, r8
 8002804:	eb03 010b 	add.w	r1, r3, fp
 8002808:	f10a 0208 	add.w	r2, sl, #8
 800280c:	f10a 0307 	add.w	r3, sl, #7
 8002810:	1a12      	subs	r2, r2, r0
 8002812:	1a18      	subs	r0, r3, r0
 8002814:	b2d2      	uxtb	r2, r2
 8002816:	9b04      	ldr	r3, [sp, #16]
 8002818:	b2c9      	uxtb	r1, r1
 800281a:	b2c0      	uxtb	r0, r0
 800281c:	f7ff fedc 	bl	80025d8 <lcd7735_setAddrWindow>

					if((ch&(1<<(7-i)))!=0)   
 8002820:	9b03      	ldr	r3, [sp, #12]
 8002822:	fa43 f308 	asr.w	r3, r3, r8
 8002826:	07db      	lsls	r3, r3, #31
 8002828:	d503      	bpl.n	8002832 <printChar+0x126>
					{
						lcd7735_pushColor(_fg);
 800282a:	4b0c      	ldr	r3, [pc, #48]	; (800285c <printChar+0x150>)
 800282c:	8818      	ldrh	r0, [r3, #0]
 800282e:	f7ff ff0b 	bl	8002648 <lcd7735_pushColor>
		for(j=0;j<cfont.y_size;j++) 
		{
			for (zz=0; zz<(fz); zz++)
			{
				ch = cfont.font[temp+zz]; 
				for(i=0;i<8;i++)
 8002832:	f118 38ff 	adds.w	r8, r8, #4294967295
 8002836:	d2e2      	bcs.n	80027fe <printChar+0xf2>
		}
	} else {
		temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
		for(j=0;j<cfont.y_size;j++) 
		{
			for (zz=0; zz<(fz); zz++)
 8002838:	3501      	adds	r5, #1
 800283a:	e7cd      	b.n	80027d8 <printChar+0xcc>
					{
						lcd7735_pushColor(_fg);
					} 
				}
			}
			temp+=(fz);
 800283c:	9b01      	ldr	r3, [sp, #4]
 800283e:	441c      	add	r4, r3
 8002840:	b2a4      	uxth	r4, r4
 8002842:	f109 0901 	add.w	r9, r9, #1
 8002846:	e7c0      	b.n	80027ca <printChar+0xbe>
		}
	}
}
 8002848:	b007      	add	sp, #28
 800284a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800284e:	bf00      	nop
 8002850:	20000028 	.word	0x20000028
 8002854:	2000003c 	.word	0x2000003c
 8002858:	20000034 	.word	0x20000034
 800285c:	20000004 	.word	0x20000004

08002860 <rotateChar>:

void rotateChar(uint8_t c, int x, int y, int pos, int deg) {
 8002860:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002864:	ed2d 8b02 	vpush	{d8}
 8002868:	b091      	sub	sp, #68	; 0x44
 800286a:	4604      	mov	r4, r0
	uint8_t i,j,ch,fz;
	uint16_t temp; 
	int newx,newy;
	double radian = deg*0.0175;
 800286c:	981c      	ldr	r0, [sp, #112]	; 0x70
			temp+=(fz);
		}
	}
}

void rotateChar(uint8_t c, int x, int y, int pos, int deg) {
 800286e:	920e      	str	r2, [sp, #56]	; 0x38
 8002870:	930f      	str	r3, [sp, #60]	; 0x3c
 8002872:	910d      	str	r1, [sp, #52]	; 0x34
	uint8_t i,j,ch,fz;
	uint16_t temp; 
	int newx,newy;
	double radian = deg*0.0175;
 8002874:	f7fd fe06 	bl	8000484 <__aeabi_i2d>
 8002878:	a35f      	add	r3, pc, #380	; (adr r3, 80029f8 <rotateChar+0x198>)
 800287a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800287e:	f7fd fe67 	bl	8000550 <__aeabi_dmul>
	int zz;

	if( cfont.x_size < 8 ) 
 8002882:	4b59      	ldr	r3, [pc, #356]	; (80029e8 <rotateChar+0x188>)
		fz = cfont.x_size;
	else
		fz = cfont.x_size/8;	
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
	for(j=0;j<cfont.y_size;j++) {
 8002884:	4f58      	ldr	r7, [pc, #352]	; (80029e8 <rotateChar+0x188>)
	uint16_t temp; 
	int newx,newy;
	double radian = deg*0.0175;
	int zz;

	if( cfont.x_size < 8 ) 
 8002886:	791d      	ldrb	r5, [r3, #4]
 8002888:	2d07      	cmp	r5, #7
		fz = cfont.x_size;
	else
		fz = cfont.x_size/8;	
 800288a:	bf88      	it	hi
 800288c:	08ed      	lsrhi	r5, r5, #3
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
 800288e:	b2aa      	uxth	r2, r5
 8002890:	9204      	str	r2, [sp, #16]
 8002892:	799a      	ldrb	r2, [r3, #6]
 8002894:	795b      	ldrb	r3, [r3, #5]
 8002896:	1aa4      	subs	r4, r4, r2
 8002898:	fb13 f404 	smulbb	r4, r3, r4
 800289c:	f8bd 3010 	ldrh.w	r3, [sp, #16]
 80028a0:	fb14 f403 	smulbb	r4, r4, r3
 80028a4:	3404      	adds	r4, #4

void rotateChar(uint8_t c, int x, int y, int pos, int deg) {
	uint8_t i,j,ch,fz;
	uint16_t temp; 
	int newx,newy;
	double radian = deg*0.0175;
 80028a6:	ec41 0b18 	vmov	d8, r0, r1

	if( cfont.x_size < 8 ) 
		fz = cfont.x_size;
	else
		fz = cfont.x_size/8;	
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
 80028aa:	fa1f fb84 	uxth.w	fp, r4
	for(j=0;j<cfont.y_size;j++) {
 80028ae:	f04f 0a00 	mov.w	sl, #0
 80028b2:	797a      	ldrb	r2, [r7, #5]
 80028b4:	fa5f f38a 	uxtb.w	r3, sl
 80028b8:	429a      	cmp	r2, r3
 80028ba:	f240 808e 	bls.w	80029da <rotateChar+0x17a>
 80028be:	2400      	movs	r4, #0
		for (zz=0; zz<(fz); zz++) {
 80028c0:	42ac      	cmp	r4, r5
 80028c2:	f280 8083 	bge.w	80029cc <rotateChar+0x16c>
			ch = cfont.font[temp+zz]; 
			for(i=0;i<8;i++) {   
				newx=x+(((i+(zz*8)+(pos*cfont.x_size))*cos(radian))-((j)*sin(radian)));
 80028c6:	eeb0 0a48 	vmov.f32	s0, s16
 80028ca:	eef0 0a68 	vmov.f32	s1, s17
	else
		fz = cfont.x_size/8;	
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
	for(j=0;j<cfont.y_size;j++) {
		for (zz=0; zz<(fz); zz++) {
			ch = cfont.font[temp+zz]; 
 80028ce:	683b      	ldr	r3, [r7, #0]
 80028d0:	445b      	add	r3, fp
			for(i=0;i<8;i++) {   
				newx=x+(((i+(zz*8)+(pos*cfont.x_size))*cos(radian))-((j)*sin(radian)));
				newy=y+(((j)*cos(radian))+((i+(zz*8)+(pos*cfont.x_size))*sin(radian)));
 80028d2:	2600      	movs	r6, #0
	else
		fz = cfont.x_size/8;	
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
	for(j=0;j<cfont.y_size;j++) {
		for (zz=0; zz<(fz); zz++) {
			ch = cfont.font[temp+zz]; 
 80028d4:	5d1b      	ldrb	r3, [r3, r4]
 80028d6:	9305      	str	r3, [sp, #20]
			for(i=0;i<8;i++) {   
				newx=x+(((i+(zz*8)+(pos*cfont.x_size))*cos(radian))-((j)*sin(radian)));
 80028d8:	f000 fb16 	bl	8002f08 <cos>
 80028dc:	fa5f f08a 	uxtb.w	r0, sl
 80028e0:	ed8d 0b00 	vstr	d0, [sp]
 80028e4:	f7fd fdce 	bl	8000484 <__aeabi_i2d>
 80028e8:	eeb0 0a48 	vmov.f32	s0, s16
 80028ec:	eef0 0a68 	vmov.f32	s1, s17
 80028f0:	4680      	mov	r8, r0
 80028f2:	4689      	mov	r9, r1
 80028f4:	f000 fb4c 	bl	8002f90 <sin>
 80028f8:	4640      	mov	r0, r8
 80028fa:	ec53 2b10 	vmov	r2, r3, d0
 80028fe:	4649      	mov	r1, r9
 8002900:	ed8d 0b02 	vstr	d0, [sp, #8]
 8002904:	f7fd fe24 	bl	8000550 <__aeabi_dmul>
				newy=y+(((j)*cos(radian))+((i+(zz*8)+(pos*cfont.x_size))*sin(radian)));
 8002908:	464b      	mov	r3, r9
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
	for(j=0;j<cfont.y_size;j++) {
		for (zz=0; zz<(fz); zz++) {
			ch = cfont.font[temp+zz]; 
			for(i=0;i<8;i++) {   
				newx=x+(((i+(zz*8)+(pos*cfont.x_size))*cos(radian))-((j)*sin(radian)));
 800290a:	e9cd 0108 	strd	r0, r1, [sp, #32]
				newy=y+(((j)*cos(radian))+((i+(zz*8)+(pos*cfont.x_size))*sin(radian)));
 800290e:	4642      	mov	r2, r8
 8002910:	e9dd 0100 	ldrd	r0, r1, [sp]
 8002914:	f7fd fe1c 	bl	8000550 <__aeabi_dmul>
 8002918:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
 800291c:	00e3      	lsls	r3, r4, #3
 800291e:	930c      	str	r3, [sp, #48]	; 0x30
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
	for(j=0;j<cfont.y_size;j++) {
		for (zz=0; zz<(fz); zz++) {
			ch = cfont.font[temp+zz]; 
			for(i=0;i<8;i++) {   
				newx=x+(((i+(zz*8)+(pos*cfont.x_size))*cos(radian))-((j)*sin(radian)));
 8002920:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8002922:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8002924:	7938      	ldrb	r0, [r7, #4]
 8002926:	18f3      	adds	r3, r6, r3
 8002928:	fb02 3000 	mla	r0, r2, r0, r3
 800292c:	f7fd fdaa 	bl	8000484 <__aeabi_i2d>
				newy=y+(((j)*cos(radian))+((i+(zz*8)+(pos*cfont.x_size))*sin(radian)));

				lcd7735_setAddrWindow(newx,newy,newx+1,newy+1);
 8002930:	e9dd 2300 	ldrd	r2, r3, [sp]
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
	for(j=0;j<cfont.y_size;j++) {
		for (zz=0; zz<(fz); zz++) {
			ch = cfont.font[temp+zz]; 
			for(i=0;i<8;i++) {   
				newx=x+(((i+(zz*8)+(pos*cfont.x_size))*cos(radian))-((j)*sin(radian)));
 8002934:	e9cd 0106 	strd	r0, r1, [sp, #24]
				newy=y+(((j)*cos(radian))+((i+(zz*8)+(pos*cfont.x_size))*sin(radian)));

				lcd7735_setAddrWindow(newx,newy,newx+1,newy+1);
 8002938:	f7fd fe0a 	bl	8000550 <__aeabi_dmul>
 800293c:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8002940:	f7fd fc52 	bl	80001e8 <__aeabi_dsub>
 8002944:	4680      	mov	r8, r0
 8002946:	980d      	ldr	r0, [sp, #52]	; 0x34
 8002948:	4689      	mov	r9, r1
 800294a:	f7fd fd9b 	bl	8000484 <__aeabi_i2d>
 800294e:	4602      	mov	r2, r0
 8002950:	460b      	mov	r3, r1
 8002952:	4640      	mov	r0, r8
 8002954:	4649      	mov	r1, r9
 8002956:	f7fd fc49 	bl	80001ec <__adddf3>
 800295a:	f7fe f893 	bl	8000a84 <__aeabi_d2iz>
 800295e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8002962:	fa5f f880 	uxtb.w	r8, r0
 8002966:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 800296a:	f7fd fdf1 	bl	8000550 <__aeabi_dmul>
 800296e:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 8002972:	f7fd fc3b 	bl	80001ec <__adddf3>
 8002976:	e9cd 0106 	strd	r0, r1, [sp, #24]
 800297a:	980e      	ldr	r0, [sp, #56]	; 0x38
 800297c:	f7fd fd82 	bl	8000484 <__aeabi_i2d>
 8002980:	4602      	mov	r2, r0
 8002982:	460b      	mov	r3, r1
 8002984:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8002988:	f7fd fc30 	bl	80001ec <__adddf3>
 800298c:	f7fe f87a 	bl	8000a84 <__aeabi_d2iz>
 8002990:	b2c1      	uxtb	r1, r0
 8002992:	1c4b      	adds	r3, r1, #1
 8002994:	f108 0201 	add.w	r2, r8, #1
 8002998:	b2db      	uxtb	r3, r3
 800299a:	b2d2      	uxtb	r2, r2
 800299c:	4640      	mov	r0, r8
 800299e:	f7ff fe1b 	bl	80025d8 <lcd7735_setAddrWindow>

				if((ch&(1<<(7-i)))!=0) {
 80029a2:	9a05      	ldr	r2, [sp, #20]
 80029a4:	f1c6 0307 	rsb	r3, r6, #7
 80029a8:	fa42 f303 	asr.w	r3, r2, r3
 80029ac:	07db      	lsls	r3, r3, #31
 80029ae:	d501      	bpl.n	80029b4 <rotateChar+0x154>
					lcd7735_pushColor(_fg);
 80029b0:	4b0e      	ldr	r3, [pc, #56]	; (80029ec <rotateChar+0x18c>)
 80029b2:	e003      	b.n	80029bc <rotateChar+0x15c>
				} else  {
					if (!_transparent)
 80029b4:	4b0e      	ldr	r3, [pc, #56]	; (80029f0 <rotateChar+0x190>)
 80029b6:	781b      	ldrb	r3, [r3, #0]
 80029b8:	b91b      	cbnz	r3, 80029c2 <rotateChar+0x162>
						lcd7735_pushColor(_bg);
 80029ba:	4b0e      	ldr	r3, [pc, #56]	; (80029f4 <rotateChar+0x194>)
 80029bc:	8818      	ldrh	r0, [r3, #0]
 80029be:	f7ff fe43 	bl	8002648 <lcd7735_pushColor>
 80029c2:	3601      	adds	r6, #1
		fz = cfont.x_size/8;	
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
	for(j=0;j<cfont.y_size;j++) {
		for (zz=0; zz<(fz); zz++) {
			ch = cfont.font[temp+zz]; 
			for(i=0;i<8;i++) {   
 80029c4:	2e08      	cmp	r6, #8
 80029c6:	d1ab      	bne.n	8002920 <rotateChar+0xc0>
		fz = cfont.x_size;
	else
		fz = cfont.x_size/8;	
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
	for(j=0;j<cfont.y_size;j++) {
		for (zz=0; zz<(fz); zz++) {
 80029c8:	3401      	adds	r4, #1
 80029ca:	e779      	b.n	80028c0 <rotateChar+0x60>
					if (!_transparent)
						lcd7735_pushColor(_bg);
				}   
			}
		}
		temp+=(fz);
 80029cc:	9b04      	ldr	r3, [sp, #16]
 80029ce:	445b      	add	r3, fp
 80029d0:	fa1f fb83 	uxth.w	fp, r3
 80029d4:	f10a 0a01 	add.w	sl, sl, #1
 80029d8:	e76b      	b.n	80028b2 <rotateChar+0x52>
	}
}
 80029da:	b011      	add	sp, #68	; 0x44
 80029dc:	ecbd 8b02 	vpop	{d8}
 80029e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80029e4:	f3af 8000 	nop.w
 80029e8:	20000028 	.word	0x20000028
 80029ec:	20000004 	.word	0x20000004
 80029f0:	2000003c 	.word	0x2000003c
 80029f4:	20000034 	.word	0x20000034
 80029f8:	1eb851ec 	.word	0x1eb851ec
 80029fc:	3f91eb85 	.word	0x3f91eb85

08002a00 <lcd7735_print>:

void lcd7735_print(char *st, int x, int y, int deg) {
 8002a00:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 8002a04:	460c      	mov	r4, r1
 8002a06:	4690      	mov	r8, r2
 8002a08:	4606      	mov	r6, r0
 8002a0a:	4699      	mov	r9, r3
	int stl, i;

	stl = strlen(st);
 8002a0c:	f7fd fbe0 	bl	80001d0 <strlen>

	if (x==RIGHT)
 8002a10:	1ca2      	adds	r2, r4, #2
}

void lcd7735_print(char *st, int x, int y, int deg) {
	int stl, i;

	stl = strlen(st);
 8002a12:	4607      	mov	r7, r0

	if (x==RIGHT)
 8002a14:	d106      	bne.n	8002a24 <lcd7735_print+0x24>
		x=(_width+1)-(stl*cfont.x_size);
 8002a16:	4b1a      	ldr	r3, [pc, #104]	; (8002a80 <lcd7735_print+0x80>)
 8002a18:	4a1a      	ldr	r2, [pc, #104]	; (8002a84 <lcd7735_print+0x84>)
 8002a1a:	881c      	ldrh	r4, [r3, #0]
 8002a1c:	1c63      	adds	r3, r4, #1
 8002a1e:	7914      	ldrb	r4, [r2, #4]
 8002a20:	fb00 3414 	mls	r4, r0, r4, r3
	if (x==CENTER)
 8002a24:	1c63      	adds	r3, r4, #1
 8002a26:	d109      	bne.n	8002a3c <lcd7735_print+0x3c>
		x=((_height+1)-(stl*cfont.x_size))/2;
 8002a28:	4b17      	ldr	r3, [pc, #92]	; (8002a88 <lcd7735_print+0x88>)
 8002a2a:	881c      	ldrh	r4, [r3, #0]
 8002a2c:	4b15      	ldr	r3, [pc, #84]	; (8002a84 <lcd7735_print+0x84>)
 8002a2e:	791b      	ldrb	r3, [r3, #4]
 8002a30:	3401      	adds	r4, #1
 8002a32:	fb07 4313 	mls	r3, r7, r3, r4
 8002a36:	2402      	movs	r4, #2
 8002a38:	fb93 f4f4 	sdiv	r4, r3, r4

	for (i=0; i<stl; i++)
		if (deg==0)
			printChar(*st++, x + (i*(cfont.x_size)), y);
 8002a3c:	f8df a044 	ldr.w	sl, [pc, #68]	; 8002a84 <lcd7735_print+0x84>
 8002a40:	3601      	adds	r6, #1
	if (x==RIGHT)
		x=(_width+1)-(stl*cfont.x_size);
	if (x==CENTER)
		x=((_height+1)-(stl*cfont.x_size))/2;

	for (i=0; i<stl; i++)
 8002a42:	2500      	movs	r5, #0
 8002a44:	42bd      	cmp	r5, r7
 8002a46:	da18      	bge.n	8002a7a <lcd7735_print+0x7a>
		if (deg==0)
 8002a48:	f1b9 0f00 	cmp.w	r9, #0
 8002a4c:	d109      	bne.n	8002a62 <lcd7735_print+0x62>
			printChar(*st++, x + (i*(cfont.x_size)), y);
 8002a4e:	f89a 1004 	ldrb.w	r1, [sl, #4]
 8002a52:	f816 0c01 	ldrb.w	r0, [r6, #-1]
 8002a56:	4642      	mov	r2, r8
 8002a58:	fb05 4101 	mla	r1, r5, r1, r4
 8002a5c:	f7ff fe56 	bl	800270c <printChar>
 8002a60:	e008      	b.n	8002a74 <lcd7735_print+0x74>
		else
			rotateChar(*st++, x, y, i, deg);
 8002a62:	f816 0c01 	ldrb.w	r0, [r6, #-1]
 8002a66:	f8cd 9000 	str.w	r9, [sp]
 8002a6a:	462b      	mov	r3, r5
 8002a6c:	4642      	mov	r2, r8
 8002a6e:	4621      	mov	r1, r4
 8002a70:	f7ff fef6 	bl	8002860 <rotateChar>
	if (x==RIGHT)
		x=(_width+1)-(stl*cfont.x_size);
	if (x==CENTER)
		x=((_height+1)-(stl*cfont.x_size))/2;

	for (i=0; i<stl; i++)
 8002a74:	3501      	adds	r5, #1
 8002a76:	3601      	adds	r6, #1
 8002a78:	e7e4      	b.n	8002a44 <lcd7735_print+0x44>
		if (deg==0)
			printChar(*st++, x + (i*(cfont.x_size)), y);
		else
			rotateChar(*st++, x, y, i, deg);
}
 8002a7a:	b002      	add	sp, #8
 8002a7c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002a80:	20000002 	.word	0x20000002
 8002a84:	20000028 	.word	0x20000028
 8002a88:	20000000 	.word	0x20000000

08002a8c <lcd7735_fillScreen>:
*********************************************************************
*********************** Service functions ***************************
*********************************************************************
*********************************************************************/

void lcd7735_fillScreen(uint16_t color) {
 8002a8c:	b507      	push	{r0, r1, r2, lr}
	lcd7735_fillRect(0, 0,  _width, _height, color);
 8002a8e:	4b07      	ldr	r3, [pc, #28]	; (8002aac <lcd7735_fillScreen+0x20>)
 8002a90:	4a07      	ldr	r2, [pc, #28]	; (8002ab0 <lcd7735_fillScreen+0x24>)
 8002a92:	f9b3 3000 	ldrsh.w	r3, [r3]
 8002a96:	f9b2 2000 	ldrsh.w	r2, [r2]
 8002a9a:	9000      	str	r0, [sp, #0]
 8002a9c:	2100      	movs	r1, #0
 8002a9e:	4608      	mov	r0, r1
 8002aa0:	f7ff fde2 	bl	8002668 <lcd7735_fillRect>
}
 8002aa4:	b003      	add	sp, #12
 8002aa6:	f85d fb04 	ldr.w	pc, [sp], #4
 8002aaa:	bf00      	nop
 8002aac:	20000000 	.word	0x20000000
 8002ab0:	20000002 	.word	0x20000002

08002ab4 <lcd7735_setForeground>:
uint8_t lcd7735_getHeight() {
	return(_height);
}

void lcd7735_setForeground(uint16_t s) {
	_fg = s;
 8002ab4:	4b01      	ldr	r3, [pc, #4]	; (8002abc <lcd7735_setForeground+0x8>)
 8002ab6:	8018      	strh	r0, [r3, #0]
 8002ab8:	4770      	bx	lr
 8002aba:	bf00      	nop
 8002abc:	20000004 	.word	0x20000004

08002ac0 <lcd7735_setTransparent>:
void lcd7735_setBackground(uint16_t s) {
	_bg = s;
}

void lcd7735_setTransparent(uint8_t s) {
	_transparent = s;
 8002ac0:	4b01      	ldr	r3, [pc, #4]	; (8002ac8 <lcd7735_setTransparent+0x8>)
 8002ac2:	7018      	strb	r0, [r3, #0]
 8002ac4:	4770      	bx	lr
 8002ac6:	bf00      	nop
 8002ac8:	2000003c 	.word	0x2000003c

08002acc <lcd7735_senddata>:
}

#endif

// Send byte via SPI to controller
void lcd7735_senddata(const uint8_t data) {
 8002acc:	b507      	push	{r0, r1, r2, lr}
	uint8_t tcmd[1];
	tcmd[0] = data;
 8002ace:	a902      	add	r1, sp, #8
	HAL_SPI_Transmit(&hspi1,tcmd,1,1);
 8002ad0:	2301      	movs	r3, #1
#endif

// Send byte via SPI to controller
void lcd7735_senddata(const uint8_t data) {
	uint8_t tcmd[1];
	tcmd[0] = data;
 8002ad2:	f801 0d04 	strb.w	r0, [r1, #-4]!
	HAL_SPI_Transmit(&hspi1,tcmd,1,1);
 8002ad6:	461a      	mov	r2, r3
 8002ad8:	4802      	ldr	r0, [pc, #8]	; (8002ae4 <lcd7735_senddata+0x18>)
 8002ada:	f7ff fa3e 	bl	8001f5a <HAL_SPI_Transmit>
//    while(SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET);
//    SPI_SendData(SPI2, data);
}
 8002ade:	b003      	add	sp, #12
 8002ae0:	f85d fb04 	ldr.w	pc, [sp], #4
 8002ae4:	20000048 	.word	0x20000048

08002ae8 <lcd7735_sendCmd>:
//    SPI_I2S_SendData(SPI2, data);
}

// Send control command to controller
void lcd7735_sendCmd(const uint8_t cmd) {
    LCD_DC0;
 8002ae8:	4b02      	ldr	r3, [pc, #8]	; (8002af4 <lcd7735_sendCmd+0xc>)
 8002aea:	2201      	movs	r2, #1
 8002aec:	629a      	str	r2, [r3, #40]	; 0x28
    lcd7735_senddata(cmd);
 8002aee:	f7ff bfed 	b.w	8002acc <lcd7735_senddata>
 8002af2:	bf00      	nop
 8002af4:	48000400 	.word	0x48000400

08002af8 <lcd7735_sendData>:
//    while(SPI2->SR & SPI_SR_BSY);
}

// Send parameters o command to controller
void lcd7735_sendData(const uint8_t data) {
    LCD_DC1;
 8002af8:	4b02      	ldr	r3, [pc, #8]	; (8002b04 <lcd7735_sendData+0xc>)
 8002afa:	2201      	movs	r2, #1
 8002afc:	619a      	str	r2, [r3, #24]
    lcd7735_senddata(data);
 8002afe:	f7ff bfe5 	b.w	8002acc <lcd7735_senddata>
 8002b02:	bf00      	nop
 8002b04:	48000400 	.word	0x48000400

08002b08 <SystemClock_Config>:
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 8002b08:	b510      	push	{r4, lr}
 8002b0a:	b0ac      	sub	sp, #176	; 0xb0
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8002b0c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8002b10:	9309      	str	r3, [sp, #36]	; 0x24
  RCC_OscInitStruct.HSICalibrationValue = 16;
 8002b12:	2310      	movs	r3, #16
 8002b14:	930a      	str	r3, [sp, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 2;
  RCC_OscInitStruct.PLL.PLLN = 20;
 8002b16:	2314      	movs	r3, #20
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8002b18:	2402      	movs	r4, #2
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 2;
  RCC_OscInitStruct.PLL.PLLN = 20;
 8002b1a:	9313      	str	r3, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8002b1c:	a806      	add	r0, sp, #24
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 2;
  RCC_OscInitStruct.PLL.PLLN = 20;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
 8002b1e:	2307      	movs	r3, #7
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8002b20:	9406      	str	r4, [sp, #24]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8002b22:	9410      	str	r4, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 8002b24:	9411      	str	r4, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLM = 2;
 8002b26:	9412      	str	r4, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLN = 20;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
 8002b28:	9314      	str	r3, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
 8002b2a:	9415      	str	r4, [sp, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 8002b2c:	9416      	str	r4, [sp, #88]	; 0x58
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8002b2e:	f7fe fbe7 	bl	8001300 <HAL_RCC_OscConfig>
 8002b32:	b100      	cbz	r0, 8002b36 <SystemClock_Config+0x2e>
 8002b34:	e7fe      	b.n	8002b34 <SystemClock_Config+0x2c>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8002b36:	230f      	movs	r3, #15
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8002b38:	2104      	movs	r1, #4
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8002b3a:	9301      	str	r3, [sp, #4]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8002b3c:	9003      	str	r0, [sp, #12]

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8002b3e:	2303      	movs	r3, #3
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8002b40:	9004      	str	r0, [sp, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8002b42:	9005      	str	r0, [sp, #20]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8002b44:	eb0d 0001 	add.w	r0, sp, r1

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8002b48:	9302      	str	r3, [sp, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8002b4a:	f7fe fe4b 	bl	80017e4 <HAL_RCC_ClockConfig>
 8002b4e:	b100      	cbz	r0, 8002b52 <SystemClock_Config+0x4a>
 8002b50:	e7fe      	b.n	8002b50 <SystemClock_Config+0x48>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
  PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
 8002b52:	9020      	str	r0, [sp, #128]	; 0x80
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8002b54:	a817      	add	r0, sp, #92	; 0x5c
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 8002b56:	9417      	str	r4, [sp, #92]	; 0x5c
  PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8002b58:	f7fe ffea 	bl	8001b30 <HAL_RCCEx_PeriphCLKConfig>
 8002b5c:	b100      	cbz	r0, 8002b60 <SystemClock_Config+0x58>
 8002b5e:	e7fe      	b.n	8002b5e <SystemClock_Config+0x56>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Configure the main internal regulator output voltage 
    */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
 8002b60:	f44f 7000 	mov.w	r0, #512	; 0x200
 8002b64:	f7fe fab6 	bl	80010d4 <HAL_PWREx_ControlVoltageScaling>
 8002b68:	4604      	mov	r4, r0
 8002b6a:	b100      	cbz	r0, 8002b6e <SystemClock_Config+0x66>
 8002b6c:	e7fe      	b.n	8002b6c <SystemClock_Config+0x64>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Configure the Systick interrupt time 
    */
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8002b6e:	f7fe fef1 	bl	8001954 <HAL_RCC_GetHCLKFreq>
 8002b72:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8002b76:	fbb0 f0f3 	udiv	r0, r0, r3
 8002b7a:	f7fe f9b9 	bl	8000ef0 <HAL_SYSTICK_Config>

    /**Configure the Systick 
    */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 8002b7e:	2004      	movs	r0, #4
 8002b80:	f7fe f9cc 	bl	8000f1c <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8002b84:	4622      	mov	r2, r4
 8002b86:	4621      	mov	r1, r4
 8002b88:	f04f 30ff 	mov.w	r0, #4294967295
 8002b8c:	f7fe f97c 	bl	8000e88 <HAL_NVIC_SetPriority>
}
 8002b90:	b02c      	add	sp, #176	; 0xb0
 8002b92:	bd10      	pop	{r4, pc}

08002b94 <main>:
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

int main(void)
{
 8002b94:	b500      	push	{lr}
 8002b96:	b08b      	sub	sp, #44	; 0x2c
  /* USER CODE END 1 */

  /* MCU Configuration----------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8002b98:	f7fe f93c 	bl	8000e14 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 8002b9c:	f7ff ffb4 	bl	8002b08 <SystemClock_Config>
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8002ba0:	4b43      	ldr	r3, [pc, #268]	; (8002cb0 <main+0x11c>)
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LCD_A0_Pin|LCD_CS_Pin|LCD_RESET_Pin, GPIO_PIN_RESET);
 8002ba2:	4844      	ldr	r0, [pc, #272]	; (8002cb4 <main+0x120>)
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8002ba4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002ba6:	f042 0204 	orr.w	r2, r2, #4
 8002baa:	64da      	str	r2, [r3, #76]	; 0x4c
 8002bac:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002bae:	f002 0204 	and.w	r2, r2, #4
 8002bb2:	9202      	str	r2, [sp, #8]
 8002bb4:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8002bb6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002bb8:	f042 0201 	orr.w	r2, r2, #1
 8002bbc:	64da      	str	r2, [r3, #76]	; 0x4c
 8002bbe:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002bc0:	f002 0201 	and.w	r2, r2, #1
 8002bc4:	9203      	str	r2, [sp, #12]
 8002bc6:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8002bc8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002bca:	f042 0202 	orr.w	r2, r2, #2
 8002bce:	64da      	str	r2, [r3, #76]	; 0x4c
 8002bd0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8002bd2:	f003 0302 	and.w	r3, r3, #2
 8002bd6:	9304      	str	r3, [sp, #16]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LCD_A0_Pin|LCD_CS_Pin|LCD_RESET_Pin, GPIO_PIN_RESET);
 8002bd8:	2200      	movs	r2, #0
 8002bda:	2113      	movs	r1, #19
  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8002bdc:	9b04      	ldr	r3, [sp, #16]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LCD_A0_Pin|LCD_CS_Pin|LCD_RESET_Pin, GPIO_PIN_RESET);
 8002bde:	f7fe fa6b 	bl	80010b8 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : LCD_A0_Pin LCD_CS_Pin LCD_RESET_Pin */
  GPIO_InitStruct.Pin = LCD_A0_Pin|LCD_CS_Pin|LCD_RESET_Pin;
 8002be2:	2313      	movs	r3, #19
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002be4:	2400      	movs	r4, #0

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LCD_A0_Pin|LCD_CS_Pin|LCD_RESET_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : LCD_A0_Pin LCD_CS_Pin LCD_RESET_Pin */
  GPIO_InitStruct.Pin = LCD_A0_Pin|LCD_CS_Pin|LCD_RESET_Pin;
 8002be6:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8002be8:	4832      	ldr	r0, [pc, #200]	; (8002cb4 <main+0x120>)
  HAL_GPIO_WritePin(GPIOB, LCD_A0_Pin|LCD_CS_Pin|LCD_RESET_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : LCD_A0_Pin LCD_CS_Pin LCD_RESET_Pin */
  GPIO_InitStruct.Pin = LCD_A0_Pin|LCD_CS_Pin|LCD_RESET_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002bea:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8002bec:	2303      	movs	r3, #3
  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LCD_A0_Pin|LCD_CS_Pin|LCD_RESET_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : LCD_A0_Pin LCD_CS_Pin LCD_RESET_Pin */
  GPIO_InitStruct.Pin = LCD_A0_Pin|LCD_CS_Pin|LCD_RESET_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8002bee:	2501      	movs	r5, #1
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8002bf0:	a905      	add	r1, sp, #20

  /*Configure GPIO pins : LCD_A0_Pin LCD_CS_Pin LCD_RESET_Pin */
  GPIO_InitStruct.Pin = LCD_A0_Pin|LCD_CS_Pin|LCD_RESET_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8002bf2:	9308      	str	r3, [sp, #32]
  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LCD_A0_Pin|LCD_CS_Pin|LCD_RESET_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : LCD_A0_Pin LCD_CS_Pin LCD_RESET_Pin */
  GPIO_InitStruct.Pin = LCD_A0_Pin|LCD_CS_Pin|LCD_RESET_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8002bf4:	9506      	str	r5, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8002bf6:	f7fe f9a3 	bl	8000f40 <HAL_GPIO_Init>

/* USART2 init function */
static void MX_USART2_UART_Init(void)
{

  huart2.Instance = USART2;
 8002bfa:	482f      	ldr	r0, [pc, #188]	; (8002cb8 <main+0x124>)
  huart2.Init.BaudRate = 115200;
 8002bfc:	4b2f      	ldr	r3, [pc, #188]	; (8002cbc <main+0x128>)
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8002bfe:	6084      	str	r4, [r0, #8]
/* USART2 init function */
static void MX_USART2_UART_Init(void)
{

  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
 8002c00:	f44f 3ce1 	mov.w	ip, #115200	; 0x1c200
 8002c04:	e880 1008 	stmia.w	r0, {r3, ip}
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
 8002c08:	230c      	movs	r3, #12
{

  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
 8002c0a:	60c4      	str	r4, [r0, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 8002c0c:	6104      	str	r4, [r0, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 8002c0e:	6143      	str	r3, [r0, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8002c10:	6184      	str	r4, [r0, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8002c12:	61c4      	str	r4, [r0, #28]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8002c14:	6204      	str	r4, [r0, #32]
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8002c16:	6244      	str	r4, [r0, #36]	; 0x24
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8002c18:	f7ff fc33 	bl	8002482 <HAL_UART_Init>
 8002c1c:	b100      	cbz	r0, 8002c20 <main+0x8c>
 8002c1e:	e7fe      	b.n	8002c1e <main+0x8a>

/* SPI1 init function */
static void MX_SPI1_Init(void)
{

  hspi1.Instance = SPI1;
 8002c20:	4b27      	ldr	r3, [pc, #156]	; (8002cc0 <main+0x12c>)
  hspi1.Init.Mode = SPI_MODE_MASTER;
  hspi1.Init.Direction = SPI_DIRECTION_1LINE;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 8002c22:	4928      	ldr	r1, [pc, #160]	; (8002cc4 <main+0x130>)
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 8002c24:	6118      	str	r0, [r3, #16]
{

  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;
  hspi1.Init.Direction = SPI_DIRECTION_1LINE;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 8002c26:	f44f 7282 	mov.w	r2, #260	; 0x104
 8002c2a:	f44f 4400 	mov.w	r4, #32768	; 0x8000
 8002c2e:	f44f 6ee0 	mov.w	lr, #1792	; 0x700
 8002c32:	e883 4016 	stmia.w	r3, {r1, r2, r4, lr}
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
 8002c36:	f44f 7200 	mov.w	r2, #512	; 0x200
 8002c3a:	619a      	str	r2, [r3, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi1.Init.CRCPolynomial = 7;
 8002c3c:	2207      	movs	r2, #7
  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;
  hspi1.Init.Direction = SPI_DIRECTION_1LINE;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 8002c3e:	6158      	str	r0, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 8002c40:	61d8      	str	r0, [r3, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8002c42:	6218      	str	r0, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 8002c44:	6258      	str	r0, [r3, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8002c46:	6298      	str	r0, [r3, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 7;
 8002c48:	62da      	str	r2, [r3, #44]	; 0x2c
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 8002c4a:	6318      	str	r0, [r3, #48]	; 0x30
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 8002c4c:	2208      	movs	r2, #8
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 8002c4e:	4618      	mov	r0, r3
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi1.Init.CRCPolynomial = 7;
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 8002c50:	635a      	str	r2, [r3, #52]	; 0x34
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 8002c52:	f7ff f930 	bl	8001eb6 <HAL_SPI_Init>
 8002c56:	4604      	mov	r4, r0
 8002c58:	b100      	cbz	r0, 8002c5c <main+0xc8>
 8002c5a:	e7fe      	b.n	8002c5a <main+0xc6>
  MX_GPIO_Init();
  MX_USART2_UART_Init();
  MX_SPI1_Init();

  /* USER CODE BEGIN 2 */
  lcd7735_initR(INITR_REDTAB);
 8002c5c:	4628      	mov	r0, r5
 8002c5e:	f7ff fc8b 	bl	8002578 <lcd7735_initR>
  lcd7735_setFont((uint8_t *)&SmallFont[0]);
 8002c62:	4819      	ldr	r0, [pc, #100]	; (8002cc8 <main+0x134>)
 8002c64:	f7ff fd44 	bl	80026f0 <lcd7735_setFont>
  lcd7735_fillScreen(ST7735_BLACK);
 8002c68:	4620      	mov	r0, r4
 8002c6a:	f7ff ff0f 	bl	8002a8c <lcd7735_fillScreen>
  lcd7735_fillRect(4,58,119,35,ST7735_GREEN);
 8002c6e:	f44f 63fc 	mov.w	r3, #2016	; 0x7e0
 8002c72:	2277      	movs	r2, #119	; 0x77
 8002c74:	213a      	movs	r1, #58	; 0x3a
 8002c76:	9300      	str	r3, [sp, #0]
 8002c78:	2004      	movs	r0, #4
 8002c7a:	2323      	movs	r3, #35	; 0x23
 8002c7c:	f7ff fcf4 	bl	8002668 <lcd7735_fillRect>
  lcd7735_setForeground(ST7735_WHITE);
 8002c80:	f64f 70ff 	movw	r0, #65535	; 0xffff
 8002c84:	f7ff ff16 	bl	8002ab4 <lcd7735_setForeground>
  lcd7735_setTransparent(1);
 8002c88:	4628      	mov	r0, r5
 8002c8a:	f7ff ff19 	bl	8002ac0 <lcd7735_setTransparent>
  lcd7735_print("Hello World!",15,62,0);
 8002c8e:	4623      	mov	r3, r4
 8002c90:	223e      	movs	r2, #62	; 0x3e
 8002c92:	210f      	movs	r1, #15
 8002c94:	480d      	ldr	r0, [pc, #52]	; (8002ccc <main+0x138>)
 8002c96:	f7ff feb3 	bl	8002a00 <lcd7735_print>
  lcd7735_print("GLCD way!",25,75,0);
 8002c9a:	480d      	ldr	r0, [pc, #52]	; (8002cd0 <main+0x13c>)
 8002c9c:	4623      	mov	r3, r4
 8002c9e:	224b      	movs	r2, #75	; 0x4b
 8002ca0:	2119      	movs	r1, #25
 8002ca2:	f7ff fead 	bl	8002a00 <lcd7735_print>
  lcd7735_setTransparent(0);
 8002ca6:	4620      	mov	r0, r4
 8002ca8:	f7ff ff0a 	bl	8002ac0 <lcd7735_setTransparent>
 8002cac:	e7fe      	b.n	8002cac <main+0x118>
 8002cae:	bf00      	nop
 8002cb0:	40021000 	.word	0x40021000
 8002cb4:	48000400 	.word	0x48000400
 8002cb8:	200000ac 	.word	0x200000ac
 8002cbc:	40004400 	.word	0x40004400
 8002cc0:	20000048 	.word	0x20000048
 8002cc4:	40013000 	.word	0x40013000
 8002cc8:	08004059 	.word	0x08004059
 8002ccc:	08004552 	.word	0x08004552
 8002cd0:	0800455f 	.word	0x0800455f

08002cd4 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002cd4:	4b21      	ldr	r3, [pc, #132]	; (8002d5c <HAL_MspInit+0x88>)
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8002cd6:	b507      	push	{r0, r1, r2, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002cd8:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8002cda:	f042 0201 	orr.w	r2, r2, #1
 8002cde:	661a      	str	r2, [r3, #96]	; 0x60
 8002ce0:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8002ce2:	f002 0201 	and.w	r2, r2, #1
 8002ce6:	9200      	str	r2, [sp, #0]
 8002ce8:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8002cea:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8002cec:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002cf0:	659a      	str	r2, [r3, #88]	; 0x58
 8002cf2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8002cf4:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002cf8:	9301      	str	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8002cfa:	2003      	movs	r0, #3
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
  __HAL_RCC_PWR_CLK_ENABLE();
 8002cfc:	9b01      	ldr	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8002cfe:	f7fe f8b1 	bl	8000e64 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 8002d02:	2200      	movs	r2, #0
 8002d04:	4611      	mov	r1, r2
 8002d06:	f06f 000b 	mvn.w	r0, #11
 8002d0a:	f7fe f8bd 	bl	8000e88 <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 8002d0e:	2200      	movs	r2, #0
 8002d10:	4611      	mov	r1, r2
 8002d12:	f06f 000a 	mvn.w	r0, #10
 8002d16:	f7fe f8b7 	bl	8000e88 <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 8002d1a:	2200      	movs	r2, #0
 8002d1c:	4611      	mov	r1, r2
 8002d1e:	f06f 0009 	mvn.w	r0, #9
 8002d22:	f7fe f8b1 	bl	8000e88 <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 8002d26:	2200      	movs	r2, #0
 8002d28:	4611      	mov	r1, r2
 8002d2a:	f06f 0004 	mvn.w	r0, #4
 8002d2e:	f7fe f8ab 	bl	8000e88 <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 8002d32:	2200      	movs	r2, #0
 8002d34:	4611      	mov	r1, r2
 8002d36:	f06f 0003 	mvn.w	r0, #3
 8002d3a:	f7fe f8a5 	bl	8000e88 <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
 8002d3e:	2200      	movs	r2, #0
 8002d40:	4611      	mov	r1, r2
 8002d42:	f06f 0001 	mvn.w	r0, #1
 8002d46:	f7fe f89f 	bl	8000e88 <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8002d4a:	2200      	movs	r2, #0
 8002d4c:	4611      	mov	r1, r2
 8002d4e:	f04f 30ff 	mov.w	r0, #4294967295
 8002d52:	f7fe f899 	bl	8000e88 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8002d56:	b003      	add	sp, #12
 8002d58:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d5c:	40021000 	.word	0x40021000

08002d60 <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8002d60:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hspi->Instance==SPI1)
 8002d62:	6802      	ldr	r2, [r0, #0]
 8002d64:	4b0f      	ldr	r3, [pc, #60]	; (8002da4 <HAL_SPI_MspInit+0x44>)
 8002d66:	429a      	cmp	r2, r3
 8002d68:	d118      	bne.n	8002d9c <HAL_SPI_MspInit+0x3c>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8002d6a:	f503 4360 	add.w	r3, r3, #57344	; 0xe000
    GPIO_InitStruct.Pin = LCD_SCK_Pin|LCD_SDA_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8002d6e:	a901      	add	r1, sp, #4
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8002d70:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    GPIO_InitStruct.Pin = LCD_SCK_Pin|LCD_SDA_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8002d72:	480d      	ldr	r0, [pc, #52]	; (8002da8 <HAL_SPI_MspInit+0x48>)
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8002d74:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8002d78:	661a      	str	r2, [r3, #96]	; 0x60
 8002d7a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8002d7c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8002d80:	9300      	str	r3, [sp, #0]
 8002d82:	9b00      	ldr	r3, [sp, #0]
  
    /**SPI1 GPIO Configuration    
    PB3 (JTDO-TRACESWO)     ------> SPI1_SCK
    PB5     ------> SPI1_MOSI 
    */
    GPIO_InitStruct.Pin = LCD_SCK_Pin|LCD_SDA_Pin;
 8002d84:	2328      	movs	r3, #40	; 0x28
 8002d86:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8002d88:	2302      	movs	r3, #2
 8002d8a:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002d8c:	2300      	movs	r3, #0
 8002d8e:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8002d90:	2303      	movs	r3, #3
 8002d92:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 8002d94:	2305      	movs	r3, #5
 8002d96:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8002d98:	f7fe f8d2 	bl	8000f40 <HAL_GPIO_Init>
  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }

}
 8002d9c:	b007      	add	sp, #28
 8002d9e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002da2:	bf00      	nop
 8002da4:	40013000 	.word	0x40013000
 8002da8:	48000400 	.word	0x48000400

08002dac <HAL_UART_MspInit>:
  }

}

void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8002dac:	b570      	push	{r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(huart->Instance==USART2)
 8002dae:	6802      	ldr	r2, [r0, #0]
 8002db0:	4b15      	ldr	r3, [pc, #84]	; (8002e08 <HAL_UART_MspInit+0x5c>)
 8002db2:	429a      	cmp	r2, r3
  }

}

void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8002db4:	b086      	sub	sp, #24

  GPIO_InitTypeDef GPIO_InitStruct;
  if(huart->Instance==USART2)
 8002db6:	d125      	bne.n	8002e04 <HAL_UART_MspInit+0x58>
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 8002db8:	f503 33e6 	add.w	r3, r3, #117760	; 0x1cc00
    PA15 (JTDI)     ------> USART2_RX 
    */
    GPIO_InitStruct.Pin = VCP_TX_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8002dbc:	2403      	movs	r4, #3
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 8002dbe:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8002dc0:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8002dc4:	659a      	str	r2, [r3, #88]	; 0x58
 8002dc6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    PA15 (JTDI)     ------> USART2_RX 
    */
    GPIO_InitStruct.Pin = VCP_TX_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8002dc8:	9404      	str	r4, [sp, #16]
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 8002dca:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8002dce:	9300      	str	r3, [sp, #0]
 8002dd0:	9b00      	ldr	r3, [sp, #0]
  
    /**USART2 GPIO Configuration    
    PA2     ------> USART2_TX
    PA15 (JTDI)     ------> USART2_RX 
    */
    GPIO_InitStruct.Pin = VCP_TX_Pin;
 8002dd2:	2304      	movs	r3, #4
 8002dd4:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8002dd6:	2602      	movs	r6, #2
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8002dd8:	2307      	movs	r3, #7
    PA2     ------> USART2_TX
    PA15 (JTDI)     ------> USART2_RX 
    */
    GPIO_InitStruct.Pin = VCP_TX_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8002dda:	2501      	movs	r5, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(VCP_TX_GPIO_Port, &GPIO_InitStruct);
 8002ddc:	a901      	add	r1, sp, #4
 8002dde:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    */
    GPIO_InitStruct.Pin = VCP_TX_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8002de2:	9305      	str	r3, [sp, #20]
    /**USART2 GPIO Configuration    
    PA2     ------> USART2_TX
    PA15 (JTDI)     ------> USART2_RX 
    */
    GPIO_InitStruct.Pin = VCP_TX_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8002de4:	9602      	str	r6, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8002de6:	9503      	str	r5, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(VCP_TX_GPIO_Port, &GPIO_InitStruct);
 8002de8:	f7fe f8aa 	bl	8000f40 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = VCP_RX_Pin;
 8002dec:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF3_USART2;
    HAL_GPIO_Init(VCP_RX_GPIO_Port, &GPIO_InitStruct);
 8002df0:	a901      	add	r1, sp, #4
 8002df2:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(VCP_TX_GPIO_Port, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = VCP_RX_Pin;
 8002df6:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8002df8:	9602      	str	r6, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8002dfa:	9503      	str	r5, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8002dfc:	9404      	str	r4, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF3_USART2;
 8002dfe:	9405      	str	r4, [sp, #20]
    HAL_GPIO_Init(VCP_RX_GPIO_Port, &GPIO_InitStruct);
 8002e00:	f7fe f89e 	bl	8000f40 <HAL_GPIO_Init>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }

}
 8002e04:	b006      	add	sp, #24
 8002e06:	bd70      	pop	{r4, r5, r6, pc}
 8002e08:	40004400 	.word	0x40004400

08002e0c <SVC_Handler>:
 8002e0c:	4770      	bx	lr

08002e0e <PendSV_Handler>:

/**
* @brief This function handles Pendable request for system service.
*/
void PendSV_Handler(void)
{
 8002e0e:	4770      	bx	lr

08002e10 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 8002e10:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8002e12:	f7fe f80b 	bl	8000e2c <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8002e16:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  HAL_SYSTICK_IRQHandler();
 8002e1a:	f7fe b88c 	b.w	8000f36 <HAL_SYSTICK_IRQHandler>
	...

08002e20 <SystemInit>:

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8002e20:	490f      	ldr	r1, [pc, #60]	; (8002e60 <SystemInit+0x40>)
 8002e22:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8002e26:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8002e2a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8002e2e:	4b0d      	ldr	r3, [pc, #52]	; (8002e64 <SystemInit+0x44>)
 8002e30:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8002e32:	2000      	movs	r0, #0
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8002e34:	f042 0201 	orr.w	r2, r2, #1
 8002e38:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8002e3a:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= (uint32_t)0xEAF6FFFF;
 8002e3c:	681a      	ldr	r2, [r3, #0]
 8002e3e:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
 8002e42:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
 8002e46:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000;
 8002e48:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8002e4c:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8002e4e:	681a      	ldr	r2, [r3, #0]
 8002e50:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8002e54:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 8002e56:	6198      	str	r0, [r3, #24]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8002e58:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8002e5c:	608b      	str	r3, [r1, #8]
 8002e5e:	4770      	bx	lr
 8002e60:	e000ed00 	.word	0xe000ed00
 8002e64:	40021000 	.word	0x40021000

08002e68 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8002e68:	f8df d034 	ldr.w	sp, [pc, #52]	; 8002ea0 <LoopForever+0x2>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8002e6c:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8002e6e:	e003      	b.n	8002e78 <LoopCopyDataInit>

08002e70 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8002e70:	4b0c      	ldr	r3, [pc, #48]	; (8002ea4 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 8002e72:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8002e74:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 8002e76:	3104      	adds	r1, #4

08002e78 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 8002e78:	480b      	ldr	r0, [pc, #44]	; (8002ea8 <LoopForever+0xa>)
	ldr	r3, =_edata
 8002e7a:	4b0c      	ldr	r3, [pc, #48]	; (8002eac <LoopForever+0xe>)
	adds	r2, r0, r1
 8002e7c:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8002e7e:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8002e80:	d3f6      	bcc.n	8002e70 <CopyDataInit>
	ldr	r2, =_sbss
 8002e82:	4a0b      	ldr	r2, [pc, #44]	; (8002eb0 <LoopForever+0x12>)
	b	LoopFillZerobss
 8002e84:	e002      	b.n	8002e8c <LoopFillZerobss>

08002e86 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 8002e86:	2300      	movs	r3, #0
	str	r3, [r2], #4
 8002e88:	f842 3b04 	str.w	r3, [r2], #4

08002e8c <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 8002e8c:	4b09      	ldr	r3, [pc, #36]	; (8002eb4 <LoopForever+0x16>)
	cmp	r2, r3
 8002e8e:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8002e90:	d3f9      	bcc.n	8002e86 <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 8002e92:	f7ff ffc5 	bl	8002e20 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8002e96:	f000 f811 	bl	8002ebc <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 8002e9a:	f7ff fe7b 	bl	8002b94 <main>

08002e9e <LoopForever>:

LoopForever:
    b LoopForever
 8002e9e:	e7fe      	b.n	8002e9e <LoopForever>

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8002ea0:	20010000 	.word	0x20010000
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
 8002ea4:	080047a0 	.word	0x080047a0
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
 8002ea8:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8002eac:	2000000c 	.word	0x2000000c
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
 8002eb0:	2000000c 	.word	0x2000000c
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
 8002eb4:	2000011c 	.word	0x2000011c

08002eb8 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8002eb8:	e7fe      	b.n	8002eb8 <ADC1_IRQHandler>
	...

08002ebc <__libc_init_array>:
 8002ebc:	b570      	push	{r4, r5, r6, lr}
 8002ebe:	4b0e      	ldr	r3, [pc, #56]	; (8002ef8 <__libc_init_array+0x3c>)
 8002ec0:	4c0e      	ldr	r4, [pc, #56]	; (8002efc <__libc_init_array+0x40>)
 8002ec2:	1ae4      	subs	r4, r4, r3
 8002ec4:	10a4      	asrs	r4, r4, #2
 8002ec6:	2500      	movs	r5, #0
 8002ec8:	461e      	mov	r6, r3
 8002eca:	42a5      	cmp	r5, r4
 8002ecc:	d004      	beq.n	8002ed8 <__libc_init_array+0x1c>
 8002ece:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8002ed2:	4798      	blx	r3
 8002ed4:	3501      	adds	r5, #1
 8002ed6:	e7f8      	b.n	8002eca <__libc_init_array+0xe>
 8002ed8:	f001 f8aa 	bl	8004030 <_init>
 8002edc:	4c08      	ldr	r4, [pc, #32]	; (8002f00 <__libc_init_array+0x44>)
 8002ede:	4b09      	ldr	r3, [pc, #36]	; (8002f04 <__libc_init_array+0x48>)
 8002ee0:	1ae4      	subs	r4, r4, r3
 8002ee2:	10a4      	asrs	r4, r4, #2
 8002ee4:	2500      	movs	r5, #0
 8002ee6:	461e      	mov	r6, r3
 8002ee8:	42a5      	cmp	r5, r4
 8002eea:	d004      	beq.n	8002ef6 <__libc_init_array+0x3a>
 8002eec:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8002ef0:	4798      	blx	r3
 8002ef2:	3501      	adds	r5, #1
 8002ef4:	e7f8      	b.n	8002ee8 <__libc_init_array+0x2c>
 8002ef6:	bd70      	pop	{r4, r5, r6, pc}
 8002ef8:	08004798 	.word	0x08004798
 8002efc:	08004798 	.word	0x08004798
 8002f00:	0800479c 	.word	0x0800479c
 8002f04:	08004798 	.word	0x08004798

08002f08 <cos>:
 8002f08:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8002f0a:	ec51 0b10 	vmov	r0, r1, d0
 8002f0e:	4a1e      	ldr	r2, [pc, #120]	; (8002f88 <cos+0x80>)
 8002f10:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 8002f14:	4293      	cmp	r3, r2
 8002f16:	dc02      	bgt.n	8002f1e <cos+0x16>
 8002f18:	ed9f 1b19 	vldr	d1, [pc, #100]	; 8002f80 <cos+0x78>
 8002f1c:	e016      	b.n	8002f4c <cos+0x44>
 8002f1e:	4a1b      	ldr	r2, [pc, #108]	; (8002f8c <cos+0x84>)
 8002f20:	4293      	cmp	r3, r2
 8002f22:	dd05      	ble.n	8002f30 <cos+0x28>
 8002f24:	ee10 2a10 	vmov	r2, s0
 8002f28:	460b      	mov	r3, r1
 8002f2a:	f7fd f95d 	bl	80001e8 <__aeabi_dsub>
 8002f2e:	e021      	b.n	8002f74 <cos+0x6c>
 8002f30:	4668      	mov	r0, sp
 8002f32:	f000 f875 	bl	8003020 <__ieee754_rem_pio2>
 8002f36:	f000 0003 	and.w	r0, r0, #3
 8002f3a:	2801      	cmp	r0, #1
 8002f3c:	ed9d 1b02 	vldr	d1, [sp, #8]
 8002f40:	ed9d 0b00 	vldr	d0, [sp]
 8002f44:	d005      	beq.n	8002f52 <cos+0x4a>
 8002f46:	2802      	cmp	r0, #2
 8002f48:	d006      	beq.n	8002f58 <cos+0x50>
 8002f4a:	b970      	cbnz	r0, 8002f6a <cos+0x62>
 8002f4c:	f000 fa68 	bl	8003420 <__kernel_cos>
 8002f50:	e00e      	b.n	8002f70 <cos+0x68>
 8002f52:	f000 fe9d 	bl	8003c90 <__kernel_sin>
 8002f56:	e001      	b.n	8002f5c <cos+0x54>
 8002f58:	f000 fa62 	bl	8003420 <__kernel_cos>
 8002f5c:	ec53 2b10 	vmov	r2, r3, d0
 8002f60:	ee10 0a10 	vmov	r0, s0
 8002f64:	f103 4100 	add.w	r1, r3, #2147483648	; 0x80000000
 8002f68:	e004      	b.n	8002f74 <cos+0x6c>
 8002f6a:	2001      	movs	r0, #1
 8002f6c:	f000 fe90 	bl	8003c90 <__kernel_sin>
 8002f70:	ec51 0b10 	vmov	r0, r1, d0
 8002f74:	ec41 0b10 	vmov	d0, r0, r1
 8002f78:	b005      	add	sp, #20
 8002f7a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f7e:	bf00      	nop
	...
 8002f88:	3fe921fb 	.word	0x3fe921fb
 8002f8c:	7fefffff 	.word	0x7fefffff

08002f90 <sin>:
 8002f90:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8002f92:	ec51 0b10 	vmov	r0, r1, d0
 8002f96:	4a20      	ldr	r2, [pc, #128]	; (8003018 <sin+0x88>)
 8002f98:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 8002f9c:	4293      	cmp	r3, r2
 8002f9e:	dc03      	bgt.n	8002fa8 <sin+0x18>
 8002fa0:	2000      	movs	r0, #0
 8002fa2:	ed9f 1b1b 	vldr	d1, [pc, #108]	; 8003010 <sin+0x80>
 8002fa6:	e017      	b.n	8002fd8 <sin+0x48>
 8002fa8:	4a1c      	ldr	r2, [pc, #112]	; (800301c <sin+0x8c>)
 8002faa:	4293      	cmp	r3, r2
 8002fac:	dd05      	ble.n	8002fba <sin+0x2a>
 8002fae:	ee10 2a10 	vmov	r2, s0
 8002fb2:	460b      	mov	r3, r1
 8002fb4:	f7fd f918 	bl	80001e8 <__aeabi_dsub>
 8002fb8:	e022      	b.n	8003000 <sin+0x70>
 8002fba:	4668      	mov	r0, sp
 8002fbc:	f000 f830 	bl	8003020 <__ieee754_rem_pio2>
 8002fc0:	f000 0003 	and.w	r0, r0, #3
 8002fc4:	2801      	cmp	r0, #1
 8002fc6:	ed9d 1b02 	vldr	d1, [sp, #8]
 8002fca:	ed9d 0b00 	vldr	d0, [sp]
 8002fce:	d008      	beq.n	8002fe2 <sin+0x52>
 8002fd0:	2802      	cmp	r0, #2
 8002fd2:	d009      	beq.n	8002fe8 <sin+0x58>
 8002fd4:	b960      	cbnz	r0, 8002ff0 <sin+0x60>
 8002fd6:	2001      	movs	r0, #1
 8002fd8:	f000 fe5a 	bl	8003c90 <__kernel_sin>
 8002fdc:	ec51 0b10 	vmov	r0, r1, d0
 8002fe0:	e00e      	b.n	8003000 <sin+0x70>
 8002fe2:	f000 fa1d 	bl	8003420 <__kernel_cos>
 8002fe6:	e7f9      	b.n	8002fdc <sin+0x4c>
 8002fe8:	2001      	movs	r0, #1
 8002fea:	f000 fe51 	bl	8003c90 <__kernel_sin>
 8002fee:	e001      	b.n	8002ff4 <sin+0x64>
 8002ff0:	f000 fa16 	bl	8003420 <__kernel_cos>
 8002ff4:	ec53 2b10 	vmov	r2, r3, d0
 8002ff8:	ee10 0a10 	vmov	r0, s0
 8002ffc:	f103 4100 	add.w	r1, r3, #2147483648	; 0x80000000
 8003000:	ec41 0b10 	vmov	d0, r0, r1
 8003004:	b005      	add	sp, #20
 8003006:	f85d fb04 	ldr.w	pc, [sp], #4
 800300a:	bf00      	nop
 800300c:	f3af 8000 	nop.w
	...
 8003018:	3fe921fb 	.word	0x3fe921fb
 800301c:	7fefffff 	.word	0x7fefffff

08003020 <__ieee754_rem_pio2>:
 8003020:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003024:	ec55 4b10 	vmov	r4, r5, d0
 8003028:	4bc7      	ldr	r3, [pc, #796]	; (8003348 <__ieee754_rem_pio2+0x328>)
 800302a:	f025 4800 	bic.w	r8, r5, #2147483648	; 0x80000000
 800302e:	4598      	cmp	r8, r3
 8003030:	b08d      	sub	sp, #52	; 0x34
 8003032:	4682      	mov	sl, r0
 8003034:	46ab      	mov	fp, r5
 8003036:	dc06      	bgt.n	8003046 <__ieee754_rem_pio2+0x26>
 8003038:	2200      	movs	r2, #0
 800303a:	2300      	movs	r3, #0
 800303c:	ed8a 0b00 	vstr	d0, [sl]
 8003040:	e9c0 2302 	strd	r2, r3, [r0, #8]
 8003044:	e160      	b.n	8003308 <__ieee754_rem_pio2+0x2e8>
 8003046:	4bc1      	ldr	r3, [pc, #772]	; (800334c <__ieee754_rem_pio2+0x32c>)
 8003048:	4598      	cmp	r8, r3
 800304a:	dc71      	bgt.n	8003130 <__ieee754_rem_pio2+0x110>
 800304c:	2d00      	cmp	r5, #0
 800304e:	a3b0      	add	r3, pc, #704	; (adr r3, 8003310 <__ieee754_rem_pio2+0x2f0>)
 8003050:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003054:	ee10 0a10 	vmov	r0, s0
 8003058:	4629      	mov	r1, r5
 800305a:	4ebd      	ldr	r6, [pc, #756]	; (8003350 <__ieee754_rem_pio2+0x330>)
 800305c:	dd33      	ble.n	80030c6 <__ieee754_rem_pio2+0xa6>
 800305e:	f7fd f8c3 	bl	80001e8 <__aeabi_dsub>
 8003062:	45b0      	cmp	r8, r6
 8003064:	4604      	mov	r4, r0
 8003066:	460d      	mov	r5, r1
 8003068:	d010      	beq.n	800308c <__ieee754_rem_pio2+0x6c>
 800306a:	a3ab      	add	r3, pc, #684	; (adr r3, 8003318 <__ieee754_rem_pio2+0x2f8>)
 800306c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003070:	f7fd f8ba 	bl	80001e8 <__aeabi_dsub>
 8003074:	4602      	mov	r2, r0
 8003076:	460b      	mov	r3, r1
 8003078:	e9ca 2300 	strd	r2, r3, [sl]
 800307c:	4620      	mov	r0, r4
 800307e:	4629      	mov	r1, r5
 8003080:	f7fd f8b2 	bl	80001e8 <__aeabi_dsub>
 8003084:	a3a4      	add	r3, pc, #656	; (adr r3, 8003318 <__ieee754_rem_pio2+0x2f8>)
 8003086:	e9d3 2300 	ldrd	r2, r3, [r3]
 800308a:	e016      	b.n	80030ba <__ieee754_rem_pio2+0x9a>
 800308c:	a3a4      	add	r3, pc, #656	; (adr r3, 8003320 <__ieee754_rem_pio2+0x300>)
 800308e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003092:	f7fd f8a9 	bl	80001e8 <__aeabi_dsub>
 8003096:	a3a4      	add	r3, pc, #656	; (adr r3, 8003328 <__ieee754_rem_pio2+0x308>)
 8003098:	e9d3 2300 	ldrd	r2, r3, [r3]
 800309c:	4604      	mov	r4, r0
 800309e:	460d      	mov	r5, r1
 80030a0:	f7fd f8a2 	bl	80001e8 <__aeabi_dsub>
 80030a4:	4602      	mov	r2, r0
 80030a6:	460b      	mov	r3, r1
 80030a8:	e9ca 2300 	strd	r2, r3, [sl]
 80030ac:	4620      	mov	r0, r4
 80030ae:	4629      	mov	r1, r5
 80030b0:	f7fd f89a 	bl	80001e8 <__aeabi_dsub>
 80030b4:	a39c      	add	r3, pc, #624	; (adr r3, 8003328 <__ieee754_rem_pio2+0x308>)
 80030b6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80030ba:	f7fd f895 	bl	80001e8 <__aeabi_dsub>
 80030be:	e9ca 0102 	strd	r0, r1, [sl, #8]
 80030c2:	2001      	movs	r0, #1
 80030c4:	e1a2      	b.n	800340c <__ieee754_rem_pio2+0x3ec>
 80030c6:	f7fd f891 	bl	80001ec <__adddf3>
 80030ca:	45b0      	cmp	r8, r6
 80030cc:	4604      	mov	r4, r0
 80030ce:	460d      	mov	r5, r1
 80030d0:	d010      	beq.n	80030f4 <__ieee754_rem_pio2+0xd4>
 80030d2:	a391      	add	r3, pc, #580	; (adr r3, 8003318 <__ieee754_rem_pio2+0x2f8>)
 80030d4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80030d8:	f7fd f888 	bl	80001ec <__adddf3>
 80030dc:	4602      	mov	r2, r0
 80030de:	460b      	mov	r3, r1
 80030e0:	e9ca 2300 	strd	r2, r3, [sl]
 80030e4:	4620      	mov	r0, r4
 80030e6:	4629      	mov	r1, r5
 80030e8:	f7fd f87e 	bl	80001e8 <__aeabi_dsub>
 80030ec:	a38a      	add	r3, pc, #552	; (adr r3, 8003318 <__ieee754_rem_pio2+0x2f8>)
 80030ee:	e9d3 2300 	ldrd	r2, r3, [r3]
 80030f2:	e016      	b.n	8003122 <__ieee754_rem_pio2+0x102>
 80030f4:	a38a      	add	r3, pc, #552	; (adr r3, 8003320 <__ieee754_rem_pio2+0x300>)
 80030f6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80030fa:	f7fd f877 	bl	80001ec <__adddf3>
 80030fe:	a38a      	add	r3, pc, #552	; (adr r3, 8003328 <__ieee754_rem_pio2+0x308>)
 8003100:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003104:	4604      	mov	r4, r0
 8003106:	460d      	mov	r5, r1
 8003108:	f7fd f870 	bl	80001ec <__adddf3>
 800310c:	4602      	mov	r2, r0
 800310e:	460b      	mov	r3, r1
 8003110:	e9ca 2300 	strd	r2, r3, [sl]
 8003114:	4620      	mov	r0, r4
 8003116:	4629      	mov	r1, r5
 8003118:	f7fd f866 	bl	80001e8 <__aeabi_dsub>
 800311c:	a382      	add	r3, pc, #520	; (adr r3, 8003328 <__ieee754_rem_pio2+0x308>)
 800311e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003122:	f7fd f863 	bl	80001ec <__adddf3>
 8003126:	e9ca 0102 	strd	r0, r1, [sl, #8]
 800312a:	f04f 30ff 	mov.w	r0, #4294967295
 800312e:	e16d      	b.n	800340c <__ieee754_rem_pio2+0x3ec>
 8003130:	4b88      	ldr	r3, [pc, #544]	; (8003354 <__ieee754_rem_pio2+0x334>)
 8003132:	4598      	cmp	r8, r3
 8003134:	f300 80da 	bgt.w	80032ec <__ieee754_rem_pio2+0x2cc>
 8003138:	f000 fe64 	bl	8003e04 <fabs>
 800313c:	ec55 4b10 	vmov	r4, r5, d0
 8003140:	ee10 0a10 	vmov	r0, s0
 8003144:	a37a      	add	r3, pc, #488	; (adr r3, 8003330 <__ieee754_rem_pio2+0x310>)
 8003146:	e9d3 2300 	ldrd	r2, r3, [r3]
 800314a:	4629      	mov	r1, r5
 800314c:	f7fd fa00 	bl	8000550 <__aeabi_dmul>
 8003150:	2200      	movs	r2, #0
 8003152:	4b81      	ldr	r3, [pc, #516]	; (8003358 <__ieee754_rem_pio2+0x338>)
 8003154:	f7fd f84a 	bl	80001ec <__adddf3>
 8003158:	f7fd fc94 	bl	8000a84 <__aeabi_d2iz>
 800315c:	4681      	mov	r9, r0
 800315e:	f7fd f991 	bl	8000484 <__aeabi_i2d>
 8003162:	a36b      	add	r3, pc, #428	; (adr r3, 8003310 <__ieee754_rem_pio2+0x2f0>)
 8003164:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003168:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800316c:	f7fd f9f0 	bl	8000550 <__aeabi_dmul>
 8003170:	4602      	mov	r2, r0
 8003172:	460b      	mov	r3, r1
 8003174:	4620      	mov	r0, r4
 8003176:	4629      	mov	r1, r5
 8003178:	f7fd f836 	bl	80001e8 <__aeabi_dsub>
 800317c:	a366      	add	r3, pc, #408	; (adr r3, 8003318 <__ieee754_rem_pio2+0x2f8>)
 800317e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003182:	4604      	mov	r4, r0
 8003184:	460d      	mov	r5, r1
 8003186:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800318a:	f7fd f9e1 	bl	8000550 <__aeabi_dmul>
 800318e:	f1b9 0f1f 	cmp.w	r9, #31
 8003192:	4606      	mov	r6, r0
 8003194:	460f      	mov	r7, r1
 8003196:	dc06      	bgt.n	80031a6 <__ieee754_rem_pio2+0x186>
 8003198:	f109 32ff 	add.w	r2, r9, #4294967295
 800319c:	4b6f      	ldr	r3, [pc, #444]	; (800335c <__ieee754_rem_pio2+0x33c>)
 800319e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80031a2:	4598      	cmp	r8, r3
 80031a4:	d172      	bne.n	800328c <__ieee754_rem_pio2+0x26c>
 80031a6:	463b      	mov	r3, r7
 80031a8:	4632      	mov	r2, r6
 80031aa:	4620      	mov	r0, r4
 80031ac:	4629      	mov	r1, r5
 80031ae:	f7fd f81b 	bl	80001e8 <__aeabi_dsub>
 80031b2:	ea4f 5828 	mov.w	r8, r8, asr #20
 80031b6:	f3c1 530a 	ubfx	r3, r1, #20, #11
 80031ba:	ebc3 0308 	rsb	r3, r3, r8
 80031be:	2b10      	cmp	r3, #16
 80031c0:	e9ca 0100 	strd	r0, r1, [sl]
 80031c4:	dd6d      	ble.n	80032a2 <__ieee754_rem_pio2+0x282>
 80031c6:	a356      	add	r3, pc, #344	; (adr r3, 8003320 <__ieee754_rem_pio2+0x300>)
 80031c8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80031cc:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80031d0:	f7fd f9be 	bl	8000550 <__aeabi_dmul>
 80031d4:	4606      	mov	r6, r0
 80031d6:	460f      	mov	r7, r1
 80031d8:	4602      	mov	r2, r0
 80031da:	460b      	mov	r3, r1
 80031dc:	4620      	mov	r0, r4
 80031de:	4629      	mov	r1, r5
 80031e0:	f7fd f802 	bl	80001e8 <__aeabi_dsub>
 80031e4:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80031e8:	4602      	mov	r2, r0
 80031ea:	460b      	mov	r3, r1
 80031ec:	4620      	mov	r0, r4
 80031ee:	4629      	mov	r1, r5
 80031f0:	f7fc fffa 	bl	80001e8 <__aeabi_dsub>
 80031f4:	4632      	mov	r2, r6
 80031f6:	463b      	mov	r3, r7
 80031f8:	f7fc fff6 	bl	80001e8 <__aeabi_dsub>
 80031fc:	a34a      	add	r3, pc, #296	; (adr r3, 8003328 <__ieee754_rem_pio2+0x308>)
 80031fe:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003202:	4604      	mov	r4, r0
 8003204:	460d      	mov	r5, r1
 8003206:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800320a:	f7fd f9a1 	bl	8000550 <__aeabi_dmul>
 800320e:	4622      	mov	r2, r4
 8003210:	462b      	mov	r3, r5
 8003212:	f7fc ffe9 	bl	80001e8 <__aeabi_dsub>
 8003216:	460b      	mov	r3, r1
 8003218:	4602      	mov	r2, r0
 800321a:	4606      	mov	r6, r0
 800321c:	460f      	mov	r7, r1
 800321e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8003222:	f7fc ffe1 	bl	80001e8 <__aeabi_dsub>
 8003226:	f3c1 530a 	ubfx	r3, r1, #20, #11
 800322a:	ebc3 0808 	rsb	r8, r3, r8
 800322e:	f1b8 0f31 	cmp.w	r8, #49	; 0x31
 8003232:	e9ca 0100 	strd	r0, r1, [sl]
 8003236:	dd32      	ble.n	800329e <__ieee754_rem_pio2+0x27e>
 8003238:	a33f      	add	r3, pc, #252	; (adr r3, 8003338 <__ieee754_rem_pio2+0x318>)
 800323a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800323e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8003242:	f7fd f985 	bl	8000550 <__aeabi_dmul>
 8003246:	4606      	mov	r6, r0
 8003248:	460f      	mov	r7, r1
 800324a:	4602      	mov	r2, r0
 800324c:	460b      	mov	r3, r1
 800324e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8003252:	f7fc ffc9 	bl	80001e8 <__aeabi_dsub>
 8003256:	4602      	mov	r2, r0
 8003258:	460b      	mov	r3, r1
 800325a:	4604      	mov	r4, r0
 800325c:	460d      	mov	r5, r1
 800325e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8003262:	f7fc ffc1 	bl	80001e8 <__aeabi_dsub>
 8003266:	4632      	mov	r2, r6
 8003268:	463b      	mov	r3, r7
 800326a:	f7fc ffbd 	bl	80001e8 <__aeabi_dsub>
 800326e:	a334      	add	r3, pc, #208	; (adr r3, 8003340 <__ieee754_rem_pio2+0x320>)
 8003270:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003274:	4606      	mov	r6, r0
 8003276:	460f      	mov	r7, r1
 8003278:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800327c:	f7fd f968 	bl	8000550 <__aeabi_dmul>
 8003280:	4632      	mov	r2, r6
 8003282:	463b      	mov	r3, r7
 8003284:	f7fc ffb0 	bl	80001e8 <__aeabi_dsub>
 8003288:	4606      	mov	r6, r0
 800328a:	460f      	mov	r7, r1
 800328c:	4632      	mov	r2, r6
 800328e:	463b      	mov	r3, r7
 8003290:	4620      	mov	r0, r4
 8003292:	4629      	mov	r1, r5
 8003294:	f7fc ffa8 	bl	80001e8 <__aeabi_dsub>
 8003298:	e9ca 0100 	strd	r0, r1, [sl]
 800329c:	e001      	b.n	80032a2 <__ieee754_rem_pio2+0x282>
 800329e:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
 80032a2:	ed9a 7b00 	vldr	d7, [sl]
 80032a6:	4620      	mov	r0, r4
 80032a8:	ec53 2b17 	vmov	r2, r3, d7
 80032ac:	4629      	mov	r1, r5
 80032ae:	ed8d 7b02 	vstr	d7, [sp, #8]
 80032b2:	f7fc ff99 	bl	80001e8 <__aeabi_dsub>
 80032b6:	4632      	mov	r2, r6
 80032b8:	463b      	mov	r3, r7
 80032ba:	f7fc ff95 	bl	80001e8 <__aeabi_dsub>
 80032be:	f1bb 0f00 	cmp.w	fp, #0
 80032c2:	e9ca 0102 	strd	r0, r1, [sl, #8]
 80032c6:	f280 80a0 	bge.w	800340a <__ieee754_rem_pio2+0x3ea>
 80032ca:	9b02      	ldr	r3, [sp, #8]
 80032cc:	f8ca 3000 	str.w	r3, [sl]
 80032d0:	9b03      	ldr	r3, [sp, #12]
 80032d2:	f8ca 0008 	str.w	r0, [sl, #8]
 80032d6:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 80032da:	f8ca 3004 	str.w	r3, [sl, #4]
 80032de:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 80032e2:	f8ca 300c 	str.w	r3, [sl, #12]
 80032e6:	f1c9 0000 	rsb	r0, r9, #0
 80032ea:	e08f      	b.n	800340c <__ieee754_rem_pio2+0x3ec>
 80032ec:	4b1c      	ldr	r3, [pc, #112]	; (8003360 <__ieee754_rem_pio2+0x340>)
 80032ee:	4598      	cmp	r8, r3
 80032f0:	dd38      	ble.n	8003364 <__ieee754_rem_pio2+0x344>
 80032f2:	ee10 2a10 	vmov	r2, s0
 80032f6:	462b      	mov	r3, r5
 80032f8:	4620      	mov	r0, r4
 80032fa:	4629      	mov	r1, r5
 80032fc:	f7fc ff74 	bl	80001e8 <__aeabi_dsub>
 8003300:	e9ca 0102 	strd	r0, r1, [sl, #8]
 8003304:	e9ca 0100 	strd	r0, r1, [sl]
 8003308:	2000      	movs	r0, #0
 800330a:	e07f      	b.n	800340c <__ieee754_rem_pio2+0x3ec>
 800330c:	f3af 8000 	nop.w
 8003310:	54400000 	.word	0x54400000
 8003314:	3ff921fb 	.word	0x3ff921fb
 8003318:	1a626331 	.word	0x1a626331
 800331c:	3dd0b461 	.word	0x3dd0b461
 8003320:	1a600000 	.word	0x1a600000
 8003324:	3dd0b461 	.word	0x3dd0b461
 8003328:	2e037073 	.word	0x2e037073
 800332c:	3ba3198a 	.word	0x3ba3198a
 8003330:	6dc9c883 	.word	0x6dc9c883
 8003334:	3fe45f30 	.word	0x3fe45f30
 8003338:	2e000000 	.word	0x2e000000
 800333c:	3ba3198a 	.word	0x3ba3198a
 8003340:	252049c1 	.word	0x252049c1
 8003344:	397b839a 	.word	0x397b839a
 8003348:	3fe921fb 	.word	0x3fe921fb
 800334c:	4002d97b 	.word	0x4002d97b
 8003350:	3ff921fb 	.word	0x3ff921fb
 8003354:	413921fb 	.word	0x413921fb
 8003358:	3fe00000 	.word	0x3fe00000
 800335c:	080045b4 	.word	0x080045b4
 8003360:	7fefffff 	.word	0x7fefffff
 8003364:	ea4f 5628 	mov.w	r6, r8, asr #20
 8003368:	f2a6 4616 	subw	r6, r6, #1046	; 0x416
 800336c:	eba8 5106 	sub.w	r1, r8, r6, lsl #20
 8003370:	4620      	mov	r0, r4
 8003372:	460d      	mov	r5, r1
 8003374:	f7fd fb86 	bl	8000a84 <__aeabi_d2iz>
 8003378:	f7fd f884 	bl	8000484 <__aeabi_i2d>
 800337c:	4602      	mov	r2, r0
 800337e:	460b      	mov	r3, r1
 8003380:	4620      	mov	r0, r4
 8003382:	4629      	mov	r1, r5
 8003384:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8003388:	f7fc ff2e 	bl	80001e8 <__aeabi_dsub>
 800338c:	2200      	movs	r2, #0
 800338e:	4b21      	ldr	r3, [pc, #132]	; (8003414 <__ieee754_rem_pio2+0x3f4>)
 8003390:	f7fd f8de 	bl	8000550 <__aeabi_dmul>
 8003394:	460d      	mov	r5, r1
 8003396:	4604      	mov	r4, r0
 8003398:	f7fd fb74 	bl	8000a84 <__aeabi_d2iz>
 800339c:	f7fd f872 	bl	8000484 <__aeabi_i2d>
 80033a0:	4602      	mov	r2, r0
 80033a2:	460b      	mov	r3, r1
 80033a4:	4620      	mov	r0, r4
 80033a6:	4629      	mov	r1, r5
 80033a8:	e9cd 2308 	strd	r2, r3, [sp, #32]
 80033ac:	f7fc ff1c 	bl	80001e8 <__aeabi_dsub>
 80033b0:	2200      	movs	r2, #0
 80033b2:	4b18      	ldr	r3, [pc, #96]	; (8003414 <__ieee754_rem_pio2+0x3f4>)
 80033b4:	f7fd f8cc 	bl	8000550 <__aeabi_dmul>
 80033b8:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
 80033bc:	ad0c      	add	r5, sp, #48	; 0x30
 80033be:	2403      	movs	r4, #3
 80033c0:	2200      	movs	r2, #0
 80033c2:	2300      	movs	r3, #0
 80033c4:	e975 0102 	ldrd	r0, r1, [r5, #-8]!
 80033c8:	1e67      	subs	r7, r4, #1
 80033ca:	f7fd fb29 	bl	8000a20 <__aeabi_dcmpeq>
 80033ce:	b108      	cbz	r0, 80033d4 <__ieee754_rem_pio2+0x3b4>
 80033d0:	463c      	mov	r4, r7
 80033d2:	e7f5      	b.n	80033c0 <__ieee754_rem_pio2+0x3a0>
 80033d4:	4b10      	ldr	r3, [pc, #64]	; (8003418 <__ieee754_rem_pio2+0x3f8>)
 80033d6:	9301      	str	r3, [sp, #4]
 80033d8:	2302      	movs	r3, #2
 80033da:	9300      	str	r3, [sp, #0]
 80033dc:	4632      	mov	r2, r6
 80033de:	4623      	mov	r3, r4
 80033e0:	4651      	mov	r1, sl
 80033e2:	a806      	add	r0, sp, #24
 80033e4:	f000 f904 	bl	80035f0 <__kernel_rem_pio2>
 80033e8:	f1bb 0f00 	cmp.w	fp, #0
 80033ec:	da0e      	bge.n	800340c <__ieee754_rem_pio2+0x3ec>
 80033ee:	f8da 3004 	ldr.w	r3, [sl, #4]
 80033f2:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 80033f6:	f8ca 3004 	str.w	r3, [sl, #4]
 80033fa:	f8da 300c 	ldr.w	r3, [sl, #12]
 80033fe:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8003402:	f8ca 300c 	str.w	r3, [sl, #12]
 8003406:	4240      	negs	r0, r0
 8003408:	e000      	b.n	800340c <__ieee754_rem_pio2+0x3ec>
 800340a:	4648      	mov	r0, r9
 800340c:	b00d      	add	sp, #52	; 0x34
 800340e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003412:	bf00      	nop
 8003414:	41700000 	.word	0x41700000
 8003418:	08004634 	.word	0x08004634
 800341c:	00000000 	.word	0x00000000

08003420 <__kernel_cos>:
 8003420:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003424:	ec59 8b10 	vmov	r8, r9, d0
 8003428:	f029 4700 	bic.w	r7, r9, #2147483648	; 0x80000000
 800342c:	b085      	sub	sp, #20
 800342e:	f1b7 5f79 	cmp.w	r7, #1044381696	; 0x3e400000
 8003432:	ed8d 1b00 	vstr	d1, [sp]
 8003436:	da07      	bge.n	8003448 <__kernel_cos+0x28>
 8003438:	ee10 0a10 	vmov	r0, s0
 800343c:	4649      	mov	r1, r9
 800343e:	f7fd fb21 	bl	8000a84 <__aeabi_d2iz>
 8003442:	2800      	cmp	r0, #0
 8003444:	f000 80a6 	beq.w	8003594 <__kernel_cos+0x174>
 8003448:	4642      	mov	r2, r8
 800344a:	464b      	mov	r3, r9
 800344c:	4640      	mov	r0, r8
 800344e:	4649      	mov	r1, r9
 8003450:	f7fd f87e 	bl	8000550 <__aeabi_dmul>
 8003454:	a359      	add	r3, pc, #356	; (adr r3, 80035bc <__kernel_cos+0x19c>)
 8003456:	e9d3 2300 	ldrd	r2, r3, [r3]
 800345a:	4604      	mov	r4, r0
 800345c:	460d      	mov	r5, r1
 800345e:	f7fd f877 	bl	8000550 <__aeabi_dmul>
 8003462:	a358      	add	r3, pc, #352	; (adr r3, 80035c4 <__kernel_cos+0x1a4>)
 8003464:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003468:	f7fc fec0 	bl	80001ec <__adddf3>
 800346c:	4622      	mov	r2, r4
 800346e:	462b      	mov	r3, r5
 8003470:	f7fd f86e 	bl	8000550 <__aeabi_dmul>
 8003474:	a355      	add	r3, pc, #340	; (adr r3, 80035cc <__kernel_cos+0x1ac>)
 8003476:	e9d3 2300 	ldrd	r2, r3, [r3]
 800347a:	f7fc feb5 	bl	80001e8 <__aeabi_dsub>
 800347e:	4622      	mov	r2, r4
 8003480:	462b      	mov	r3, r5
 8003482:	f7fd f865 	bl	8000550 <__aeabi_dmul>
 8003486:	a353      	add	r3, pc, #332	; (adr r3, 80035d4 <__kernel_cos+0x1b4>)
 8003488:	e9d3 2300 	ldrd	r2, r3, [r3]
 800348c:	f7fc feae 	bl	80001ec <__adddf3>
 8003490:	4622      	mov	r2, r4
 8003492:	462b      	mov	r3, r5
 8003494:	f7fd f85c 	bl	8000550 <__aeabi_dmul>
 8003498:	a350      	add	r3, pc, #320	; (adr r3, 80035dc <__kernel_cos+0x1bc>)
 800349a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800349e:	f7fc fea3 	bl	80001e8 <__aeabi_dsub>
 80034a2:	4622      	mov	r2, r4
 80034a4:	462b      	mov	r3, r5
 80034a6:	f7fd f853 	bl	8000550 <__aeabi_dmul>
 80034aa:	a34e      	add	r3, pc, #312	; (adr r3, 80035e4 <__kernel_cos+0x1c4>)
 80034ac:	e9d3 2300 	ldrd	r2, r3, [r3]
 80034b0:	f7fc fe9c 	bl	80001ec <__adddf3>
 80034b4:	462b      	mov	r3, r5
 80034b6:	4622      	mov	r2, r4
 80034b8:	f7fd f84a 	bl	8000550 <__aeabi_dmul>
 80034bc:	4b3a      	ldr	r3, [pc, #232]	; (80035a8 <__kernel_cos+0x188>)
 80034be:	429f      	cmp	r7, r3
 80034c0:	4682      	mov	sl, r0
 80034c2:	468b      	mov	fp, r1
 80034c4:	dc26      	bgt.n	8003514 <__kernel_cos+0xf4>
 80034c6:	2200      	movs	r2, #0
 80034c8:	4b38      	ldr	r3, [pc, #224]	; (80035ac <__kernel_cos+0x18c>)
 80034ca:	4620      	mov	r0, r4
 80034cc:	4629      	mov	r1, r5
 80034ce:	f7fd f83f 	bl	8000550 <__aeabi_dmul>
 80034d2:	4652      	mov	r2, sl
 80034d4:	4606      	mov	r6, r0
 80034d6:	460f      	mov	r7, r1
 80034d8:	465b      	mov	r3, fp
 80034da:	4620      	mov	r0, r4
 80034dc:	4629      	mov	r1, r5
 80034de:	f7fd f837 	bl	8000550 <__aeabi_dmul>
 80034e2:	e9dd 2300 	ldrd	r2, r3, [sp]
 80034e6:	4604      	mov	r4, r0
 80034e8:	460d      	mov	r5, r1
 80034ea:	4640      	mov	r0, r8
 80034ec:	4649      	mov	r1, r9
 80034ee:	f7fd f82f 	bl	8000550 <__aeabi_dmul>
 80034f2:	4602      	mov	r2, r0
 80034f4:	460b      	mov	r3, r1
 80034f6:	4620      	mov	r0, r4
 80034f8:	4629      	mov	r1, r5
 80034fa:	f7fc fe75 	bl	80001e8 <__aeabi_dsub>
 80034fe:	4602      	mov	r2, r0
 8003500:	460b      	mov	r3, r1
 8003502:	4630      	mov	r0, r6
 8003504:	4639      	mov	r1, r7
 8003506:	f7fc fe6f 	bl	80001e8 <__aeabi_dsub>
 800350a:	4602      	mov	r2, r0
 800350c:	460b      	mov	r3, r1
 800350e:	2000      	movs	r0, #0
 8003510:	4927      	ldr	r1, [pc, #156]	; (80035b0 <__kernel_cos+0x190>)
 8003512:	e03c      	b.n	800358e <__kernel_cos+0x16e>
 8003514:	4b27      	ldr	r3, [pc, #156]	; (80035b4 <__kernel_cos+0x194>)
 8003516:	4926      	ldr	r1, [pc, #152]	; (80035b0 <__kernel_cos+0x190>)
 8003518:	429f      	cmp	r7, r3
 800351a:	bfd7      	itett	le
 800351c:	f5a7 1300 	suble.w	r3, r7, #2097152	; 0x200000
 8003520:	4f25      	ldrgt	r7, [pc, #148]	; (80035b8 <__kernel_cos+0x198>)
 8003522:	2200      	movle	r2, #0
 8003524:	4616      	movle	r6, r2
 8003526:	bfd4      	ite	le
 8003528:	461f      	movle	r7, r3
 800352a:	2600      	movgt	r6, #0
 800352c:	4632      	mov	r2, r6
 800352e:	463b      	mov	r3, r7
 8003530:	2000      	movs	r0, #0
 8003532:	f7fc fe59 	bl	80001e8 <__aeabi_dsub>
 8003536:	2200      	movs	r2, #0
 8003538:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800353c:	4b1b      	ldr	r3, [pc, #108]	; (80035ac <__kernel_cos+0x18c>)
 800353e:	4620      	mov	r0, r4
 8003540:	4629      	mov	r1, r5
 8003542:	f7fd f805 	bl	8000550 <__aeabi_dmul>
 8003546:	4632      	mov	r2, r6
 8003548:	463b      	mov	r3, r7
 800354a:	f7fc fe4d 	bl	80001e8 <__aeabi_dsub>
 800354e:	4652      	mov	r2, sl
 8003550:	4606      	mov	r6, r0
 8003552:	460f      	mov	r7, r1
 8003554:	465b      	mov	r3, fp
 8003556:	4620      	mov	r0, r4
 8003558:	4629      	mov	r1, r5
 800355a:	f7fc fff9 	bl	8000550 <__aeabi_dmul>
 800355e:	e9dd 2300 	ldrd	r2, r3, [sp]
 8003562:	4604      	mov	r4, r0
 8003564:	460d      	mov	r5, r1
 8003566:	4640      	mov	r0, r8
 8003568:	4649      	mov	r1, r9
 800356a:	f7fc fff1 	bl	8000550 <__aeabi_dmul>
 800356e:	4602      	mov	r2, r0
 8003570:	460b      	mov	r3, r1
 8003572:	4620      	mov	r0, r4
 8003574:	4629      	mov	r1, r5
 8003576:	f7fc fe37 	bl	80001e8 <__aeabi_dsub>
 800357a:	4602      	mov	r2, r0
 800357c:	460b      	mov	r3, r1
 800357e:	4630      	mov	r0, r6
 8003580:	4639      	mov	r1, r7
 8003582:	f7fc fe31 	bl	80001e8 <__aeabi_dsub>
 8003586:	4602      	mov	r2, r0
 8003588:	460b      	mov	r3, r1
 800358a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800358e:	f7fc fe2b 	bl	80001e8 <__aeabi_dsub>
 8003592:	e001      	b.n	8003598 <__kernel_cos+0x178>
 8003594:	4906      	ldr	r1, [pc, #24]	; (80035b0 <__kernel_cos+0x190>)
 8003596:	2000      	movs	r0, #0
 8003598:	ec41 0b10 	vmov	d0, r0, r1
 800359c:	b005      	add	sp, #20
 800359e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80035a2:	bf00      	nop
 80035a4:	f3af 8000 	nop.w
 80035a8:	3fd33332 	.word	0x3fd33332
 80035ac:	3fe00000 	.word	0x3fe00000
 80035b0:	3ff00000 	.word	0x3ff00000
 80035b4:	3fe90000 	.word	0x3fe90000
 80035b8:	3fd20000 	.word	0x3fd20000
 80035bc:	be8838d4 	.word	0xbe8838d4
 80035c0:	bda8fae9 	.word	0xbda8fae9
 80035c4:	bdb4b1c4 	.word	0xbdb4b1c4
 80035c8:	3e21ee9e 	.word	0x3e21ee9e
 80035cc:	809c52ad 	.word	0x809c52ad
 80035d0:	3e927e4f 	.word	0x3e927e4f
 80035d4:	19cb1590 	.word	0x19cb1590
 80035d8:	3efa01a0 	.word	0x3efa01a0
 80035dc:	16c15177 	.word	0x16c15177
 80035e0:	3f56c16c 	.word	0x3f56c16c
 80035e4:	5555554c 	.word	0x5555554c
 80035e8:	3fa55555 	.word	0x3fa55555
 80035ec:	00000000 	.word	0x00000000

080035f0 <__kernel_rem_pio2>:
 80035f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80035f4:	f5ad 7d19 	sub.w	sp, sp, #612	; 0x264
 80035f8:	2418      	movs	r4, #24
 80035fa:	9306      	str	r3, [sp, #24]
 80035fc:	9101      	str	r1, [sp, #4]
 80035fe:	4bba      	ldr	r3, [pc, #744]	; (80038e8 <__kernel_rem_pio2+0x2f8>)
 8003600:	99a2      	ldr	r1, [sp, #648]	; 0x288
 8003602:	9009      	str	r0, [sp, #36]	; 0x24
 8003604:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8003608:	9302      	str	r3, [sp, #8]
 800360a:	9b06      	ldr	r3, [sp, #24]
 800360c:	3b01      	subs	r3, #1
 800360e:	9305      	str	r3, [sp, #20]
 8003610:	1ed3      	subs	r3, r2, #3
 8003612:	fb93 f4f4 	sdiv	r4, r3, r4
 8003616:	f06f 0317 	mvn.w	r3, #23
 800361a:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
 800361e:	fb04 3303 	mla	r3, r4, r3, r3
 8003622:	eb03 0802 	add.w	r8, r3, r2
 8003626:	9b02      	ldr	r3, [sp, #8]
 8003628:	9a05      	ldr	r2, [sp, #20]
 800362a:	eb03 0a02 	add.w	sl, r3, r2
 800362e:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
 8003630:	1aa7      	subs	r7, r4, r2
 8003632:	ae20      	add	r6, sp, #128	; 0x80
 8003634:	eb03 0987 	add.w	r9, r3, r7, lsl #2
 8003638:	2500      	movs	r5, #0
 800363a:	4555      	cmp	r5, sl
 800363c:	dc0c      	bgt.n	8003658 <__kernel_rem_pio2+0x68>
 800363e:	42ef      	cmn	r7, r5
 8003640:	d404      	bmi.n	800364c <__kernel_rem_pio2+0x5c>
 8003642:	f859 0025 	ldr.w	r0, [r9, r5, lsl #2]
 8003646:	f7fc ff1d 	bl	8000484 <__aeabi_i2d>
 800364a:	e001      	b.n	8003650 <__kernel_rem_pio2+0x60>
 800364c:	2000      	movs	r0, #0
 800364e:	2100      	movs	r1, #0
 8003650:	e8e6 0102 	strd	r0, r1, [r6], #8
 8003654:	3501      	adds	r5, #1
 8003656:	e7f0      	b.n	800363a <__kernel_rem_pio2+0x4a>
 8003658:	f50d 7be0 	add.w	fp, sp, #448	; 0x1c0
 800365c:	2600      	movs	r6, #0
 800365e:	9b02      	ldr	r3, [sp, #8]
 8003660:	429e      	cmp	r6, r3
 8003662:	dc27      	bgt.n	80036b4 <__kernel_rem_pio2+0xc4>
 8003664:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003666:	9304      	str	r3, [sp, #16]
 8003668:	9b06      	ldr	r3, [sp, #24]
 800366a:	199d      	adds	r5, r3, r6
 800366c:	ab20      	add	r3, sp, #128	; 0x80
 800366e:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 8003672:	9308      	str	r3, [sp, #32]
 8003674:	f04f 0900 	mov.w	r9, #0
 8003678:	f04f 0a00 	mov.w	sl, #0
 800367c:	2700      	movs	r7, #0
 800367e:	9b05      	ldr	r3, [sp, #20]
 8003680:	429f      	cmp	r7, r3
 8003682:	dc13      	bgt.n	80036ac <__kernel_rem_pio2+0xbc>
 8003684:	9908      	ldr	r1, [sp, #32]
 8003686:	9d04      	ldr	r5, [sp, #16]
 8003688:	e971 2302 	ldrd	r2, r3, [r1, #-8]!
 800368c:	9108      	str	r1, [sp, #32]
 800368e:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 8003692:	9504      	str	r5, [sp, #16]
 8003694:	f7fc ff5c 	bl	8000550 <__aeabi_dmul>
 8003698:	4602      	mov	r2, r0
 800369a:	460b      	mov	r3, r1
 800369c:	4648      	mov	r0, r9
 800369e:	4651      	mov	r1, sl
 80036a0:	f7fc fda4 	bl	80001ec <__adddf3>
 80036a4:	3701      	adds	r7, #1
 80036a6:	4681      	mov	r9, r0
 80036a8:	468a      	mov	sl, r1
 80036aa:	e7e8      	b.n	800367e <__kernel_rem_pio2+0x8e>
 80036ac:	e8ab 0600 	stmia.w	fp!, {r9, sl}
 80036b0:	3601      	adds	r6, #1
 80036b2:	e7d4      	b.n	800365e <__kernel_rem_pio2+0x6e>
 80036b4:	9b02      	ldr	r3, [sp, #8]
 80036b6:	f8dd b008 	ldr.w	fp, [sp, #8]
 80036ba:	aa0c      	add	r2, sp, #48	; 0x30
 80036bc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80036c0:	930a      	str	r3, [sp, #40]	; 0x28
 80036c2:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
 80036c4:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 80036c8:	930b      	str	r3, [sp, #44]	; 0x2c
 80036ca:	ab98      	add	r3, sp, #608	; 0x260
 80036cc:	f10b 5a00 	add.w	sl, fp, #536870912	; 0x20000000
 80036d0:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 80036d4:	f10a 3aff 	add.w	sl, sl, #4294967295
 80036d8:	e953 6728 	ldrd	r6, r7, [r3, #-160]	; 0xa0
 80036dc:	aa98      	add	r2, sp, #608	; 0x260
 80036de:	ea4f 03ca 	mov.w	r3, sl, lsl #3
 80036e2:	eb02 0903 	add.w	r9, r2, r3
 80036e6:	9308      	str	r3, [sp, #32]
 80036e8:	f1a9 0998 	sub.w	r9, r9, #152	; 0x98
 80036ec:	f04f 0a00 	mov.w	sl, #0
 80036f0:	ebca 030b 	rsb	r3, sl, fp
 80036f4:	2b00      	cmp	r3, #0
 80036f6:	dd25      	ble.n	8003744 <__kernel_rem_pio2+0x154>
 80036f8:	2200      	movs	r2, #0
 80036fa:	4b7c      	ldr	r3, [pc, #496]	; (80038ec <__kernel_rem_pio2+0x2fc>)
 80036fc:	4630      	mov	r0, r6
 80036fe:	4639      	mov	r1, r7
 8003700:	f7fc ff26 	bl	8000550 <__aeabi_dmul>
 8003704:	f7fd f9be 	bl	8000a84 <__aeabi_d2iz>
 8003708:	f7fc febc 	bl	8000484 <__aeabi_i2d>
 800370c:	2200      	movs	r2, #0
 800370e:	4b78      	ldr	r3, [pc, #480]	; (80038f0 <__kernel_rem_pio2+0x300>)
 8003710:	4604      	mov	r4, r0
 8003712:	460d      	mov	r5, r1
 8003714:	f7fc ff1c 	bl	8000550 <__aeabi_dmul>
 8003718:	4602      	mov	r2, r0
 800371a:	460b      	mov	r3, r1
 800371c:	4630      	mov	r0, r6
 800371e:	4639      	mov	r1, r7
 8003720:	f7fc fd62 	bl	80001e8 <__aeabi_dsub>
 8003724:	f7fd f9ae 	bl	8000a84 <__aeabi_d2iz>
 8003728:	ab0c      	add	r3, sp, #48	; 0x30
 800372a:	4629      	mov	r1, r5
 800372c:	f843 002a 	str.w	r0, [r3, sl, lsl #2]
 8003730:	e979 2302 	ldrd	r2, r3, [r9, #-8]!
 8003734:	4620      	mov	r0, r4
 8003736:	f7fc fd59 	bl	80001ec <__adddf3>
 800373a:	f10a 0a01 	add.w	sl, sl, #1
 800373e:	4606      	mov	r6, r0
 8003740:	460f      	mov	r7, r1
 8003742:	e7d5      	b.n	80036f0 <__kernel_rem_pio2+0x100>
 8003744:	ec47 6b10 	vmov	d0, r6, r7
 8003748:	4640      	mov	r0, r8
 800374a:	f000 fbe9 	bl	8003f20 <scalbn>
 800374e:	ec55 4b10 	vmov	r4, r5, d0
 8003752:	2200      	movs	r2, #0
 8003754:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
 8003758:	ee10 0a10 	vmov	r0, s0
 800375c:	4629      	mov	r1, r5
 800375e:	f7fc fef7 	bl	8000550 <__aeabi_dmul>
 8003762:	ec41 0b10 	vmov	d0, r0, r1
 8003766:	f000 fb57 	bl	8003e18 <floor>
 800376a:	2200      	movs	r2, #0
 800376c:	ec51 0b10 	vmov	r0, r1, d0
 8003770:	4b60      	ldr	r3, [pc, #384]	; (80038f4 <__kernel_rem_pio2+0x304>)
 8003772:	f7fc feed 	bl	8000550 <__aeabi_dmul>
 8003776:	4602      	mov	r2, r0
 8003778:	460b      	mov	r3, r1
 800377a:	4620      	mov	r0, r4
 800377c:	4629      	mov	r1, r5
 800377e:	f7fc fd33 	bl	80001e8 <__aeabi_dsub>
 8003782:	460d      	mov	r5, r1
 8003784:	4604      	mov	r4, r0
 8003786:	f7fd f97d 	bl	8000a84 <__aeabi_d2iz>
 800378a:	9004      	str	r0, [sp, #16]
 800378c:	f7fc fe7a 	bl	8000484 <__aeabi_i2d>
 8003790:	4602      	mov	r2, r0
 8003792:	460b      	mov	r3, r1
 8003794:	4620      	mov	r0, r4
 8003796:	4629      	mov	r1, r5
 8003798:	f7fc fd26 	bl	80001e8 <__aeabi_dsub>
 800379c:	f1b8 0f00 	cmp.w	r8, #0
 80037a0:	4606      	mov	r6, r0
 80037a2:	460f      	mov	r7, r1
 80037a4:	dd15      	ble.n	80037d2 <__kernel_rem_pio2+0x1e2>
 80037a6:	f10b 31ff 	add.w	r1, fp, #4294967295
 80037aa:	ab0c      	add	r3, sp, #48	; 0x30
 80037ac:	f1c8 0018 	rsb	r0, r8, #24
 80037b0:	f853 2021 	ldr.w	r2, [r3, r1, lsl #2]
 80037b4:	9c04      	ldr	r4, [sp, #16]
 80037b6:	fa42 f300 	asr.w	r3, r2, r0
 80037ba:	441c      	add	r4, r3
 80037bc:	4083      	lsls	r3, r0
 80037be:	1ad3      	subs	r3, r2, r3
 80037c0:	aa0c      	add	r2, sp, #48	; 0x30
 80037c2:	f1c8 0017 	rsb	r0, r8, #23
 80037c6:	9404      	str	r4, [sp, #16]
 80037c8:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 80037cc:	fa43 fa00 	asr.w	sl, r3, r0
 80037d0:	e00f      	b.n	80037f2 <__kernel_rem_pio2+0x202>
 80037d2:	d107      	bne.n	80037e4 <__kernel_rem_pio2+0x1f4>
 80037d4:	f10b 33ff 	add.w	r3, fp, #4294967295
 80037d8:	aa0c      	add	r2, sp, #48	; 0x30
 80037da:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 80037de:	ea4f 5ae0 	mov.w	sl, r0, asr #23
 80037e2:	e006      	b.n	80037f2 <__kernel_rem_pio2+0x202>
 80037e4:	2200      	movs	r2, #0
 80037e6:	4b44      	ldr	r3, [pc, #272]	; (80038f8 <__kernel_rem_pio2+0x308>)
 80037e8:	f7fd f938 	bl	8000a5c <__aeabi_dcmpge>
 80037ec:	b928      	cbnz	r0, 80037fa <__kernel_rem_pio2+0x20a>
 80037ee:	4682      	mov	sl, r0
 80037f0:	e052      	b.n	8003898 <__kernel_rem_pio2+0x2a8>
 80037f2:	f1ba 0f00 	cmp.w	sl, #0
 80037f6:	dc02      	bgt.n	80037fe <__kernel_rem_pio2+0x20e>
 80037f8:	e04e      	b.n	8003898 <__kernel_rem_pio2+0x2a8>
 80037fa:	f04f 0a02 	mov.w	sl, #2
 80037fe:	9b04      	ldr	r3, [sp, #16]
 8003800:	2200      	movs	r2, #0
 8003802:	3301      	adds	r3, #1
 8003804:	9304      	str	r3, [sp, #16]
 8003806:	4614      	mov	r4, r2
 8003808:	4593      	cmp	fp, r2
 800380a:	dd11      	ble.n	8003830 <__kernel_rem_pio2+0x240>
 800380c:	ab0c      	add	r3, sp, #48	; 0x30
 800380e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8003812:	b91c      	cbnz	r4, 800381c <__kernel_rem_pio2+0x22c>
 8003814:	b153      	cbz	r3, 800382c <__kernel_rem_pio2+0x23c>
 8003816:	f1c3 7380 	rsb	r3, r3, #16777216	; 0x1000000
 800381a:	e003      	b.n	8003824 <__kernel_rem_pio2+0x234>
 800381c:	f1c3 13ff 	rsb	r3, r3, #16711935	; 0xff00ff
 8003820:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
 8003824:	a90c      	add	r1, sp, #48	; 0x30
 8003826:	2401      	movs	r4, #1
 8003828:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
 800382c:	3201      	adds	r2, #1
 800382e:	e7eb      	b.n	8003808 <__kernel_rem_pio2+0x218>
 8003830:	f1b8 0f00 	cmp.w	r8, #0
 8003834:	dd17      	ble.n	8003866 <__kernel_rem_pio2+0x276>
 8003836:	f1b8 0f01 	cmp.w	r8, #1
 800383a:	d00a      	beq.n	8003852 <__kernel_rem_pio2+0x262>
 800383c:	f1b8 0f02 	cmp.w	r8, #2
 8003840:	d111      	bne.n	8003866 <__kernel_rem_pio2+0x276>
 8003842:	f10b 32ff 	add.w	r2, fp, #4294967295
 8003846:	ab0c      	add	r3, sp, #48	; 0x30
 8003848:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800384c:	f3c3 0315 	ubfx	r3, r3, #0, #22
 8003850:	e006      	b.n	8003860 <__kernel_rem_pio2+0x270>
 8003852:	f10b 32ff 	add.w	r2, fp, #4294967295
 8003856:	ab0c      	add	r3, sp, #48	; 0x30
 8003858:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800385c:	f3c3 0316 	ubfx	r3, r3, #0, #23
 8003860:	a90c      	add	r1, sp, #48	; 0x30
 8003862:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
 8003866:	f1ba 0f02 	cmp.w	sl, #2
 800386a:	d115      	bne.n	8003898 <__kernel_rem_pio2+0x2a8>
 800386c:	4632      	mov	r2, r6
 800386e:	463b      	mov	r3, r7
 8003870:	2000      	movs	r0, #0
 8003872:	4922      	ldr	r1, [pc, #136]	; (80038fc <__kernel_rem_pio2+0x30c>)
 8003874:	f7fc fcb8 	bl	80001e8 <__aeabi_dsub>
 8003878:	4606      	mov	r6, r0
 800387a:	460f      	mov	r7, r1
 800387c:	b164      	cbz	r4, 8003898 <__kernel_rem_pio2+0x2a8>
 800387e:	4640      	mov	r0, r8
 8003880:	ed9f 0b17 	vldr	d0, [pc, #92]	; 80038e0 <__kernel_rem_pio2+0x2f0>
 8003884:	f000 fb4c 	bl	8003f20 <scalbn>
 8003888:	4630      	mov	r0, r6
 800388a:	4639      	mov	r1, r7
 800388c:	ec53 2b10 	vmov	r2, r3, d0
 8003890:	f7fc fcaa 	bl	80001e8 <__aeabi_dsub>
 8003894:	4606      	mov	r6, r0
 8003896:	460f      	mov	r7, r1
 8003898:	2200      	movs	r2, #0
 800389a:	2300      	movs	r3, #0
 800389c:	4630      	mov	r0, r6
 800389e:	4639      	mov	r1, r7
 80038a0:	f7fd f8be 	bl	8000a20 <__aeabi_dcmpeq>
 80038a4:	2800      	cmp	r0, #0
 80038a6:	d074      	beq.n	8003992 <__kernel_rem_pio2+0x3a2>
 80038a8:	f10b 31ff 	add.w	r1, fp, #4294967295
 80038ac:	460b      	mov	r3, r1
 80038ae:	2200      	movs	r2, #0
 80038b0:	9802      	ldr	r0, [sp, #8]
 80038b2:	4283      	cmp	r3, r0
 80038b4:	db05      	blt.n	80038c2 <__kernel_rem_pio2+0x2d2>
 80038b6:	a80c      	add	r0, sp, #48	; 0x30
 80038b8:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 80038bc:	3b01      	subs	r3, #1
 80038be:	4302      	orrs	r2, r0
 80038c0:	e7f6      	b.n	80038b0 <__kernel_rem_pio2+0x2c0>
 80038c2:	2a00      	cmp	r2, #0
 80038c4:	d158      	bne.n	8003978 <__kernel_rem_pio2+0x388>
 80038c6:	2301      	movs	r3, #1
 80038c8:	f06f 0103 	mvn.w	r1, #3
 80038cc:	fb01 f203 	mul.w	r2, r1, r3
 80038d0:	980a      	ldr	r0, [sp, #40]	; 0x28
 80038d2:	5882      	ldr	r2, [r0, r2]
 80038d4:	b9a2      	cbnz	r2, 8003900 <__kernel_rem_pio2+0x310>
 80038d6:	3301      	adds	r3, #1
 80038d8:	e7f8      	b.n	80038cc <__kernel_rem_pio2+0x2dc>
 80038da:	bf00      	nop
 80038dc:	f3af 8000 	nop.w
 80038e0:	00000000 	.word	0x00000000
 80038e4:	3ff00000 	.word	0x3ff00000
 80038e8:	0800473c 	.word	0x0800473c
 80038ec:	3e700000 	.word	0x3e700000
 80038f0:	41700000 	.word	0x41700000
 80038f4:	40200000 	.word	0x40200000
 80038f8:	3fe00000 	.word	0x3fe00000
 80038fc:	3ff00000 	.word	0x3ff00000
 8003900:	9a08      	ldr	r2, [sp, #32]
 8003902:	a998      	add	r1, sp, #608	; 0x260
 8003904:	440a      	add	r2, r1
 8003906:	3a98      	subs	r2, #152	; 0x98
 8003908:	9204      	str	r2, [sp, #16]
 800390a:	9a06      	ldr	r2, [sp, #24]
 800390c:	445b      	add	r3, fp
 800390e:	eb02 050b 	add.w	r5, r2, fp
 8003912:	aa20      	add	r2, sp, #128	; 0x80
 8003914:	f10b 0601 	add.w	r6, fp, #1
 8003918:	eb02 05c5 	add.w	r5, r2, r5, lsl #3
 800391c:	9308      	str	r3, [sp, #32]
 800391e:	9b08      	ldr	r3, [sp, #32]
 8003920:	429e      	cmp	r6, r3
 8003922:	dc27      	bgt.n	8003974 <__kernel_rem_pio2+0x384>
 8003924:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8003926:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
 800392a:	f7fc fdab 	bl	8000484 <__aeabi_i2d>
 800392e:	e8e5 0102 	strd	r0, r1, [r5], #8
 8003932:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003934:	46a9      	mov	r9, r5
 8003936:	461c      	mov	r4, r3
 8003938:	2700      	movs	r7, #0
 800393a:	f04f 0a00 	mov.w	sl, #0
 800393e:	f04f 0b00 	mov.w	fp, #0
 8003942:	9b05      	ldr	r3, [sp, #20]
 8003944:	429f      	cmp	r7, r3
 8003946:	dc0f      	bgt.n	8003968 <__kernel_rem_pio2+0x378>
 8003948:	e979 2302 	ldrd	r2, r3, [r9, #-8]!
 800394c:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 8003950:	f7fc fdfe 	bl	8000550 <__aeabi_dmul>
 8003954:	4602      	mov	r2, r0
 8003956:	460b      	mov	r3, r1
 8003958:	4650      	mov	r0, sl
 800395a:	4659      	mov	r1, fp
 800395c:	f7fc fc46 	bl	80001ec <__adddf3>
 8003960:	3701      	adds	r7, #1
 8003962:	4682      	mov	sl, r0
 8003964:	468b      	mov	fp, r1
 8003966:	e7ec      	b.n	8003942 <__kernel_rem_pio2+0x352>
 8003968:	9b04      	ldr	r3, [sp, #16]
 800396a:	e9e3 ab02 	strd	sl, fp, [r3, #8]!
 800396e:	3601      	adds	r6, #1
 8003970:	9304      	str	r3, [sp, #16]
 8003972:	e7d4      	b.n	800391e <__kernel_rem_pio2+0x32e>
 8003974:	469b      	mov	fp, r3
 8003976:	e6a8      	b.n	80036ca <__kernel_rem_pio2+0xda>
 8003978:	f1a8 0818 	sub.w	r8, r8, #24
 800397c:	468b      	mov	fp, r1
 800397e:	ab0c      	add	r3, sp, #48	; 0x30
 8003980:	f853 302b 	ldr.w	r3, [r3, fp, lsl #2]
 8003984:	2b00      	cmp	r3, #0
 8003986:	d13c      	bne.n	8003a02 <__kernel_rem_pio2+0x412>
 8003988:	f10b 3bff 	add.w	fp, fp, #4294967295
 800398c:	f1a8 0818 	sub.w	r8, r8, #24
 8003990:	e7f5      	b.n	800397e <__kernel_rem_pio2+0x38e>
 8003992:	f1c8 0000 	rsb	r0, r8, #0
 8003996:	ec47 6b10 	vmov	d0, r6, r7
 800399a:	f000 fac1 	bl	8003f20 <scalbn>
 800399e:	ec55 4b10 	vmov	r4, r5, d0
 80039a2:	2200      	movs	r2, #0
 80039a4:	4bb6      	ldr	r3, [pc, #728]	; (8003c80 <__kernel_rem_pio2+0x690>)
 80039a6:	ee10 0a10 	vmov	r0, s0
 80039aa:	4629      	mov	r1, r5
 80039ac:	f7fd f856 	bl	8000a5c <__aeabi_dcmpge>
 80039b0:	b300      	cbz	r0, 80039f4 <__kernel_rem_pio2+0x404>
 80039b2:	2200      	movs	r2, #0
 80039b4:	4bb3      	ldr	r3, [pc, #716]	; (8003c84 <__kernel_rem_pio2+0x694>)
 80039b6:	4620      	mov	r0, r4
 80039b8:	4629      	mov	r1, r5
 80039ba:	f7fc fdc9 	bl	8000550 <__aeabi_dmul>
 80039be:	f7fd f861 	bl	8000a84 <__aeabi_d2iz>
 80039c2:	4606      	mov	r6, r0
 80039c4:	f7fc fd5e 	bl	8000484 <__aeabi_i2d>
 80039c8:	2200      	movs	r2, #0
 80039ca:	4bad      	ldr	r3, [pc, #692]	; (8003c80 <__kernel_rem_pio2+0x690>)
 80039cc:	f7fc fdc0 	bl	8000550 <__aeabi_dmul>
 80039d0:	460b      	mov	r3, r1
 80039d2:	4602      	mov	r2, r0
 80039d4:	4629      	mov	r1, r5
 80039d6:	4620      	mov	r0, r4
 80039d8:	f7fc fc06 	bl	80001e8 <__aeabi_dsub>
 80039dc:	f7fd f852 	bl	8000a84 <__aeabi_d2iz>
 80039e0:	ab0c      	add	r3, sp, #48	; 0x30
 80039e2:	f108 0818 	add.w	r8, r8, #24
 80039e6:	f843 002b 	str.w	r0, [r3, fp, lsl #2]
 80039ea:	f10b 0b01 	add.w	fp, fp, #1
 80039ee:	f843 602b 	str.w	r6, [r3, fp, lsl #2]
 80039f2:	e006      	b.n	8003a02 <__kernel_rem_pio2+0x412>
 80039f4:	4620      	mov	r0, r4
 80039f6:	4629      	mov	r1, r5
 80039f8:	f7fd f844 	bl	8000a84 <__aeabi_d2iz>
 80039fc:	ab0c      	add	r3, sp, #48	; 0x30
 80039fe:	f843 002b 	str.w	r0, [r3, fp, lsl #2]
 8003a02:	4640      	mov	r0, r8
 8003a04:	ed9f 0b9a 	vldr	d0, [pc, #616]	; 8003c70 <__kernel_rem_pio2+0x680>
 8003a08:	f000 fa8a 	bl	8003f20 <scalbn>
 8003a0c:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8003a10:	9305      	str	r3, [sp, #20]
 8003a12:	9a05      	ldr	r2, [sp, #20]
 8003a14:	ab98      	add	r3, sp, #608	; 0x260
 8003a16:	189f      	adds	r7, r3, r2
 8003a18:	ec55 4b10 	vmov	r4, r5, d0
 8003a1c:	3f98      	subs	r7, #152	; 0x98
 8003a1e:	465e      	mov	r6, fp
 8003a20:	2e00      	cmp	r6, #0
 8003a22:	db14      	blt.n	8003a4e <__kernel_rem_pio2+0x45e>
 8003a24:	ab0c      	add	r3, sp, #48	; 0x30
 8003a26:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
 8003a2a:	f7fc fd2b 	bl	8000484 <__aeabi_i2d>
 8003a2e:	4622      	mov	r2, r4
 8003a30:	462b      	mov	r3, r5
 8003a32:	f7fc fd8d 	bl	8000550 <__aeabi_dmul>
 8003a36:	2200      	movs	r2, #0
 8003a38:	e967 0102 	strd	r0, r1, [r7, #-8]!
 8003a3c:	4b91      	ldr	r3, [pc, #580]	; (8003c84 <__kernel_rem_pio2+0x694>)
 8003a3e:	4620      	mov	r0, r4
 8003a40:	4629      	mov	r1, r5
 8003a42:	f7fc fd85 	bl	8000550 <__aeabi_dmul>
 8003a46:	3e01      	subs	r6, #1
 8003a48:	4604      	mov	r4, r0
 8003a4a:	460d      	mov	r5, r1
 8003a4c:	e7e8      	b.n	8003a20 <__kernel_rem_pio2+0x430>
 8003a4e:	f50d 7890 	add.w	r8, sp, #288	; 0x120
 8003a52:	2400      	movs	r4, #0
 8003a54:	4645      	mov	r5, r8
 8003a56:	ebbb 0704 	subs.w	r7, fp, r4
 8003a5a:	d424      	bmi.n	8003aa6 <__kernel_rem_pio2+0x4b6>
 8003a5c:	ed9f 7b86 	vldr	d7, [pc, #536]	; 8003c78 <__kernel_rem_pio2+0x688>
 8003a60:	ed8d 7b06 	vstr	d7, [sp, #24]
 8003a64:	ab70      	add	r3, sp, #448	; 0x1c0
 8003a66:	f8df 9220 	ldr.w	r9, [pc, #544]	; 8003c88 <__kernel_rem_pio2+0x698>
 8003a6a:	eb03 07c7 	add.w	r7, r3, r7, lsl #3
 8003a6e:	2600      	movs	r6, #0
 8003a70:	9b02      	ldr	r3, [sp, #8]
 8003a72:	429e      	cmp	r6, r3
 8003a74:	dc11      	bgt.n	8003a9a <__kernel_rem_pio2+0x4aa>
 8003a76:	42a6      	cmp	r6, r4
 8003a78:	dc0f      	bgt.n	8003a9a <__kernel_rem_pio2+0x4aa>
 8003a7a:	e8f7 2302 	ldrd	r2, r3, [r7], #8
 8003a7e:	e8f9 0102 	ldrd	r0, r1, [r9], #8
 8003a82:	f7fc fd65 	bl	8000550 <__aeabi_dmul>
 8003a86:	4602      	mov	r2, r0
 8003a88:	460b      	mov	r3, r1
 8003a8a:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8003a8e:	f7fc fbad 	bl	80001ec <__adddf3>
 8003a92:	3601      	adds	r6, #1
 8003a94:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8003a98:	e7ea      	b.n	8003a70 <__kernel_rem_pio2+0x480>
 8003a9a:	ed9d 7b06 	vldr	d7, [sp, #24]
 8003a9e:	3401      	adds	r4, #1
 8003aa0:	eca8 7b02 	vstmia	r8!, {d7}
 8003aa4:	e7d7      	b.n	8003a56 <__kernel_rem_pio2+0x466>
 8003aa6:	9ba2      	ldr	r3, [sp, #648]	; 0x288
 8003aa8:	2b03      	cmp	r3, #3
 8003aaa:	f200 80d8 	bhi.w	8003c5e <__kernel_rem_pio2+0x66e>
 8003aae:	e8df f003 	tbb	[pc, r3]
 8003ab2:	0810      	.short	0x0810
 8003ab4:	0208      	.short	0x0208
 8003ab6:	9a05      	ldr	r2, [sp, #20]
 8003ab8:	ab48      	add	r3, sp, #288	; 0x120
 8003aba:	189c      	adds	r4, r3, r2
 8003abc:	46a0      	mov	r8, r4
 8003abe:	46d9      	mov	r9, fp
 8003ac0:	e056      	b.n	8003b70 <__kernel_rem_pio2+0x580>
 8003ac2:	9c05      	ldr	r4, [sp, #20]
 8003ac4:	ab48      	add	r3, sp, #288	; 0x120
 8003ac6:	3408      	adds	r4, #8
 8003ac8:	441c      	add	r4, r3
 8003aca:	465d      	mov	r5, fp
 8003acc:	2000      	movs	r0, #0
 8003ace:	2100      	movs	r1, #0
 8003ad0:	e01d      	b.n	8003b0e <__kernel_rem_pio2+0x51e>
 8003ad2:	9b05      	ldr	r3, [sp, #20]
 8003ad4:	aa98      	add	r2, sp, #608	; 0x260
 8003ad6:	4413      	add	r3, r2
 8003ad8:	f5a3 749c 	sub.w	r4, r3, #312	; 0x138
 8003adc:	2000      	movs	r0, #0
 8003ade:	2100      	movs	r1, #0
 8003ae0:	f1bb 0f00 	cmp.w	fp, #0
 8003ae4:	db06      	blt.n	8003af4 <__kernel_rem_pio2+0x504>
 8003ae6:	e974 2302 	ldrd	r2, r3, [r4, #-8]!
 8003aea:	f7fc fb7f 	bl	80001ec <__adddf3>
 8003aee:	f10b 3bff 	add.w	fp, fp, #4294967295
 8003af2:	e7f5      	b.n	8003ae0 <__kernel_rem_pio2+0x4f0>
 8003af4:	f1ba 0f00 	cmp.w	sl, #0
 8003af8:	d003      	beq.n	8003b02 <__kernel_rem_pio2+0x512>
 8003afa:	4602      	mov	r2, r0
 8003afc:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8003b00:	e001      	b.n	8003b06 <__kernel_rem_pio2+0x516>
 8003b02:	4602      	mov	r2, r0
 8003b04:	460b      	mov	r3, r1
 8003b06:	9901      	ldr	r1, [sp, #4]
 8003b08:	e9c1 2300 	strd	r2, r3, [r1]
 8003b0c:	e0a7      	b.n	8003c5e <__kernel_rem_pio2+0x66e>
 8003b0e:	2d00      	cmp	r5, #0
 8003b10:	db05      	blt.n	8003b1e <__kernel_rem_pio2+0x52e>
 8003b12:	e974 2302 	ldrd	r2, r3, [r4, #-8]!
 8003b16:	f7fc fb69 	bl	80001ec <__adddf3>
 8003b1a:	3d01      	subs	r5, #1
 8003b1c:	e7f7      	b.n	8003b0e <__kernel_rem_pio2+0x51e>
 8003b1e:	f1ba 0f00 	cmp.w	sl, #0
 8003b22:	d003      	beq.n	8003b2c <__kernel_rem_pio2+0x53c>
 8003b24:	4602      	mov	r2, r0
 8003b26:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8003b2a:	e001      	b.n	8003b30 <__kernel_rem_pio2+0x540>
 8003b2c:	4602      	mov	r2, r0
 8003b2e:	460b      	mov	r3, r1
 8003b30:	9c01      	ldr	r4, [sp, #4]
 8003b32:	e9c4 2300 	strd	r2, r3, [r4]
 8003b36:	4602      	mov	r2, r0
 8003b38:	460b      	mov	r3, r1
 8003b3a:	e9dd 0148 	ldrd	r0, r1, [sp, #288]	; 0x120
 8003b3e:	f7fc fb53 	bl	80001e8 <__aeabi_dsub>
 8003b42:	ad4a      	add	r5, sp, #296	; 0x128
 8003b44:	2401      	movs	r4, #1
 8003b46:	45a3      	cmp	fp, r4
 8003b48:	db05      	blt.n	8003b56 <__kernel_rem_pio2+0x566>
 8003b4a:	e8f5 2302 	ldrd	r2, r3, [r5], #8
 8003b4e:	f7fc fb4d 	bl	80001ec <__adddf3>
 8003b52:	3401      	adds	r4, #1
 8003b54:	e7f7      	b.n	8003b46 <__kernel_rem_pio2+0x556>
 8003b56:	f1ba 0f00 	cmp.w	sl, #0
 8003b5a:	d003      	beq.n	8003b64 <__kernel_rem_pio2+0x574>
 8003b5c:	4602      	mov	r2, r0
 8003b5e:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8003b62:	e001      	b.n	8003b68 <__kernel_rem_pio2+0x578>
 8003b64:	4602      	mov	r2, r0
 8003b66:	460b      	mov	r3, r1
 8003b68:	9901      	ldr	r1, [sp, #4]
 8003b6a:	e9c1 2302 	strd	r2, r3, [r1, #8]
 8003b6e:	e076      	b.n	8003c5e <__kernel_rem_pio2+0x66e>
 8003b70:	f1b9 0f00 	cmp.w	r9, #0
 8003b74:	dd20      	ble.n	8003bb8 <__kernel_rem_pio2+0x5c8>
 8003b76:	e978 6702 	ldrd	r6, r7, [r8, #-8]!
 8003b7a:	ed98 7b02 	vldr	d7, [r8, #8]
 8003b7e:	4630      	mov	r0, r6
 8003b80:	ec53 2b17 	vmov	r2, r3, d7
 8003b84:	4639      	mov	r1, r7
 8003b86:	ed8d 7b02 	vstr	d7, [sp, #8]
 8003b8a:	f7fc fb2f 	bl	80001ec <__adddf3>
 8003b8e:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8003b92:	4602      	mov	r2, r0
 8003b94:	460b      	mov	r3, r1
 8003b96:	4630      	mov	r0, r6
 8003b98:	4639      	mov	r1, r7
 8003b9a:	f7fc fb25 	bl	80001e8 <__aeabi_dsub>
 8003b9e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8003ba2:	f7fc fb23 	bl	80001ec <__adddf3>
 8003ba6:	ed9d 7b06 	vldr	d7, [sp, #24]
 8003baa:	f109 39ff 	add.w	r9, r9, #4294967295
 8003bae:	e9c8 0102 	strd	r0, r1, [r8, #8]
 8003bb2:	ed88 7b00 	vstr	d7, [r8]
 8003bb6:	e7db      	b.n	8003b70 <__kernel_rem_pio2+0x580>
 8003bb8:	465e      	mov	r6, fp
 8003bba:	2e01      	cmp	r6, #1
 8003bbc:	dd1f      	ble.n	8003bfe <__kernel_rem_pio2+0x60e>
 8003bbe:	e974 8902 	ldrd	r8, r9, [r4, #-8]!
 8003bc2:	ed94 7b02 	vldr	d7, [r4, #8]
 8003bc6:	4640      	mov	r0, r8
 8003bc8:	ec53 2b17 	vmov	r2, r3, d7
 8003bcc:	4649      	mov	r1, r9
 8003bce:	ed8d 7b02 	vstr	d7, [sp, #8]
 8003bd2:	f7fc fb0b 	bl	80001ec <__adddf3>
 8003bd6:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8003bda:	4602      	mov	r2, r0
 8003bdc:	460b      	mov	r3, r1
 8003bde:	4640      	mov	r0, r8
 8003be0:	4649      	mov	r1, r9
 8003be2:	f7fc fb01 	bl	80001e8 <__aeabi_dsub>
 8003be6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8003bea:	f7fc faff 	bl	80001ec <__adddf3>
 8003bee:	ed9d 7b06 	vldr	d7, [sp, #24]
 8003bf2:	3e01      	subs	r6, #1
 8003bf4:	e9c4 0102 	strd	r0, r1, [r4, #8]
 8003bf8:	ed84 7b00 	vstr	d7, [r4]
 8003bfc:	e7dd      	b.n	8003bba <__kernel_rem_pio2+0x5ca>
 8003bfe:	9c05      	ldr	r4, [sp, #20]
 8003c00:	ab48      	add	r3, sp, #288	; 0x120
 8003c02:	3408      	adds	r4, #8
 8003c04:	441c      	add	r4, r3
 8003c06:	2000      	movs	r0, #0
 8003c08:	2100      	movs	r1, #0
 8003c0a:	f1bb 0f01 	cmp.w	fp, #1
 8003c0e:	dd06      	ble.n	8003c1e <__kernel_rem_pio2+0x62e>
 8003c10:	e974 2302 	ldrd	r2, r3, [r4, #-8]!
 8003c14:	f7fc faea 	bl	80001ec <__adddf3>
 8003c18:	f10b 3bff 	add.w	fp, fp, #4294967295
 8003c1c:	e7f5      	b.n	8003c0a <__kernel_rem_pio2+0x61a>
 8003c1e:	f1ba 0f00 	cmp.w	sl, #0
 8003c22:	d10b      	bne.n	8003c3c <__kernel_rem_pio2+0x64c>
 8003c24:	e9dd 2348 	ldrd	r2, r3, [sp, #288]	; 0x120
 8003c28:	9c01      	ldr	r4, [sp, #4]
 8003c2a:	e9c4 2300 	strd	r2, r3, [r4]
 8003c2e:	e9dd 234a 	ldrd	r2, r3, [sp, #296]	; 0x128
 8003c32:	e9c4 0104 	strd	r0, r1, [r4, #16]
 8003c36:	e9c4 2302 	strd	r2, r3, [r4, #8]
 8003c3a:	e010      	b.n	8003c5e <__kernel_rem_pio2+0x66e>
 8003c3c:	9a01      	ldr	r2, [sp, #4]
 8003c3e:	682b      	ldr	r3, [r5, #0]
 8003c40:	6013      	str	r3, [r2, #0]
 8003c42:	686b      	ldr	r3, [r5, #4]
 8003c44:	6110      	str	r0, [r2, #16]
 8003c46:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8003c4a:	6053      	str	r3, [r2, #4]
 8003c4c:	68ab      	ldr	r3, [r5, #8]
 8003c4e:	6093      	str	r3, [r2, #8]
 8003c50:	68eb      	ldr	r3, [r5, #12]
 8003c52:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8003c56:	60d3      	str	r3, [r2, #12]
 8003c58:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8003c5c:	6153      	str	r3, [r2, #20]
 8003c5e:	9b04      	ldr	r3, [sp, #16]
 8003c60:	f003 0007 	and.w	r0, r3, #7
 8003c64:	f50d 7d19 	add.w	sp, sp, #612	; 0x264
 8003c68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003c6c:	f3af 8000 	nop.w
 8003c70:	00000000 	.word	0x00000000
 8003c74:	3ff00000 	.word	0x3ff00000
	...
 8003c80:	41700000 	.word	0x41700000
 8003c84:	3e700000 	.word	0x3e700000
 8003c88:	08004750 	.word	0x08004750
 8003c8c:	00000000 	.word	0x00000000

08003c90 <__kernel_sin>:
 8003c90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003c94:	ec55 4b10 	vmov	r4, r5, d0
 8003c98:	b085      	sub	sp, #20
 8003c9a:	f025 4300 	bic.w	r3, r5, #2147483648	; 0x80000000
 8003c9e:	f1b3 5f79 	cmp.w	r3, #1044381696	; 0x3e400000
 8003ca2:	ed8d 1b00 	vstr	d1, [sp]
 8003ca6:	9002      	str	r0, [sp, #8]
 8003ca8:	da07      	bge.n	8003cba <__kernel_sin+0x2a>
 8003caa:	ee10 0a10 	vmov	r0, s0
 8003cae:	4629      	mov	r1, r5
 8003cb0:	f7fc fee8 	bl	8000a84 <__aeabi_d2iz>
 8003cb4:	2800      	cmp	r0, #0
 8003cb6:	f000 8081 	beq.w	8003dbc <__kernel_sin+0x12c>
 8003cba:	4622      	mov	r2, r4
 8003cbc:	462b      	mov	r3, r5
 8003cbe:	4620      	mov	r0, r4
 8003cc0:	4629      	mov	r1, r5
 8003cc2:	f7fc fc45 	bl	8000550 <__aeabi_dmul>
 8003cc6:	4682      	mov	sl, r0
 8003cc8:	468b      	mov	fp, r1
 8003cca:	4602      	mov	r2, r0
 8003ccc:	460b      	mov	r3, r1
 8003cce:	4620      	mov	r0, r4
 8003cd0:	4629      	mov	r1, r5
 8003cd2:	f7fc fc3d 	bl	8000550 <__aeabi_dmul>
 8003cd6:	a341      	add	r3, pc, #260	; (adr r3, 8003ddc <__kernel_sin+0x14c>)
 8003cd8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003cdc:	4680      	mov	r8, r0
 8003cde:	4689      	mov	r9, r1
 8003ce0:	4650      	mov	r0, sl
 8003ce2:	4659      	mov	r1, fp
 8003ce4:	f7fc fc34 	bl	8000550 <__aeabi_dmul>
 8003ce8:	a33e      	add	r3, pc, #248	; (adr r3, 8003de4 <__kernel_sin+0x154>)
 8003cea:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003cee:	f7fc fa7b 	bl	80001e8 <__aeabi_dsub>
 8003cf2:	4652      	mov	r2, sl
 8003cf4:	465b      	mov	r3, fp
 8003cf6:	f7fc fc2b 	bl	8000550 <__aeabi_dmul>
 8003cfa:	a33c      	add	r3, pc, #240	; (adr r3, 8003dec <__kernel_sin+0x15c>)
 8003cfc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003d00:	f7fc fa74 	bl	80001ec <__adddf3>
 8003d04:	4652      	mov	r2, sl
 8003d06:	465b      	mov	r3, fp
 8003d08:	f7fc fc22 	bl	8000550 <__aeabi_dmul>
 8003d0c:	a339      	add	r3, pc, #228	; (adr r3, 8003df4 <__kernel_sin+0x164>)
 8003d0e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003d12:	f7fc fa69 	bl	80001e8 <__aeabi_dsub>
 8003d16:	4652      	mov	r2, sl
 8003d18:	465b      	mov	r3, fp
 8003d1a:	f7fc fc19 	bl	8000550 <__aeabi_dmul>
 8003d1e:	a337      	add	r3, pc, #220	; (adr r3, 8003dfc <__kernel_sin+0x16c>)
 8003d20:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003d24:	f7fc fa62 	bl	80001ec <__adddf3>
 8003d28:	9b02      	ldr	r3, [sp, #8]
 8003d2a:	4606      	mov	r6, r0
 8003d2c:	460f      	mov	r7, r1
 8003d2e:	b99b      	cbnz	r3, 8003d58 <__kernel_sin+0xc8>
 8003d30:	4602      	mov	r2, r0
 8003d32:	460b      	mov	r3, r1
 8003d34:	4650      	mov	r0, sl
 8003d36:	4659      	mov	r1, fp
 8003d38:	f7fc fc0a 	bl	8000550 <__aeabi_dmul>
 8003d3c:	a324      	add	r3, pc, #144	; (adr r3, 8003dd0 <__kernel_sin+0x140>)
 8003d3e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003d42:	f7fc fa51 	bl	80001e8 <__aeabi_dsub>
 8003d46:	4642      	mov	r2, r8
 8003d48:	464b      	mov	r3, r9
 8003d4a:	f7fc fc01 	bl	8000550 <__aeabi_dmul>
 8003d4e:	4622      	mov	r2, r4
 8003d50:	462b      	mov	r3, r5
 8003d52:	f7fc fa4b 	bl	80001ec <__adddf3>
 8003d56:	e033      	b.n	8003dc0 <__kernel_sin+0x130>
 8003d58:	2200      	movs	r2, #0
 8003d5a:	4b1f      	ldr	r3, [pc, #124]	; (8003dd8 <__kernel_sin+0x148>)
 8003d5c:	e9dd 0100 	ldrd	r0, r1, [sp]
 8003d60:	f7fc fbf6 	bl	8000550 <__aeabi_dmul>
 8003d64:	4632      	mov	r2, r6
 8003d66:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8003d6a:	463b      	mov	r3, r7
 8003d6c:	4640      	mov	r0, r8
 8003d6e:	4649      	mov	r1, r9
 8003d70:	f7fc fbee 	bl	8000550 <__aeabi_dmul>
 8003d74:	4602      	mov	r2, r0
 8003d76:	460b      	mov	r3, r1
 8003d78:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8003d7c:	f7fc fa34 	bl	80001e8 <__aeabi_dsub>
 8003d80:	4652      	mov	r2, sl
 8003d82:	465b      	mov	r3, fp
 8003d84:	f7fc fbe4 	bl	8000550 <__aeabi_dmul>
 8003d88:	e9dd 2300 	ldrd	r2, r3, [sp]
 8003d8c:	f7fc fa2c 	bl	80001e8 <__aeabi_dsub>
 8003d90:	a30f      	add	r3, pc, #60	; (adr r3, 8003dd0 <__kernel_sin+0x140>)
 8003d92:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003d96:	4606      	mov	r6, r0
 8003d98:	460f      	mov	r7, r1
 8003d9a:	4640      	mov	r0, r8
 8003d9c:	4649      	mov	r1, r9
 8003d9e:	f7fc fbd7 	bl	8000550 <__aeabi_dmul>
 8003da2:	4602      	mov	r2, r0
 8003da4:	460b      	mov	r3, r1
 8003da6:	4630      	mov	r0, r6
 8003da8:	4639      	mov	r1, r7
 8003daa:	f7fc fa1f 	bl	80001ec <__adddf3>
 8003dae:	4602      	mov	r2, r0
 8003db0:	460b      	mov	r3, r1
 8003db2:	4620      	mov	r0, r4
 8003db4:	4629      	mov	r1, r5
 8003db6:	f7fc fa17 	bl	80001e8 <__aeabi_dsub>
 8003dba:	e001      	b.n	8003dc0 <__kernel_sin+0x130>
 8003dbc:	4620      	mov	r0, r4
 8003dbe:	4629      	mov	r1, r5
 8003dc0:	ec41 0b10 	vmov	d0, r0, r1
 8003dc4:	b005      	add	sp, #20
 8003dc6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003dca:	bf00      	nop
 8003dcc:	f3af 8000 	nop.w
 8003dd0:	55555549 	.word	0x55555549
 8003dd4:	3fc55555 	.word	0x3fc55555
 8003dd8:	3fe00000 	.word	0x3fe00000
 8003ddc:	5acfd57c 	.word	0x5acfd57c
 8003de0:	3de5d93a 	.word	0x3de5d93a
 8003de4:	8a2b9ceb 	.word	0x8a2b9ceb
 8003de8:	3e5ae5e6 	.word	0x3e5ae5e6
 8003dec:	57b1fe7d 	.word	0x57b1fe7d
 8003df0:	3ec71de3 	.word	0x3ec71de3
 8003df4:	19c161d5 	.word	0x19c161d5
 8003df8:	3f2a01a0 	.word	0x3f2a01a0
 8003dfc:	1110f8a6 	.word	0x1110f8a6
 8003e00:	3f811111 	.word	0x3f811111

08003e04 <fabs>:
 8003e04:	ec53 2b10 	vmov	r2, r3, d0
 8003e08:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8003e0c:	ec43 2b10 	vmov	d0, r2, r3
 8003e10:	4770      	bx	lr
 8003e12:	0000      	movs	r0, r0
 8003e14:	0000      	movs	r0, r0
	...

08003e18 <floor>:
 8003e18:	ec51 0b10 	vmov	r0, r1, d0
 8003e1c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003e20:	f3c1 570a 	ubfx	r7, r1, #20, #11
 8003e24:	f2a7 36ff 	subw	r6, r7, #1023	; 0x3ff
 8003e28:	2e13      	cmp	r6, #19
 8003e2a:	ee10 8a10 	vmov	r8, s0
 8003e2e:	460c      	mov	r4, r1
 8003e30:	ee10 5a10 	vmov	r5, s0
 8003e34:	dc33      	bgt.n	8003e9e <floor+0x86>
 8003e36:	2e00      	cmp	r6, #0
 8003e38:	da16      	bge.n	8003e68 <floor+0x50>
 8003e3a:	a335      	add	r3, pc, #212	; (adr r3, 8003f10 <floor+0xf8>)
 8003e3c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003e40:	f7fc f9d4 	bl	80001ec <__adddf3>
 8003e44:	2200      	movs	r2, #0
 8003e46:	2300      	movs	r3, #0
 8003e48:	f7fc fe12 	bl	8000a70 <__aeabi_dcmpgt>
 8003e4c:	2800      	cmp	r0, #0
 8003e4e:	d057      	beq.n	8003f00 <floor+0xe8>
 8003e50:	2c00      	cmp	r4, #0
 8003e52:	da53      	bge.n	8003efc <floor+0xe4>
 8003e54:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
 8003e58:	ea53 0308 	orrs.w	r3, r3, r8
 8003e5c:	4b2e      	ldr	r3, [pc, #184]	; (8003f18 <floor+0x100>)
 8003e5e:	f04f 0500 	mov.w	r5, #0
 8003e62:	bf18      	it	ne
 8003e64:	461c      	movne	r4, r3
 8003e66:	e04b      	b.n	8003f00 <floor+0xe8>
 8003e68:	4f2c      	ldr	r7, [pc, #176]	; (8003f1c <floor+0x104>)
 8003e6a:	4137      	asrs	r7, r6
 8003e6c:	ea01 0307 	and.w	r3, r1, r7
 8003e70:	4303      	orrs	r3, r0
 8003e72:	d047      	beq.n	8003f04 <floor+0xec>
 8003e74:	a326      	add	r3, pc, #152	; (adr r3, 8003f10 <floor+0xf8>)
 8003e76:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003e7a:	f7fc f9b7 	bl	80001ec <__adddf3>
 8003e7e:	2200      	movs	r2, #0
 8003e80:	2300      	movs	r3, #0
 8003e82:	f7fc fdf5 	bl	8000a70 <__aeabi_dcmpgt>
 8003e86:	b3d8      	cbz	r0, 8003f00 <floor+0xe8>
 8003e88:	2c00      	cmp	r4, #0
 8003e8a:	bfbe      	ittt	lt
 8003e8c:	f44f 1380 	movlt.w	r3, #1048576	; 0x100000
 8003e90:	fa43 f606 	asrlt.w	r6, r3, r6
 8003e94:	19a4      	addlt	r4, r4, r6
 8003e96:	ea24 0407 	bic.w	r4, r4, r7
 8003e9a:	2500      	movs	r5, #0
 8003e9c:	e030      	b.n	8003f00 <floor+0xe8>
 8003e9e:	2e33      	cmp	r6, #51	; 0x33
 8003ea0:	dd08      	ble.n	8003eb4 <floor+0x9c>
 8003ea2:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 8003ea6:	d12d      	bne.n	8003f04 <floor+0xec>
 8003ea8:	ee10 2a10 	vmov	r2, s0
 8003eac:	460b      	mov	r3, r1
 8003eae:	f7fc f99d 	bl	80001ec <__adddf3>
 8003eb2:	e027      	b.n	8003f04 <floor+0xec>
 8003eb4:	f2a7 4713 	subw	r7, r7, #1043	; 0x413
 8003eb8:	f04f 33ff 	mov.w	r3, #4294967295
 8003ebc:	fa23 f707 	lsr.w	r7, r3, r7
 8003ec0:	4238      	tst	r0, r7
 8003ec2:	d01f      	beq.n	8003f04 <floor+0xec>
 8003ec4:	a312      	add	r3, pc, #72	; (adr r3, 8003f10 <floor+0xf8>)
 8003ec6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003eca:	f7fc f98f 	bl	80001ec <__adddf3>
 8003ece:	2200      	movs	r2, #0
 8003ed0:	2300      	movs	r3, #0
 8003ed2:	f7fc fdcd 	bl	8000a70 <__aeabi_dcmpgt>
 8003ed6:	b198      	cbz	r0, 8003f00 <floor+0xe8>
 8003ed8:	2c00      	cmp	r4, #0
 8003eda:	da0c      	bge.n	8003ef6 <floor+0xde>
 8003edc:	2e14      	cmp	r6, #20
 8003ede:	d101      	bne.n	8003ee4 <floor+0xcc>
 8003ee0:	3401      	adds	r4, #1
 8003ee2:	e008      	b.n	8003ef6 <floor+0xde>
 8003ee4:	2301      	movs	r3, #1
 8003ee6:	f1c6 0634 	rsb	r6, r6, #52	; 0x34
 8003eea:	fa03 f606 	lsl.w	r6, r3, r6
 8003eee:	4435      	add	r5, r6
 8003ef0:	45a8      	cmp	r8, r5
 8003ef2:	bf88      	it	hi
 8003ef4:	18e4      	addhi	r4, r4, r3
 8003ef6:	ea25 0507 	bic.w	r5, r5, r7
 8003efa:	e001      	b.n	8003f00 <floor+0xe8>
 8003efc:	2500      	movs	r5, #0
 8003efe:	462c      	mov	r4, r5
 8003f00:	4621      	mov	r1, r4
 8003f02:	4628      	mov	r0, r5
 8003f04:	ec41 0b10 	vmov	d0, r0, r1
 8003f08:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003f0c:	f3af 8000 	nop.w
 8003f10:	8800759c 	.word	0x8800759c
 8003f14:	7e37e43c 	.word	0x7e37e43c
 8003f18:	bff00000 	.word	0xbff00000
 8003f1c:	000fffff 	.word	0x000fffff

08003f20 <scalbn>:
 8003f20:	b570      	push	{r4, r5, r6, lr}
 8003f22:	ec55 4b10 	vmov	r4, r5, d0
 8003f26:	f3c5 520a 	ubfx	r2, r5, #20, #11
 8003f2a:	4606      	mov	r6, r0
 8003f2c:	462b      	mov	r3, r5
 8003f2e:	b9a2      	cbnz	r2, 8003f5a <scalbn+0x3a>
 8003f30:	f025 4300 	bic.w	r3, r5, #2147483648	; 0x80000000
 8003f34:	4323      	orrs	r3, r4
 8003f36:	d059      	beq.n	8003fec <scalbn+0xcc>
 8003f38:	2200      	movs	r2, #0
 8003f3a:	4b33      	ldr	r3, [pc, #204]	; (8004008 <scalbn+0xe8>)
 8003f3c:	4629      	mov	r1, r5
 8003f3e:	ee10 0a10 	vmov	r0, s0
 8003f42:	f7fc fb05 	bl	8000550 <__aeabi_dmul>
 8003f46:	4a31      	ldr	r2, [pc, #196]	; (800400c <scalbn+0xec>)
 8003f48:	4296      	cmp	r6, r2
 8003f4a:	4604      	mov	r4, r0
 8003f4c:	460d      	mov	r5, r1
 8003f4e:	460b      	mov	r3, r1
 8003f50:	da0f      	bge.n	8003f72 <scalbn+0x52>
 8003f52:	a329      	add	r3, pc, #164	; (adr r3, 8003ff8 <scalbn+0xd8>)
 8003f54:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003f58:	e045      	b.n	8003fe6 <scalbn+0xc6>
 8003f5a:	f240 71ff 	movw	r1, #2047	; 0x7ff
 8003f5e:	428a      	cmp	r2, r1
 8003f60:	d10a      	bne.n	8003f78 <scalbn+0x58>
 8003f62:	ee10 2a10 	vmov	r2, s0
 8003f66:	462b      	mov	r3, r5
 8003f68:	4620      	mov	r0, r4
 8003f6a:	4629      	mov	r1, r5
 8003f6c:	f7fc f93e 	bl	80001ec <__adddf3>
 8003f70:	e03e      	b.n	8003ff0 <scalbn+0xd0>
 8003f72:	f3c1 520a 	ubfx	r2, r1, #20, #11
 8003f76:	3a36      	subs	r2, #54	; 0x36
 8003f78:	4432      	add	r2, r6
 8003f7a:	f240 71fe 	movw	r1, #2046	; 0x7fe
 8003f7e:	428a      	cmp	r2, r1
 8003f80:	dd02      	ble.n	8003f88 <scalbn+0x68>
 8003f82:	ec45 4b11 	vmov	d1, r4, r5
 8003f86:	e011      	b.n	8003fac <scalbn+0x8c>
 8003f88:	2a00      	cmp	r2, #0
 8003f8a:	dd06      	ble.n	8003f9a <scalbn+0x7a>
 8003f8c:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 8003f90:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 8003f94:	ea43 5502 	orr.w	r5, r3, r2, lsl #20
 8003f98:	e028      	b.n	8003fec <scalbn+0xcc>
 8003f9a:	f112 0f35 	cmn.w	r2, #53	; 0x35
 8003f9e:	da17      	bge.n	8003fd0 <scalbn+0xb0>
 8003fa0:	f24c 3350 	movw	r3, #50000	; 0xc350
 8003fa4:	429e      	cmp	r6, r3
 8003fa6:	ec45 4b11 	vmov	d1, r4, r5
 8003faa:	dd07      	ble.n	8003fbc <scalbn+0x9c>
 8003fac:	ed9f 0b14 	vldr	d0, [pc, #80]	; 8004000 <scalbn+0xe0>
 8003fb0:	f000 f830 	bl	8004014 <copysign>
 8003fb4:	a312      	add	r3, pc, #72	; (adr r3, 8004000 <scalbn+0xe0>)
 8003fb6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003fba:	e006      	b.n	8003fca <scalbn+0xaa>
 8003fbc:	ed9f 0b0e 	vldr	d0, [pc, #56]	; 8003ff8 <scalbn+0xd8>
 8003fc0:	f000 f828 	bl	8004014 <copysign>
 8003fc4:	a30c      	add	r3, pc, #48	; (adr r3, 8003ff8 <scalbn+0xd8>)
 8003fc6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003fca:	ec51 0b10 	vmov	r0, r1, d0
 8003fce:	e00a      	b.n	8003fe6 <scalbn+0xc6>
 8003fd0:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 8003fd4:	3236      	adds	r2, #54	; 0x36
 8003fd6:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 8003fda:	ea43 5502 	orr.w	r5, r3, r2, lsl #20
 8003fde:	4b0c      	ldr	r3, [pc, #48]	; (8004010 <scalbn+0xf0>)
 8003fe0:	4620      	mov	r0, r4
 8003fe2:	4629      	mov	r1, r5
 8003fe4:	2200      	movs	r2, #0
 8003fe6:	f7fc fab3 	bl	8000550 <__aeabi_dmul>
 8003fea:	e001      	b.n	8003ff0 <scalbn+0xd0>
 8003fec:	4620      	mov	r0, r4
 8003fee:	4629      	mov	r1, r5
 8003ff0:	ec41 0b10 	vmov	d0, r0, r1
 8003ff4:	bd70      	pop	{r4, r5, r6, pc}
 8003ff6:	bf00      	nop
 8003ff8:	c2f8f359 	.word	0xc2f8f359
 8003ffc:	01a56e1f 	.word	0x01a56e1f
 8004000:	8800759c 	.word	0x8800759c
 8004004:	7e37e43c 	.word	0x7e37e43c
 8004008:	43500000 	.word	0x43500000
 800400c:	ffff3cb0 	.word	0xffff3cb0
 8004010:	3c900000 	.word	0x3c900000

08004014 <copysign>:
 8004014:	ec53 2b10 	vmov	r2, r3, d0
 8004018:	ee11 0a90 	vmov	r0, s3
 800401c:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 8004020:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8004024:	ea41 0300 	orr.w	r3, r1, r0
 8004028:	ec43 2b10 	vmov	d0, r2, r3
 800402c:	4770      	bx	lr
	...

08004030 <_init>:
 8004030:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004032:	bf00      	nop
 8004034:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8004036:	bc08      	pop	{r3}
 8004038:	469e      	mov	lr, r3
 800403a:	4770      	bx	lr

0800403c <_fini>:
 800403c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800403e:	bf00      	nop
 8004040:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8004042:	bc08      	pop	{r3}
 8004044:	469e      	mov	lr, r3
 8004046:	4770      	bx	lr
