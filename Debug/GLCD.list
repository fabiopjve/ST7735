
E:\ARM\Atollic\GLCD\Debug\GLCD.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000018c  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00006180  08000190  08000190  00010190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00001ad8  08006310  08006310  00016310  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  08007de8  08007de8  00017de8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  08007df0  08007df0  00017df0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  08007df4  08007df4  00017df4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000114  20000000  08007df8  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          0000019c  20000114  08007f0c  00020114  2**2
                  ALLOC
  8 ._user_heap_stack 00000600  200002b0  08007f0c  000202b0  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00020114  2**0
                  CONTENTS, READONLY
 10 .debug_info   00013687  00000000  00000000  00020144  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00002ba4  00000000  00000000  000337cb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000ba1a  00000000  00000000  0003636f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00000e48  00000000  00000000  00041d90  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000011f8  00000000  00000000  00042bd8  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00006c58  00000000  00000000  00043dd0  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0000492d  00000000  00000000  0004aa28  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007e  00000000  00000000  0004f355  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00003534  00000000  00000000  0004f3d4  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000190 <__do_global_dtors_aux>:
 8000190:	b510      	push	{r4, lr}
 8000192:	4c05      	ldr	r4, [pc, #20]	; (80001a8 <__do_global_dtors_aux+0x18>)
 8000194:	7823      	ldrb	r3, [r4, #0]
 8000196:	b933      	cbnz	r3, 80001a6 <__do_global_dtors_aux+0x16>
 8000198:	4b04      	ldr	r3, [pc, #16]	; (80001ac <__do_global_dtors_aux+0x1c>)
 800019a:	b113      	cbz	r3, 80001a2 <__do_global_dtors_aux+0x12>
 800019c:	4804      	ldr	r0, [pc, #16]	; (80001b0 <__do_global_dtors_aux+0x20>)
 800019e:	f3af 8000 	nop.w
 80001a2:	2301      	movs	r3, #1
 80001a4:	7023      	strb	r3, [r4, #0]
 80001a6:	bd10      	pop	{r4, pc}
 80001a8:	20000114 	.word	0x20000114
 80001ac:	00000000 	.word	0x00000000
 80001b0:	080062f8 	.word	0x080062f8

080001b4 <frame_dummy>:
 80001b4:	b508      	push	{r3, lr}
 80001b6:	4b03      	ldr	r3, [pc, #12]	; (80001c4 <frame_dummy+0x10>)
 80001b8:	b11b      	cbz	r3, 80001c2 <frame_dummy+0xe>
 80001ba:	4903      	ldr	r1, [pc, #12]	; (80001c8 <frame_dummy+0x14>)
 80001bc:	4803      	ldr	r0, [pc, #12]	; (80001cc <frame_dummy+0x18>)
 80001be:	f3af 8000 	nop.w
 80001c2:	bd08      	pop	{r3, pc}
 80001c4:	00000000 	.word	0x00000000
 80001c8:	20000118 	.word	0x20000118
 80001cc:	080062f8 	.word	0x080062f8

080001d0 <strlen>:
 80001d0:	4603      	mov	r3, r0
 80001d2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001d6:	2a00      	cmp	r2, #0
 80001d8:	d1fb      	bne.n	80001d2 <strlen+0x2>
 80001da:	1a18      	subs	r0, r3, r0
 80001dc:	3801      	subs	r0, #1
 80001de:	4770      	bx	lr

080001e0 <memchr>:
 80001e0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80001e4:	2a10      	cmp	r2, #16
 80001e6:	db2b      	blt.n	8000240 <memchr+0x60>
 80001e8:	f010 0f07 	tst.w	r0, #7
 80001ec:	d008      	beq.n	8000200 <memchr+0x20>
 80001ee:	f810 3b01 	ldrb.w	r3, [r0], #1
 80001f2:	3a01      	subs	r2, #1
 80001f4:	428b      	cmp	r3, r1
 80001f6:	d02d      	beq.n	8000254 <memchr+0x74>
 80001f8:	f010 0f07 	tst.w	r0, #7
 80001fc:	b342      	cbz	r2, 8000250 <memchr+0x70>
 80001fe:	d1f6      	bne.n	80001ee <memchr+0xe>
 8000200:	b4f0      	push	{r4, r5, r6, r7}
 8000202:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000206:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800020a:	f022 0407 	bic.w	r4, r2, #7
 800020e:	f07f 0700 	mvns.w	r7, #0
 8000212:	2300      	movs	r3, #0
 8000214:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000218:	3c08      	subs	r4, #8
 800021a:	ea85 0501 	eor.w	r5, r5, r1
 800021e:	ea86 0601 	eor.w	r6, r6, r1
 8000222:	fa85 f547 	uadd8	r5, r5, r7
 8000226:	faa3 f587 	sel	r5, r3, r7
 800022a:	fa86 f647 	uadd8	r6, r6, r7
 800022e:	faa5 f687 	sel	r6, r5, r7
 8000232:	b98e      	cbnz	r6, 8000258 <memchr+0x78>
 8000234:	d1ee      	bne.n	8000214 <memchr+0x34>
 8000236:	bcf0      	pop	{r4, r5, r6, r7}
 8000238:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800023c:	f002 0207 	and.w	r2, r2, #7
 8000240:	b132      	cbz	r2, 8000250 <memchr+0x70>
 8000242:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000246:	3a01      	subs	r2, #1
 8000248:	ea83 0301 	eor.w	r3, r3, r1
 800024c:	b113      	cbz	r3, 8000254 <memchr+0x74>
 800024e:	d1f8      	bne.n	8000242 <memchr+0x62>
 8000250:	2000      	movs	r0, #0
 8000252:	4770      	bx	lr
 8000254:	3801      	subs	r0, #1
 8000256:	4770      	bx	lr
 8000258:	2d00      	cmp	r5, #0
 800025a:	bf06      	itte	eq
 800025c:	4635      	moveq	r5, r6
 800025e:	3803      	subeq	r0, #3
 8000260:	3807      	subne	r0, #7
 8000262:	f015 0f01 	tst.w	r5, #1
 8000266:	d107      	bne.n	8000278 <memchr+0x98>
 8000268:	3001      	adds	r0, #1
 800026a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800026e:	bf02      	ittt	eq
 8000270:	3001      	addeq	r0, #1
 8000272:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000276:	3001      	addeq	r0, #1
 8000278:	bcf0      	pop	{r4, r5, r6, r7}
 800027a:	3801      	subs	r0, #1
 800027c:	4770      	bx	lr
 800027e:	bf00      	nop

08000280 <__aeabi_drsub>:
 8000280:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000284:	e002      	b.n	800028c <__adddf3>
 8000286:	bf00      	nop

08000288 <__aeabi_dsub>:
 8000288:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800028c <__adddf3>:
 800028c:	b530      	push	{r4, r5, lr}
 800028e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000292:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000296:	ea94 0f05 	teq	r4, r5
 800029a:	bf08      	it	eq
 800029c:	ea90 0f02 	teqeq	r0, r2
 80002a0:	bf1f      	itttt	ne
 80002a2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002a6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002aa:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002ae:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002b2:	f000 80e2 	beq.w	800047a <__adddf3+0x1ee>
 80002b6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002ba:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002be:	bfb8      	it	lt
 80002c0:	426d      	neglt	r5, r5
 80002c2:	dd0c      	ble.n	80002de <__adddf3+0x52>
 80002c4:	442c      	add	r4, r5
 80002c6:	ea80 0202 	eor.w	r2, r0, r2
 80002ca:	ea81 0303 	eor.w	r3, r1, r3
 80002ce:	ea82 0000 	eor.w	r0, r2, r0
 80002d2:	ea83 0101 	eor.w	r1, r3, r1
 80002d6:	ea80 0202 	eor.w	r2, r0, r2
 80002da:	ea81 0303 	eor.w	r3, r1, r3
 80002de:	2d36      	cmp	r5, #54	; 0x36
 80002e0:	bf88      	it	hi
 80002e2:	bd30      	pophi	{r4, r5, pc}
 80002e4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80002e8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80002ec:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80002f0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80002f4:	d002      	beq.n	80002fc <__adddf3+0x70>
 80002f6:	4240      	negs	r0, r0
 80002f8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80002fc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000300:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000304:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000308:	d002      	beq.n	8000310 <__adddf3+0x84>
 800030a:	4252      	negs	r2, r2
 800030c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000310:	ea94 0f05 	teq	r4, r5
 8000314:	f000 80a7 	beq.w	8000466 <__adddf3+0x1da>
 8000318:	f1a4 0401 	sub.w	r4, r4, #1
 800031c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000320:	db0d      	blt.n	800033e <__adddf3+0xb2>
 8000322:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000326:	fa22 f205 	lsr.w	r2, r2, r5
 800032a:	1880      	adds	r0, r0, r2
 800032c:	f141 0100 	adc.w	r1, r1, #0
 8000330:	fa03 f20e 	lsl.w	r2, r3, lr
 8000334:	1880      	adds	r0, r0, r2
 8000336:	fa43 f305 	asr.w	r3, r3, r5
 800033a:	4159      	adcs	r1, r3
 800033c:	e00e      	b.n	800035c <__adddf3+0xd0>
 800033e:	f1a5 0520 	sub.w	r5, r5, #32
 8000342:	f10e 0e20 	add.w	lr, lr, #32
 8000346:	2a01      	cmp	r2, #1
 8000348:	fa03 fc0e 	lsl.w	ip, r3, lr
 800034c:	bf28      	it	cs
 800034e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000352:	fa43 f305 	asr.w	r3, r3, r5
 8000356:	18c0      	adds	r0, r0, r3
 8000358:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800035c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000360:	d507      	bpl.n	8000372 <__adddf3+0xe6>
 8000362:	f04f 0e00 	mov.w	lr, #0
 8000366:	f1dc 0c00 	rsbs	ip, ip, #0
 800036a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800036e:	eb6e 0101 	sbc.w	r1, lr, r1
 8000372:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8000376:	d31b      	bcc.n	80003b0 <__adddf3+0x124>
 8000378:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800037c:	d30c      	bcc.n	8000398 <__adddf3+0x10c>
 800037e:	0849      	lsrs	r1, r1, #1
 8000380:	ea5f 0030 	movs.w	r0, r0, rrx
 8000384:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000388:	f104 0401 	add.w	r4, r4, #1
 800038c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000390:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000394:	f080 809a 	bcs.w	80004cc <__adddf3+0x240>
 8000398:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800039c:	bf08      	it	eq
 800039e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003a2:	f150 0000 	adcs.w	r0, r0, #0
 80003a6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003aa:	ea41 0105 	orr.w	r1, r1, r5
 80003ae:	bd30      	pop	{r4, r5, pc}
 80003b0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003b4:	4140      	adcs	r0, r0
 80003b6:	eb41 0101 	adc.w	r1, r1, r1
 80003ba:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80003be:	f1a4 0401 	sub.w	r4, r4, #1
 80003c2:	d1e9      	bne.n	8000398 <__adddf3+0x10c>
 80003c4:	f091 0f00 	teq	r1, #0
 80003c8:	bf04      	itt	eq
 80003ca:	4601      	moveq	r1, r0
 80003cc:	2000      	moveq	r0, #0
 80003ce:	fab1 f381 	clz	r3, r1
 80003d2:	bf08      	it	eq
 80003d4:	3320      	addeq	r3, #32
 80003d6:	f1a3 030b 	sub.w	r3, r3, #11
 80003da:	f1b3 0220 	subs.w	r2, r3, #32
 80003de:	da0c      	bge.n	80003fa <__adddf3+0x16e>
 80003e0:	320c      	adds	r2, #12
 80003e2:	dd08      	ble.n	80003f6 <__adddf3+0x16a>
 80003e4:	f102 0c14 	add.w	ip, r2, #20
 80003e8:	f1c2 020c 	rsb	r2, r2, #12
 80003ec:	fa01 f00c 	lsl.w	r0, r1, ip
 80003f0:	fa21 f102 	lsr.w	r1, r1, r2
 80003f4:	e00c      	b.n	8000410 <__adddf3+0x184>
 80003f6:	f102 0214 	add.w	r2, r2, #20
 80003fa:	bfd8      	it	le
 80003fc:	f1c2 0c20 	rsble	ip, r2, #32
 8000400:	fa01 f102 	lsl.w	r1, r1, r2
 8000404:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000408:	bfdc      	itt	le
 800040a:	ea41 010c 	orrle.w	r1, r1, ip
 800040e:	4090      	lslle	r0, r2
 8000410:	1ae4      	subs	r4, r4, r3
 8000412:	bfa2      	ittt	ge
 8000414:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000418:	4329      	orrge	r1, r5
 800041a:	bd30      	popge	{r4, r5, pc}
 800041c:	ea6f 0404 	mvn.w	r4, r4
 8000420:	3c1f      	subs	r4, #31
 8000422:	da1c      	bge.n	800045e <__adddf3+0x1d2>
 8000424:	340c      	adds	r4, #12
 8000426:	dc0e      	bgt.n	8000446 <__adddf3+0x1ba>
 8000428:	f104 0414 	add.w	r4, r4, #20
 800042c:	f1c4 0220 	rsb	r2, r4, #32
 8000430:	fa20 f004 	lsr.w	r0, r0, r4
 8000434:	fa01 f302 	lsl.w	r3, r1, r2
 8000438:	ea40 0003 	orr.w	r0, r0, r3
 800043c:	fa21 f304 	lsr.w	r3, r1, r4
 8000440:	ea45 0103 	orr.w	r1, r5, r3
 8000444:	bd30      	pop	{r4, r5, pc}
 8000446:	f1c4 040c 	rsb	r4, r4, #12
 800044a:	f1c4 0220 	rsb	r2, r4, #32
 800044e:	fa20 f002 	lsr.w	r0, r0, r2
 8000452:	fa01 f304 	lsl.w	r3, r1, r4
 8000456:	ea40 0003 	orr.w	r0, r0, r3
 800045a:	4629      	mov	r1, r5
 800045c:	bd30      	pop	{r4, r5, pc}
 800045e:	fa21 f004 	lsr.w	r0, r1, r4
 8000462:	4629      	mov	r1, r5
 8000464:	bd30      	pop	{r4, r5, pc}
 8000466:	f094 0f00 	teq	r4, #0
 800046a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800046e:	bf06      	itte	eq
 8000470:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8000474:	3401      	addeq	r4, #1
 8000476:	3d01      	subne	r5, #1
 8000478:	e74e      	b.n	8000318 <__adddf3+0x8c>
 800047a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800047e:	bf18      	it	ne
 8000480:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000484:	d029      	beq.n	80004da <__adddf3+0x24e>
 8000486:	ea94 0f05 	teq	r4, r5
 800048a:	bf08      	it	eq
 800048c:	ea90 0f02 	teqeq	r0, r2
 8000490:	d005      	beq.n	800049e <__adddf3+0x212>
 8000492:	ea54 0c00 	orrs.w	ip, r4, r0
 8000496:	bf04      	itt	eq
 8000498:	4619      	moveq	r1, r3
 800049a:	4610      	moveq	r0, r2
 800049c:	bd30      	pop	{r4, r5, pc}
 800049e:	ea91 0f03 	teq	r1, r3
 80004a2:	bf1e      	ittt	ne
 80004a4:	2100      	movne	r1, #0
 80004a6:	2000      	movne	r0, #0
 80004a8:	bd30      	popne	{r4, r5, pc}
 80004aa:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004ae:	d105      	bne.n	80004bc <__adddf3+0x230>
 80004b0:	0040      	lsls	r0, r0, #1
 80004b2:	4149      	adcs	r1, r1
 80004b4:	bf28      	it	cs
 80004b6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80004ba:	bd30      	pop	{r4, r5, pc}
 80004bc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80004c0:	bf3c      	itt	cc
 80004c2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80004c6:	bd30      	popcc	{r4, r5, pc}
 80004c8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004cc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80004d0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80004d4:	f04f 0000 	mov.w	r0, #0
 80004d8:	bd30      	pop	{r4, r5, pc}
 80004da:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004de:	bf1a      	itte	ne
 80004e0:	4619      	movne	r1, r3
 80004e2:	4610      	movne	r0, r2
 80004e4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80004e8:	bf1c      	itt	ne
 80004ea:	460b      	movne	r3, r1
 80004ec:	4602      	movne	r2, r0
 80004ee:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80004f2:	bf06      	itte	eq
 80004f4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80004f8:	ea91 0f03 	teqeq	r1, r3
 80004fc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000500:	bd30      	pop	{r4, r5, pc}
 8000502:	bf00      	nop

08000504 <__aeabi_ui2d>:
 8000504:	f090 0f00 	teq	r0, #0
 8000508:	bf04      	itt	eq
 800050a:	2100      	moveq	r1, #0
 800050c:	4770      	bxeq	lr
 800050e:	b530      	push	{r4, r5, lr}
 8000510:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000514:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000518:	f04f 0500 	mov.w	r5, #0
 800051c:	f04f 0100 	mov.w	r1, #0
 8000520:	e750      	b.n	80003c4 <__adddf3+0x138>
 8000522:	bf00      	nop

08000524 <__aeabi_i2d>:
 8000524:	f090 0f00 	teq	r0, #0
 8000528:	bf04      	itt	eq
 800052a:	2100      	moveq	r1, #0
 800052c:	4770      	bxeq	lr
 800052e:	b530      	push	{r4, r5, lr}
 8000530:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000534:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000538:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800053c:	bf48      	it	mi
 800053e:	4240      	negmi	r0, r0
 8000540:	f04f 0100 	mov.w	r1, #0
 8000544:	e73e      	b.n	80003c4 <__adddf3+0x138>
 8000546:	bf00      	nop

08000548 <__aeabi_f2d>:
 8000548:	0042      	lsls	r2, r0, #1
 800054a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800054e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000552:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000556:	bf1f      	itttt	ne
 8000558:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800055c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000560:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000564:	4770      	bxne	lr
 8000566:	f092 0f00 	teq	r2, #0
 800056a:	bf14      	ite	ne
 800056c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000570:	4770      	bxeq	lr
 8000572:	b530      	push	{r4, r5, lr}
 8000574:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000578:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800057c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000580:	e720      	b.n	80003c4 <__adddf3+0x138>
 8000582:	bf00      	nop

08000584 <__aeabi_ul2d>:
 8000584:	ea50 0201 	orrs.w	r2, r0, r1
 8000588:	bf08      	it	eq
 800058a:	4770      	bxeq	lr
 800058c:	b530      	push	{r4, r5, lr}
 800058e:	f04f 0500 	mov.w	r5, #0
 8000592:	e00a      	b.n	80005aa <__aeabi_l2d+0x16>

08000594 <__aeabi_l2d>:
 8000594:	ea50 0201 	orrs.w	r2, r0, r1
 8000598:	bf08      	it	eq
 800059a:	4770      	bxeq	lr
 800059c:	b530      	push	{r4, r5, lr}
 800059e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80005a2:	d502      	bpl.n	80005aa <__aeabi_l2d+0x16>
 80005a4:	4240      	negs	r0, r0
 80005a6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005aa:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005ae:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005b2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005b6:	f43f aedc 	beq.w	8000372 <__adddf3+0xe6>
 80005ba:	f04f 0203 	mov.w	r2, #3
 80005be:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005c2:	bf18      	it	ne
 80005c4:	3203      	addne	r2, #3
 80005c6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005ca:	bf18      	it	ne
 80005cc:	3203      	addne	r2, #3
 80005ce:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80005d2:	f1c2 0320 	rsb	r3, r2, #32
 80005d6:	fa00 fc03 	lsl.w	ip, r0, r3
 80005da:	fa20 f002 	lsr.w	r0, r0, r2
 80005de:	fa01 fe03 	lsl.w	lr, r1, r3
 80005e2:	ea40 000e 	orr.w	r0, r0, lr
 80005e6:	fa21 f102 	lsr.w	r1, r1, r2
 80005ea:	4414      	add	r4, r2
 80005ec:	e6c1      	b.n	8000372 <__adddf3+0xe6>
 80005ee:	bf00      	nop

080005f0 <__aeabi_dmul>:
 80005f0:	b570      	push	{r4, r5, r6, lr}
 80005f2:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80005f6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80005fa:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80005fe:	bf1d      	ittte	ne
 8000600:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000604:	ea94 0f0c 	teqne	r4, ip
 8000608:	ea95 0f0c 	teqne	r5, ip
 800060c:	f000 f8de 	bleq	80007cc <__aeabi_dmul+0x1dc>
 8000610:	442c      	add	r4, r5
 8000612:	ea81 0603 	eor.w	r6, r1, r3
 8000616:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800061a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800061e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000622:	bf18      	it	ne
 8000624:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000628:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800062c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000630:	d038      	beq.n	80006a4 <__aeabi_dmul+0xb4>
 8000632:	fba0 ce02 	umull	ip, lr, r0, r2
 8000636:	f04f 0500 	mov.w	r5, #0
 800063a:	fbe1 e502 	umlal	lr, r5, r1, r2
 800063e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8000642:	fbe0 e503 	umlal	lr, r5, r0, r3
 8000646:	f04f 0600 	mov.w	r6, #0
 800064a:	fbe1 5603 	umlal	r5, r6, r1, r3
 800064e:	f09c 0f00 	teq	ip, #0
 8000652:	bf18      	it	ne
 8000654:	f04e 0e01 	orrne.w	lr, lr, #1
 8000658:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800065c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000660:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000664:	d204      	bcs.n	8000670 <__aeabi_dmul+0x80>
 8000666:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800066a:	416d      	adcs	r5, r5
 800066c:	eb46 0606 	adc.w	r6, r6, r6
 8000670:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000674:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000678:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800067c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000680:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000684:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000688:	bf88      	it	hi
 800068a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800068e:	d81e      	bhi.n	80006ce <__aeabi_dmul+0xde>
 8000690:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000694:	bf08      	it	eq
 8000696:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800069a:	f150 0000 	adcs.w	r0, r0, #0
 800069e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80006a2:	bd70      	pop	{r4, r5, r6, pc}
 80006a4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80006a8:	ea46 0101 	orr.w	r1, r6, r1
 80006ac:	ea40 0002 	orr.w	r0, r0, r2
 80006b0:	ea81 0103 	eor.w	r1, r1, r3
 80006b4:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80006b8:	bfc2      	ittt	gt
 80006ba:	ebd4 050c 	rsbsgt	r5, r4, ip
 80006be:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80006c2:	bd70      	popgt	{r4, r5, r6, pc}
 80006c4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80006c8:	f04f 0e00 	mov.w	lr, #0
 80006cc:	3c01      	subs	r4, #1
 80006ce:	f300 80ab 	bgt.w	8000828 <__aeabi_dmul+0x238>
 80006d2:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80006d6:	bfde      	ittt	le
 80006d8:	2000      	movle	r0, #0
 80006da:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80006de:	bd70      	pople	{r4, r5, r6, pc}
 80006e0:	f1c4 0400 	rsb	r4, r4, #0
 80006e4:	3c20      	subs	r4, #32
 80006e6:	da35      	bge.n	8000754 <__aeabi_dmul+0x164>
 80006e8:	340c      	adds	r4, #12
 80006ea:	dc1b      	bgt.n	8000724 <__aeabi_dmul+0x134>
 80006ec:	f104 0414 	add.w	r4, r4, #20
 80006f0:	f1c4 0520 	rsb	r5, r4, #32
 80006f4:	fa00 f305 	lsl.w	r3, r0, r5
 80006f8:	fa20 f004 	lsr.w	r0, r0, r4
 80006fc:	fa01 f205 	lsl.w	r2, r1, r5
 8000700:	ea40 0002 	orr.w	r0, r0, r2
 8000704:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000708:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800070c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000710:	fa21 f604 	lsr.w	r6, r1, r4
 8000714:	eb42 0106 	adc.w	r1, r2, r6
 8000718:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800071c:	bf08      	it	eq
 800071e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000722:	bd70      	pop	{r4, r5, r6, pc}
 8000724:	f1c4 040c 	rsb	r4, r4, #12
 8000728:	f1c4 0520 	rsb	r5, r4, #32
 800072c:	fa00 f304 	lsl.w	r3, r0, r4
 8000730:	fa20 f005 	lsr.w	r0, r0, r5
 8000734:	fa01 f204 	lsl.w	r2, r1, r4
 8000738:	ea40 0002 	orr.w	r0, r0, r2
 800073c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000740:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000744:	f141 0100 	adc.w	r1, r1, #0
 8000748:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800074c:	bf08      	it	eq
 800074e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000752:	bd70      	pop	{r4, r5, r6, pc}
 8000754:	f1c4 0520 	rsb	r5, r4, #32
 8000758:	fa00 f205 	lsl.w	r2, r0, r5
 800075c:	ea4e 0e02 	orr.w	lr, lr, r2
 8000760:	fa20 f304 	lsr.w	r3, r0, r4
 8000764:	fa01 f205 	lsl.w	r2, r1, r5
 8000768:	ea43 0302 	orr.w	r3, r3, r2
 800076c:	fa21 f004 	lsr.w	r0, r1, r4
 8000770:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000774:	fa21 f204 	lsr.w	r2, r1, r4
 8000778:	ea20 0002 	bic.w	r0, r0, r2
 800077c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000780:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000784:	bf08      	it	eq
 8000786:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800078a:	bd70      	pop	{r4, r5, r6, pc}
 800078c:	f094 0f00 	teq	r4, #0
 8000790:	d10f      	bne.n	80007b2 <__aeabi_dmul+0x1c2>
 8000792:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8000796:	0040      	lsls	r0, r0, #1
 8000798:	eb41 0101 	adc.w	r1, r1, r1
 800079c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80007a0:	bf08      	it	eq
 80007a2:	3c01      	subeq	r4, #1
 80007a4:	d0f7      	beq.n	8000796 <__aeabi_dmul+0x1a6>
 80007a6:	ea41 0106 	orr.w	r1, r1, r6
 80007aa:	f095 0f00 	teq	r5, #0
 80007ae:	bf18      	it	ne
 80007b0:	4770      	bxne	lr
 80007b2:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80007b6:	0052      	lsls	r2, r2, #1
 80007b8:	eb43 0303 	adc.w	r3, r3, r3
 80007bc:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80007c0:	bf08      	it	eq
 80007c2:	3d01      	subeq	r5, #1
 80007c4:	d0f7      	beq.n	80007b6 <__aeabi_dmul+0x1c6>
 80007c6:	ea43 0306 	orr.w	r3, r3, r6
 80007ca:	4770      	bx	lr
 80007cc:	ea94 0f0c 	teq	r4, ip
 80007d0:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80007d4:	bf18      	it	ne
 80007d6:	ea95 0f0c 	teqne	r5, ip
 80007da:	d00c      	beq.n	80007f6 <__aeabi_dmul+0x206>
 80007dc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80007e0:	bf18      	it	ne
 80007e2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80007e6:	d1d1      	bne.n	800078c <__aeabi_dmul+0x19c>
 80007e8:	ea81 0103 	eor.w	r1, r1, r3
 80007ec:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007f0:	f04f 0000 	mov.w	r0, #0
 80007f4:	bd70      	pop	{r4, r5, r6, pc}
 80007f6:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80007fa:	bf06      	itte	eq
 80007fc:	4610      	moveq	r0, r2
 80007fe:	4619      	moveq	r1, r3
 8000800:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000804:	d019      	beq.n	800083a <__aeabi_dmul+0x24a>
 8000806:	ea94 0f0c 	teq	r4, ip
 800080a:	d102      	bne.n	8000812 <__aeabi_dmul+0x222>
 800080c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000810:	d113      	bne.n	800083a <__aeabi_dmul+0x24a>
 8000812:	ea95 0f0c 	teq	r5, ip
 8000816:	d105      	bne.n	8000824 <__aeabi_dmul+0x234>
 8000818:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800081c:	bf1c      	itt	ne
 800081e:	4610      	movne	r0, r2
 8000820:	4619      	movne	r1, r3
 8000822:	d10a      	bne.n	800083a <__aeabi_dmul+0x24a>
 8000824:	ea81 0103 	eor.w	r1, r1, r3
 8000828:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800082c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000830:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000834:	f04f 0000 	mov.w	r0, #0
 8000838:	bd70      	pop	{r4, r5, r6, pc}
 800083a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800083e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8000842:	bd70      	pop	{r4, r5, r6, pc}

08000844 <__aeabi_ddiv>:
 8000844:	b570      	push	{r4, r5, r6, lr}
 8000846:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800084a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800084e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000852:	bf1d      	ittte	ne
 8000854:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000858:	ea94 0f0c 	teqne	r4, ip
 800085c:	ea95 0f0c 	teqne	r5, ip
 8000860:	f000 f8a7 	bleq	80009b2 <__aeabi_ddiv+0x16e>
 8000864:	eba4 0405 	sub.w	r4, r4, r5
 8000868:	ea81 0e03 	eor.w	lr, r1, r3
 800086c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000870:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000874:	f000 8088 	beq.w	8000988 <__aeabi_ddiv+0x144>
 8000878:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800087c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8000880:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8000884:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000888:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800088c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000890:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8000894:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000898:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800089c:	429d      	cmp	r5, r3
 800089e:	bf08      	it	eq
 80008a0:	4296      	cmpeq	r6, r2
 80008a2:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80008a6:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80008aa:	d202      	bcs.n	80008b2 <__aeabi_ddiv+0x6e>
 80008ac:	085b      	lsrs	r3, r3, #1
 80008ae:	ea4f 0232 	mov.w	r2, r2, rrx
 80008b2:	1ab6      	subs	r6, r6, r2
 80008b4:	eb65 0503 	sbc.w	r5, r5, r3
 80008b8:	085b      	lsrs	r3, r3, #1
 80008ba:	ea4f 0232 	mov.w	r2, r2, rrx
 80008be:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80008c2:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80008c6:	ebb6 0e02 	subs.w	lr, r6, r2
 80008ca:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008ce:	bf22      	ittt	cs
 80008d0:	1ab6      	subcs	r6, r6, r2
 80008d2:	4675      	movcs	r5, lr
 80008d4:	ea40 000c 	orrcs.w	r0, r0, ip
 80008d8:	085b      	lsrs	r3, r3, #1
 80008da:	ea4f 0232 	mov.w	r2, r2, rrx
 80008de:	ebb6 0e02 	subs.w	lr, r6, r2
 80008e2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008e6:	bf22      	ittt	cs
 80008e8:	1ab6      	subcs	r6, r6, r2
 80008ea:	4675      	movcs	r5, lr
 80008ec:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80008f0:	085b      	lsrs	r3, r3, #1
 80008f2:	ea4f 0232 	mov.w	r2, r2, rrx
 80008f6:	ebb6 0e02 	subs.w	lr, r6, r2
 80008fa:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008fe:	bf22      	ittt	cs
 8000900:	1ab6      	subcs	r6, r6, r2
 8000902:	4675      	movcs	r5, lr
 8000904:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000908:	085b      	lsrs	r3, r3, #1
 800090a:	ea4f 0232 	mov.w	r2, r2, rrx
 800090e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000912:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000916:	bf22      	ittt	cs
 8000918:	1ab6      	subcs	r6, r6, r2
 800091a:	4675      	movcs	r5, lr
 800091c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000920:	ea55 0e06 	orrs.w	lr, r5, r6
 8000924:	d018      	beq.n	8000958 <__aeabi_ddiv+0x114>
 8000926:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800092a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800092e:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000932:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000936:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800093a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800093e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000942:	d1c0      	bne.n	80008c6 <__aeabi_ddiv+0x82>
 8000944:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000948:	d10b      	bne.n	8000962 <__aeabi_ddiv+0x11e>
 800094a:	ea41 0100 	orr.w	r1, r1, r0
 800094e:	f04f 0000 	mov.w	r0, #0
 8000952:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8000956:	e7b6      	b.n	80008c6 <__aeabi_ddiv+0x82>
 8000958:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800095c:	bf04      	itt	eq
 800095e:	4301      	orreq	r1, r0
 8000960:	2000      	moveq	r0, #0
 8000962:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000966:	bf88      	it	hi
 8000968:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800096c:	f63f aeaf 	bhi.w	80006ce <__aeabi_dmul+0xde>
 8000970:	ebb5 0c03 	subs.w	ip, r5, r3
 8000974:	bf04      	itt	eq
 8000976:	ebb6 0c02 	subseq.w	ip, r6, r2
 800097a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800097e:	f150 0000 	adcs.w	r0, r0, #0
 8000982:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000986:	bd70      	pop	{r4, r5, r6, pc}
 8000988:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800098c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000990:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000994:	bfc2      	ittt	gt
 8000996:	ebd4 050c 	rsbsgt	r5, r4, ip
 800099a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800099e:	bd70      	popgt	{r4, r5, r6, pc}
 80009a0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80009a4:	f04f 0e00 	mov.w	lr, #0
 80009a8:	3c01      	subs	r4, #1
 80009aa:	e690      	b.n	80006ce <__aeabi_dmul+0xde>
 80009ac:	ea45 0e06 	orr.w	lr, r5, r6
 80009b0:	e68d      	b.n	80006ce <__aeabi_dmul+0xde>
 80009b2:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009b6:	ea94 0f0c 	teq	r4, ip
 80009ba:	bf08      	it	eq
 80009bc:	ea95 0f0c 	teqeq	r5, ip
 80009c0:	f43f af3b 	beq.w	800083a <__aeabi_dmul+0x24a>
 80009c4:	ea94 0f0c 	teq	r4, ip
 80009c8:	d10a      	bne.n	80009e0 <__aeabi_ddiv+0x19c>
 80009ca:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80009ce:	f47f af34 	bne.w	800083a <__aeabi_dmul+0x24a>
 80009d2:	ea95 0f0c 	teq	r5, ip
 80009d6:	f47f af25 	bne.w	8000824 <__aeabi_dmul+0x234>
 80009da:	4610      	mov	r0, r2
 80009dc:	4619      	mov	r1, r3
 80009de:	e72c      	b.n	800083a <__aeabi_dmul+0x24a>
 80009e0:	ea95 0f0c 	teq	r5, ip
 80009e4:	d106      	bne.n	80009f4 <__aeabi_ddiv+0x1b0>
 80009e6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80009ea:	f43f aefd 	beq.w	80007e8 <__aeabi_dmul+0x1f8>
 80009ee:	4610      	mov	r0, r2
 80009f0:	4619      	mov	r1, r3
 80009f2:	e722      	b.n	800083a <__aeabi_dmul+0x24a>
 80009f4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80009f8:	bf18      	it	ne
 80009fa:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80009fe:	f47f aec5 	bne.w	800078c <__aeabi_dmul+0x19c>
 8000a02:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a06:	f47f af0d 	bne.w	8000824 <__aeabi_dmul+0x234>
 8000a0a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a0e:	f47f aeeb 	bne.w	80007e8 <__aeabi_dmul+0x1f8>
 8000a12:	e712      	b.n	800083a <__aeabi_dmul+0x24a>

08000a14 <__gedf2>:
 8000a14:	f04f 3cff 	mov.w	ip, #4294967295
 8000a18:	e006      	b.n	8000a28 <__cmpdf2+0x4>
 8000a1a:	bf00      	nop

08000a1c <__ledf2>:
 8000a1c:	f04f 0c01 	mov.w	ip, #1
 8000a20:	e002      	b.n	8000a28 <__cmpdf2+0x4>
 8000a22:	bf00      	nop

08000a24 <__cmpdf2>:
 8000a24:	f04f 0c01 	mov.w	ip, #1
 8000a28:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000a2c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000a30:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000a34:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000a38:	bf18      	it	ne
 8000a3a:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000a3e:	d01b      	beq.n	8000a78 <__cmpdf2+0x54>
 8000a40:	b001      	add	sp, #4
 8000a42:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000a46:	bf0c      	ite	eq
 8000a48:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000a4c:	ea91 0f03 	teqne	r1, r3
 8000a50:	bf02      	ittt	eq
 8000a52:	ea90 0f02 	teqeq	r0, r2
 8000a56:	2000      	moveq	r0, #0
 8000a58:	4770      	bxeq	lr
 8000a5a:	f110 0f00 	cmn.w	r0, #0
 8000a5e:	ea91 0f03 	teq	r1, r3
 8000a62:	bf58      	it	pl
 8000a64:	4299      	cmppl	r1, r3
 8000a66:	bf08      	it	eq
 8000a68:	4290      	cmpeq	r0, r2
 8000a6a:	bf2c      	ite	cs
 8000a6c:	17d8      	asrcs	r0, r3, #31
 8000a6e:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000a72:	f040 0001 	orr.w	r0, r0, #1
 8000a76:	4770      	bx	lr
 8000a78:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000a7c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000a80:	d102      	bne.n	8000a88 <__cmpdf2+0x64>
 8000a82:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000a86:	d107      	bne.n	8000a98 <__cmpdf2+0x74>
 8000a88:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000a8c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000a90:	d1d6      	bne.n	8000a40 <__cmpdf2+0x1c>
 8000a92:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000a96:	d0d3      	beq.n	8000a40 <__cmpdf2+0x1c>
 8000a98:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000a9c:	4770      	bx	lr
 8000a9e:	bf00      	nop

08000aa0 <__aeabi_cdrcmple>:
 8000aa0:	4684      	mov	ip, r0
 8000aa2:	4610      	mov	r0, r2
 8000aa4:	4662      	mov	r2, ip
 8000aa6:	468c      	mov	ip, r1
 8000aa8:	4619      	mov	r1, r3
 8000aaa:	4663      	mov	r3, ip
 8000aac:	e000      	b.n	8000ab0 <__aeabi_cdcmpeq>
 8000aae:	bf00      	nop

08000ab0 <__aeabi_cdcmpeq>:
 8000ab0:	b501      	push	{r0, lr}
 8000ab2:	f7ff ffb7 	bl	8000a24 <__cmpdf2>
 8000ab6:	2800      	cmp	r0, #0
 8000ab8:	bf48      	it	mi
 8000aba:	f110 0f00 	cmnmi.w	r0, #0
 8000abe:	bd01      	pop	{r0, pc}

08000ac0 <__aeabi_dcmpeq>:
 8000ac0:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ac4:	f7ff fff4 	bl	8000ab0 <__aeabi_cdcmpeq>
 8000ac8:	bf0c      	ite	eq
 8000aca:	2001      	moveq	r0, #1
 8000acc:	2000      	movne	r0, #0
 8000ace:	f85d fb08 	ldr.w	pc, [sp], #8
 8000ad2:	bf00      	nop

08000ad4 <__aeabi_dcmplt>:
 8000ad4:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ad8:	f7ff ffea 	bl	8000ab0 <__aeabi_cdcmpeq>
 8000adc:	bf34      	ite	cc
 8000ade:	2001      	movcc	r0, #1
 8000ae0:	2000      	movcs	r0, #0
 8000ae2:	f85d fb08 	ldr.w	pc, [sp], #8
 8000ae6:	bf00      	nop

08000ae8 <__aeabi_dcmple>:
 8000ae8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000aec:	f7ff ffe0 	bl	8000ab0 <__aeabi_cdcmpeq>
 8000af0:	bf94      	ite	ls
 8000af2:	2001      	movls	r0, #1
 8000af4:	2000      	movhi	r0, #0
 8000af6:	f85d fb08 	ldr.w	pc, [sp], #8
 8000afa:	bf00      	nop

08000afc <__aeabi_dcmpge>:
 8000afc:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b00:	f7ff ffce 	bl	8000aa0 <__aeabi_cdrcmple>
 8000b04:	bf94      	ite	ls
 8000b06:	2001      	movls	r0, #1
 8000b08:	2000      	movhi	r0, #0
 8000b0a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b0e:	bf00      	nop

08000b10 <__aeabi_dcmpgt>:
 8000b10:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b14:	f7ff ffc4 	bl	8000aa0 <__aeabi_cdrcmple>
 8000b18:	bf34      	ite	cc
 8000b1a:	2001      	movcc	r0, #1
 8000b1c:	2000      	movcs	r0, #0
 8000b1e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b22:	bf00      	nop

08000b24 <__aeabi_d2iz>:
 8000b24:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000b28:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000b2c:	d215      	bcs.n	8000b5a <__aeabi_d2iz+0x36>
 8000b2e:	d511      	bpl.n	8000b54 <__aeabi_d2iz+0x30>
 8000b30:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000b34:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000b38:	d912      	bls.n	8000b60 <__aeabi_d2iz+0x3c>
 8000b3a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000b3e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000b42:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000b46:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000b4a:	fa23 f002 	lsr.w	r0, r3, r2
 8000b4e:	bf18      	it	ne
 8000b50:	4240      	negne	r0, r0
 8000b52:	4770      	bx	lr
 8000b54:	f04f 0000 	mov.w	r0, #0
 8000b58:	4770      	bx	lr
 8000b5a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000b5e:	d105      	bne.n	8000b6c <__aeabi_d2iz+0x48>
 8000b60:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000b64:	bf08      	it	eq
 8000b66:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000b6a:	4770      	bx	lr
 8000b6c:	f04f 0000 	mov.w	r0, #0
 8000b70:	4770      	bx	lr
 8000b72:	bf00      	nop

08000b74 <__aeabi_uldivmod>:
 8000b74:	b953      	cbnz	r3, 8000b8c <__aeabi_uldivmod+0x18>
 8000b76:	b94a      	cbnz	r2, 8000b8c <__aeabi_uldivmod+0x18>
 8000b78:	2900      	cmp	r1, #0
 8000b7a:	bf08      	it	eq
 8000b7c:	2800      	cmpeq	r0, #0
 8000b7e:	bf1c      	itt	ne
 8000b80:	f04f 31ff 	movne.w	r1, #4294967295
 8000b84:	f04f 30ff 	movne.w	r0, #4294967295
 8000b88:	f000 b97e 	b.w	8000e88 <__aeabi_idiv0>
 8000b8c:	f1ad 0c08 	sub.w	ip, sp, #8
 8000b90:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000b94:	f000 f806 	bl	8000ba4 <__udivmoddi4>
 8000b98:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000b9c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000ba0:	b004      	add	sp, #16
 8000ba2:	4770      	bx	lr

08000ba4 <__udivmoddi4>:
 8000ba4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000ba8:	468c      	mov	ip, r1
 8000baa:	460e      	mov	r6, r1
 8000bac:	4604      	mov	r4, r0
 8000bae:	9d08      	ldr	r5, [sp, #32]
 8000bb0:	2b00      	cmp	r3, #0
 8000bb2:	d150      	bne.n	8000c56 <__udivmoddi4+0xb2>
 8000bb4:	428a      	cmp	r2, r1
 8000bb6:	4617      	mov	r7, r2
 8000bb8:	d96c      	bls.n	8000c94 <__udivmoddi4+0xf0>
 8000bba:	fab2 fe82 	clz	lr, r2
 8000bbe:	f1be 0f00 	cmp.w	lr, #0
 8000bc2:	d00b      	beq.n	8000bdc <__udivmoddi4+0x38>
 8000bc4:	f1ce 0420 	rsb	r4, lr, #32
 8000bc8:	fa20 f404 	lsr.w	r4, r0, r4
 8000bcc:	fa01 f60e 	lsl.w	r6, r1, lr
 8000bd0:	ea44 0c06 	orr.w	ip, r4, r6
 8000bd4:	fa02 f70e 	lsl.w	r7, r2, lr
 8000bd8:	fa00 f40e 	lsl.w	r4, r0, lr
 8000bdc:	ea4f 4917 	mov.w	r9, r7, lsr #16
 8000be0:	0c22      	lsrs	r2, r4, #16
 8000be2:	fbbc f0f9 	udiv	r0, ip, r9
 8000be6:	fa1f f887 	uxth.w	r8, r7
 8000bea:	fb09 c610 	mls	r6, r9, r0, ip
 8000bee:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
 8000bf2:	fb00 f308 	mul.w	r3, r0, r8
 8000bf6:	42b3      	cmp	r3, r6
 8000bf8:	d909      	bls.n	8000c0e <__udivmoddi4+0x6a>
 8000bfa:	19f6      	adds	r6, r6, r7
 8000bfc:	f100 32ff 	add.w	r2, r0, #4294967295
 8000c00:	f080 8122 	bcs.w	8000e48 <__udivmoddi4+0x2a4>
 8000c04:	42b3      	cmp	r3, r6
 8000c06:	f240 811f 	bls.w	8000e48 <__udivmoddi4+0x2a4>
 8000c0a:	3802      	subs	r0, #2
 8000c0c:	443e      	add	r6, r7
 8000c0e:	1af6      	subs	r6, r6, r3
 8000c10:	b2a2      	uxth	r2, r4
 8000c12:	fbb6 f3f9 	udiv	r3, r6, r9
 8000c16:	fb09 6613 	mls	r6, r9, r3, r6
 8000c1a:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
 8000c1e:	fb03 f808 	mul.w	r8, r3, r8
 8000c22:	45a0      	cmp	r8, r4
 8000c24:	d909      	bls.n	8000c3a <__udivmoddi4+0x96>
 8000c26:	19e4      	adds	r4, r4, r7
 8000c28:	f103 32ff 	add.w	r2, r3, #4294967295
 8000c2c:	f080 810a 	bcs.w	8000e44 <__udivmoddi4+0x2a0>
 8000c30:	45a0      	cmp	r8, r4
 8000c32:	f240 8107 	bls.w	8000e44 <__udivmoddi4+0x2a0>
 8000c36:	3b02      	subs	r3, #2
 8000c38:	443c      	add	r4, r7
 8000c3a:	ebc8 0404 	rsb	r4, r8, r4
 8000c3e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8000c42:	2100      	movs	r1, #0
 8000c44:	2d00      	cmp	r5, #0
 8000c46:	d062      	beq.n	8000d0e <__udivmoddi4+0x16a>
 8000c48:	fa24 f40e 	lsr.w	r4, r4, lr
 8000c4c:	2300      	movs	r3, #0
 8000c4e:	602c      	str	r4, [r5, #0]
 8000c50:	606b      	str	r3, [r5, #4]
 8000c52:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000c56:	428b      	cmp	r3, r1
 8000c58:	d907      	bls.n	8000c6a <__udivmoddi4+0xc6>
 8000c5a:	2d00      	cmp	r5, #0
 8000c5c:	d055      	beq.n	8000d0a <__udivmoddi4+0x166>
 8000c5e:	2100      	movs	r1, #0
 8000c60:	e885 0041 	stmia.w	r5, {r0, r6}
 8000c64:	4608      	mov	r0, r1
 8000c66:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000c6a:	fab3 f183 	clz	r1, r3
 8000c6e:	2900      	cmp	r1, #0
 8000c70:	f040 8090 	bne.w	8000d94 <__udivmoddi4+0x1f0>
 8000c74:	42b3      	cmp	r3, r6
 8000c76:	d302      	bcc.n	8000c7e <__udivmoddi4+0xda>
 8000c78:	4282      	cmp	r2, r0
 8000c7a:	f200 80f8 	bhi.w	8000e6e <__udivmoddi4+0x2ca>
 8000c7e:	1a84      	subs	r4, r0, r2
 8000c80:	eb66 0603 	sbc.w	r6, r6, r3
 8000c84:	2001      	movs	r0, #1
 8000c86:	46b4      	mov	ip, r6
 8000c88:	2d00      	cmp	r5, #0
 8000c8a:	d040      	beq.n	8000d0e <__udivmoddi4+0x16a>
 8000c8c:	e885 1010 	stmia.w	r5, {r4, ip}
 8000c90:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000c94:	b912      	cbnz	r2, 8000c9c <__udivmoddi4+0xf8>
 8000c96:	2701      	movs	r7, #1
 8000c98:	fbb7 f7f2 	udiv	r7, r7, r2
 8000c9c:	fab7 fe87 	clz	lr, r7
 8000ca0:	f1be 0f00 	cmp.w	lr, #0
 8000ca4:	d135      	bne.n	8000d12 <__udivmoddi4+0x16e>
 8000ca6:	1bf3      	subs	r3, r6, r7
 8000ca8:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8000cac:	fa1f fc87 	uxth.w	ip, r7
 8000cb0:	2101      	movs	r1, #1
 8000cb2:	fbb3 f0f8 	udiv	r0, r3, r8
 8000cb6:	0c22      	lsrs	r2, r4, #16
 8000cb8:	fb08 3610 	mls	r6, r8, r0, r3
 8000cbc:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
 8000cc0:	fb0c f300 	mul.w	r3, ip, r0
 8000cc4:	42b3      	cmp	r3, r6
 8000cc6:	d907      	bls.n	8000cd8 <__udivmoddi4+0x134>
 8000cc8:	19f6      	adds	r6, r6, r7
 8000cca:	f100 32ff 	add.w	r2, r0, #4294967295
 8000cce:	d202      	bcs.n	8000cd6 <__udivmoddi4+0x132>
 8000cd0:	42b3      	cmp	r3, r6
 8000cd2:	f200 80ce 	bhi.w	8000e72 <__udivmoddi4+0x2ce>
 8000cd6:	4610      	mov	r0, r2
 8000cd8:	1af6      	subs	r6, r6, r3
 8000cda:	b2a2      	uxth	r2, r4
 8000cdc:	fbb6 f3f8 	udiv	r3, r6, r8
 8000ce0:	fb08 6613 	mls	r6, r8, r3, r6
 8000ce4:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
 8000ce8:	fb0c fc03 	mul.w	ip, ip, r3
 8000cec:	45a4      	cmp	ip, r4
 8000cee:	d907      	bls.n	8000d00 <__udivmoddi4+0x15c>
 8000cf0:	19e4      	adds	r4, r4, r7
 8000cf2:	f103 32ff 	add.w	r2, r3, #4294967295
 8000cf6:	d202      	bcs.n	8000cfe <__udivmoddi4+0x15a>
 8000cf8:	45a4      	cmp	ip, r4
 8000cfa:	f200 80b5 	bhi.w	8000e68 <__udivmoddi4+0x2c4>
 8000cfe:	4613      	mov	r3, r2
 8000d00:	ebcc 0404 	rsb	r4, ip, r4
 8000d04:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8000d08:	e79c      	b.n	8000c44 <__udivmoddi4+0xa0>
 8000d0a:	4629      	mov	r1, r5
 8000d0c:	4628      	mov	r0, r5
 8000d0e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000d12:	f1ce 0120 	rsb	r1, lr, #32
 8000d16:	fa06 f30e 	lsl.w	r3, r6, lr
 8000d1a:	fa07 f70e 	lsl.w	r7, r7, lr
 8000d1e:	fa20 f901 	lsr.w	r9, r0, r1
 8000d22:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8000d26:	40ce      	lsrs	r6, r1
 8000d28:	ea49 0903 	orr.w	r9, r9, r3
 8000d2c:	fbb6 faf8 	udiv	sl, r6, r8
 8000d30:	ea4f 4419 	mov.w	r4, r9, lsr #16
 8000d34:	fb08 661a 	mls	r6, r8, sl, r6
 8000d38:	fa1f fc87 	uxth.w	ip, r7
 8000d3c:	ea44 4306 	orr.w	r3, r4, r6, lsl #16
 8000d40:	fb0a f20c 	mul.w	r2, sl, ip
 8000d44:	429a      	cmp	r2, r3
 8000d46:	fa00 f40e 	lsl.w	r4, r0, lr
 8000d4a:	d90a      	bls.n	8000d62 <__udivmoddi4+0x1be>
 8000d4c:	19db      	adds	r3, r3, r7
 8000d4e:	f10a 31ff 	add.w	r1, sl, #4294967295
 8000d52:	f080 8087 	bcs.w	8000e64 <__udivmoddi4+0x2c0>
 8000d56:	429a      	cmp	r2, r3
 8000d58:	f240 8084 	bls.w	8000e64 <__udivmoddi4+0x2c0>
 8000d5c:	f1aa 0a02 	sub.w	sl, sl, #2
 8000d60:	443b      	add	r3, r7
 8000d62:	1a9b      	subs	r3, r3, r2
 8000d64:	fa1f f989 	uxth.w	r9, r9
 8000d68:	fbb3 f1f8 	udiv	r1, r3, r8
 8000d6c:	fb08 3311 	mls	r3, r8, r1, r3
 8000d70:	ea49 4303 	orr.w	r3, r9, r3, lsl #16
 8000d74:	fb01 f60c 	mul.w	r6, r1, ip
 8000d78:	429e      	cmp	r6, r3
 8000d7a:	d907      	bls.n	8000d8c <__udivmoddi4+0x1e8>
 8000d7c:	19db      	adds	r3, r3, r7
 8000d7e:	f101 32ff 	add.w	r2, r1, #4294967295
 8000d82:	d26b      	bcs.n	8000e5c <__udivmoddi4+0x2b8>
 8000d84:	429e      	cmp	r6, r3
 8000d86:	d969      	bls.n	8000e5c <__udivmoddi4+0x2b8>
 8000d88:	3902      	subs	r1, #2
 8000d8a:	443b      	add	r3, r7
 8000d8c:	1b9b      	subs	r3, r3, r6
 8000d8e:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
 8000d92:	e78e      	b.n	8000cb2 <__udivmoddi4+0x10e>
 8000d94:	f1c1 0e20 	rsb	lr, r1, #32
 8000d98:	fa22 f40e 	lsr.w	r4, r2, lr
 8000d9c:	408b      	lsls	r3, r1
 8000d9e:	4323      	orrs	r3, r4
 8000da0:	fa20 f70e 	lsr.w	r7, r0, lr
 8000da4:	fa06 f401 	lsl.w	r4, r6, r1
 8000da8:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 8000dac:	fa26 f60e 	lsr.w	r6, r6, lr
 8000db0:	433c      	orrs	r4, r7
 8000db2:	fbb6 f9fc 	udiv	r9, r6, ip
 8000db6:	0c27      	lsrs	r7, r4, #16
 8000db8:	fb0c 6619 	mls	r6, ip, r9, r6
 8000dbc:	fa1f f883 	uxth.w	r8, r3
 8000dc0:	ea47 4606 	orr.w	r6, r7, r6, lsl #16
 8000dc4:	fb09 f708 	mul.w	r7, r9, r8
 8000dc8:	42b7      	cmp	r7, r6
 8000dca:	fa02 f201 	lsl.w	r2, r2, r1
 8000dce:	fa00 fa01 	lsl.w	sl, r0, r1
 8000dd2:	d908      	bls.n	8000de6 <__udivmoddi4+0x242>
 8000dd4:	18f6      	adds	r6, r6, r3
 8000dd6:	f109 30ff 	add.w	r0, r9, #4294967295
 8000dda:	d241      	bcs.n	8000e60 <__udivmoddi4+0x2bc>
 8000ddc:	42b7      	cmp	r7, r6
 8000dde:	d93f      	bls.n	8000e60 <__udivmoddi4+0x2bc>
 8000de0:	f1a9 0902 	sub.w	r9, r9, #2
 8000de4:	441e      	add	r6, r3
 8000de6:	1bf6      	subs	r6, r6, r7
 8000de8:	b2a0      	uxth	r0, r4
 8000dea:	fbb6 f4fc 	udiv	r4, r6, ip
 8000dee:	fb0c 6614 	mls	r6, ip, r4, r6
 8000df2:	ea40 4706 	orr.w	r7, r0, r6, lsl #16
 8000df6:	fb04 f808 	mul.w	r8, r4, r8
 8000dfa:	45b8      	cmp	r8, r7
 8000dfc:	d907      	bls.n	8000e0e <__udivmoddi4+0x26a>
 8000dfe:	18ff      	adds	r7, r7, r3
 8000e00:	f104 30ff 	add.w	r0, r4, #4294967295
 8000e04:	d228      	bcs.n	8000e58 <__udivmoddi4+0x2b4>
 8000e06:	45b8      	cmp	r8, r7
 8000e08:	d926      	bls.n	8000e58 <__udivmoddi4+0x2b4>
 8000e0a:	3c02      	subs	r4, #2
 8000e0c:	441f      	add	r7, r3
 8000e0e:	ea44 4009 	orr.w	r0, r4, r9, lsl #16
 8000e12:	ebc8 0707 	rsb	r7, r8, r7
 8000e16:	fba0 8902 	umull	r8, r9, r0, r2
 8000e1a:	454f      	cmp	r7, r9
 8000e1c:	4644      	mov	r4, r8
 8000e1e:	464e      	mov	r6, r9
 8000e20:	d314      	bcc.n	8000e4c <__udivmoddi4+0x2a8>
 8000e22:	d029      	beq.n	8000e78 <__udivmoddi4+0x2d4>
 8000e24:	b365      	cbz	r5, 8000e80 <__udivmoddi4+0x2dc>
 8000e26:	ebba 0304 	subs.w	r3, sl, r4
 8000e2a:	eb67 0706 	sbc.w	r7, r7, r6
 8000e2e:	fa07 fe0e 	lsl.w	lr, r7, lr
 8000e32:	40cb      	lsrs	r3, r1
 8000e34:	40cf      	lsrs	r7, r1
 8000e36:	ea4e 0303 	orr.w	r3, lr, r3
 8000e3a:	e885 0088 	stmia.w	r5, {r3, r7}
 8000e3e:	2100      	movs	r1, #0
 8000e40:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000e44:	4613      	mov	r3, r2
 8000e46:	e6f8      	b.n	8000c3a <__udivmoddi4+0x96>
 8000e48:	4610      	mov	r0, r2
 8000e4a:	e6e0      	b.n	8000c0e <__udivmoddi4+0x6a>
 8000e4c:	ebb8 0402 	subs.w	r4, r8, r2
 8000e50:	eb69 0603 	sbc.w	r6, r9, r3
 8000e54:	3801      	subs	r0, #1
 8000e56:	e7e5      	b.n	8000e24 <__udivmoddi4+0x280>
 8000e58:	4604      	mov	r4, r0
 8000e5a:	e7d8      	b.n	8000e0e <__udivmoddi4+0x26a>
 8000e5c:	4611      	mov	r1, r2
 8000e5e:	e795      	b.n	8000d8c <__udivmoddi4+0x1e8>
 8000e60:	4681      	mov	r9, r0
 8000e62:	e7c0      	b.n	8000de6 <__udivmoddi4+0x242>
 8000e64:	468a      	mov	sl, r1
 8000e66:	e77c      	b.n	8000d62 <__udivmoddi4+0x1be>
 8000e68:	3b02      	subs	r3, #2
 8000e6a:	443c      	add	r4, r7
 8000e6c:	e748      	b.n	8000d00 <__udivmoddi4+0x15c>
 8000e6e:	4608      	mov	r0, r1
 8000e70:	e70a      	b.n	8000c88 <__udivmoddi4+0xe4>
 8000e72:	3802      	subs	r0, #2
 8000e74:	443e      	add	r6, r7
 8000e76:	e72f      	b.n	8000cd8 <__udivmoddi4+0x134>
 8000e78:	45c2      	cmp	sl, r8
 8000e7a:	d3e7      	bcc.n	8000e4c <__udivmoddi4+0x2a8>
 8000e7c:	463e      	mov	r6, r7
 8000e7e:	e7d1      	b.n	8000e24 <__udivmoddi4+0x280>
 8000e80:	4629      	mov	r1, r5
 8000e82:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000e86:	bf00      	nop

08000e88 <__aeabi_idiv0>:
 8000e88:	4770      	bx	lr
 8000e8a:	bf00      	nop

08000e8c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000e8c:	b510      	push	{r4, lr}
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000);
 8000e8e:	4b08      	ldr	r3, [pc, #32]	; (8000eb0 <HAL_InitTick+0x24>)
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000e90:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000);
 8000e92:	6818      	ldr	r0, [r3, #0]
 8000e94:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000e98:	fbb0 f0f3 	udiv	r0, r0, r3
 8000e9c:	f000 f878 	bl	8000f90 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 8000ea0:	2200      	movs	r2, #0
 8000ea2:	4621      	mov	r1, r4
 8000ea4:	f04f 30ff 	mov.w	r0, #4294967295
 8000ea8:	f000 f83e 	bl	8000f28 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 8000eac:	2000      	movs	r0, #0
 8000eae:	bd10      	pop	{r4, pc}
 8000eb0:	200000a8 	.word	0x200000a8

08000eb4 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8000eb4:	b508      	push	{r3, lr}
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000eb6:	2003      	movs	r0, #3
 8000eb8:	f000 f824 	bl	8000f04 <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8000ebc:	2000      	movs	r0, #0
 8000ebe:	f7ff ffe5 	bl	8000e8c <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8000ec2:	f002 fda9 	bl	8003a18 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 8000ec6:	2000      	movs	r0, #0
 8000ec8:	bd08      	pop	{r3, pc}
	...

08000ecc <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000ecc:	4a02      	ldr	r2, [pc, #8]	; (8000ed8 <HAL_IncTick+0xc>)
 8000ece:	6813      	ldr	r3, [r2, #0]
 8000ed0:	3301      	adds	r3, #1
 8000ed2:	6013      	str	r3, [r2, #0]
 8000ed4:	4770      	bx	lr
 8000ed6:	bf00      	nop
 8000ed8:	2000015c 	.word	0x2000015c

08000edc <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000edc:	4b01      	ldr	r3, [pc, #4]	; (8000ee4 <HAL_GetTick+0x8>)
 8000ede:	6818      	ldr	r0, [r3, #0]
}
 8000ee0:	4770      	bx	lr
 8000ee2:	bf00      	nop
 8000ee4:	2000015c 	.word	0x2000015c

08000ee8 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000ee8:	b538      	push	{r3, r4, r5, lr}
 8000eea:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000eec:	f7ff fff6 	bl	8000edc <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 8000ef0:	1c63      	adds	r3, r4, #1
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
  uint32_t tickstart = HAL_GetTick();
 8000ef2:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
  {
    wait++;
 8000ef4:	bf18      	it	ne
 8000ef6:	3401      	addne	r4, #1
  } 

  while((HAL_GetTick() - tickstart) < wait)
 8000ef8:	f7ff fff0 	bl	8000edc <HAL_GetTick>
 8000efc:	1b40      	subs	r0, r0, r5
 8000efe:	4284      	cmp	r4, r0
 8000f00:	d8fa      	bhi.n	8000ef8 <HAL_Delay+0x10>
  {
  }
}
 8000f02:	bd38      	pop	{r3, r4, r5, pc}

08000f04 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000f04:	4a07      	ldr	r2, [pc, #28]	; (8000f24 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8000f06:	68d3      	ldr	r3, [r2, #12]
 8000f08:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000f0c:	041b      	lsls	r3, r3, #16
 8000f0e:	0c1b      	lsrs	r3, r3, #16
 8000f10:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8000f14:	0200      	lsls	r0, r0, #8
 8000f16:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000f1a:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 8000f1e:	4303      	orrs	r3, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000f20:	60d3      	str	r3, [r2, #12]
 8000f22:	4770      	bx	lr
 8000f24:	e000ed00 	.word	0xe000ed00

08000f28 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000f28:	4b17      	ldr	r3, [pc, #92]	; (8000f88 <HAL_NVIC_SetPriority+0x60>)
 8000f2a:	68db      	ldr	r3, [r3, #12]
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8000f2c:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8000f30:	b530      	push	{r4, r5, lr}
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000f32:	f1c3 0407 	rsb	r4, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000f36:	1d1d      	adds	r5, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000f38:	2c04      	cmp	r4, #4
 8000f3a:	bf28      	it	cs
 8000f3c:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000f3e:	2d06      	cmp	r5, #6

  return (
 8000f40:	f04f 0501 	mov.w	r5, #1
 8000f44:	fa05 f404 	lsl.w	r4, r5, r4
 8000f48:	f104 34ff 	add.w	r4, r4, #4294967295
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000f4c:	bf8c      	ite	hi
 8000f4e:	3b03      	subhi	r3, #3
 8000f50:	2300      	movls	r3, #0

  return (
 8000f52:	400c      	ands	r4, r1
 8000f54:	409c      	lsls	r4, r3
 8000f56:	fa05 f303 	lsl.w	r3, r5, r3
 8000f5a:	3b01      	subs	r3, #1
 8000f5c:	401a      	ands	r2, r3
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8000f5e:	2800      	cmp	r0, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8000f60:	ea42 0204 	orr.w	r2, r2, r4
 8000f64:	ea4f 1202 	mov.w	r2, r2, lsl #4
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f68:	bfaf      	iteee	ge
 8000f6a:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f6e:	f000 000f 	andlt.w	r0, r0, #15
 8000f72:	4b06      	ldrlt	r3, [pc, #24]	; (8000f8c <HAL_NVIC_SetPriority+0x64>)
 8000f74:	b2d2      	uxtblt	r2, r2
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f76:	bfa5      	ittet	ge
 8000f78:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 8000f7c:	b2d2      	uxtbge	r2, r2
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f7e:	541a      	strblt	r2, [r3, r0]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f80:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 8000f84:	bd30      	pop	{r4, r5, pc}
 8000f86:	bf00      	nop
 8000f88:	e000ed00 	.word	0xe000ed00
 8000f8c:	e000ed14 	.word	0xe000ed14

08000f90 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000f90:	3801      	subs	r0, #1
 8000f92:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000f96:	d20a      	bcs.n	8000fae <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000f98:	4b06      	ldr	r3, [pc, #24]	; (8000fb4 <HAL_SYSTICK_Config+0x24>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f9a:	4a07      	ldr	r2, [pc, #28]	; (8000fb8 <HAL_SYSTICK_Config+0x28>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000f9c:	6058      	str	r0, [r3, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f9e:	21f0      	movs	r1, #240	; 0xf0
 8000fa0:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000fa4:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000fa6:	2207      	movs	r2, #7
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000fa8:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000faa:	601a      	str	r2, [r3, #0]
 8000fac:	4770      	bx	lr
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
 8000fae:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000fb0:	4770      	bx	lr
 8000fb2:	bf00      	nop
 8000fb4:	e000e010 	.word	0xe000e010
 8000fb8:	e000ed00 	.word	0xe000ed00

08000fbc <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 8000fbc:	4b04      	ldr	r3, [pc, #16]	; (8000fd0 <HAL_SYSTICK_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000fbe:	681a      	ldr	r2, [r3, #0]
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8000fc0:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000fc2:	bf0c      	ite	eq
 8000fc4:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8000fc8:	f022 0204 	bicne.w	r2, r2, #4
 8000fcc:	601a      	str	r2, [r3, #0]
 8000fce:	4770      	bx	lr
 8000fd0:	e000e010 	.word	0xe000e010

08000fd4 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 8000fd4:	4770      	bx	lr

08000fd6 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  Handle SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 8000fd6:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 8000fd8:	f7ff fffc 	bl	8000fd4 <HAL_SYSTICK_Callback>
 8000fdc:	bd08      	pop	{r3, pc}
	...

08000fe0 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000fe0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000fe4:	b085      	sub	sp, #20
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000fe6:	680b      	ldr	r3, [r1, #0]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000fe8:	f8df c168 	ldr.w	ip, [pc, #360]	; 8001154 <HAL_GPIO_Init+0x174>
 8000fec:	4c57      	ldr	r4, [pc, #348]	; (800114c <HAL_GPIO_Init+0x16c>)
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000fee:	9301      	str	r3, [sp, #4]
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000ff0:	f04f 080f 	mov.w	r8, #15
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  uint32_t position = 0x00;
 8000ff4:	2300      	movs	r3, #0
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000ff6:	9a01      	ldr	r2, [sp, #4]
 8000ff8:	40da      	lsrs	r2, r3
 8000ffa:	f000 80a4 	beq.w	8001146 <HAL_GPIO_Init+0x166>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 8000ffe:	2201      	movs	r2, #1
 8001000:	fa02 f903 	lsl.w	r9, r2, r3

    if(iocurrent)
 8001004:	9a01      	ldr	r2, [sp, #4]
 8001006:	ea12 0509 	ands.w	r5, r2, r9
 800100a:	f000 809a 	beq.w	8001142 <HAL_GPIO_Init+0x162>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800100e:	684a      	ldr	r2, [r1, #4]
 8001010:	f022 0a10 	bic.w	sl, r2, #16
 8001014:	f1ba 0f02 	cmp.w	sl, #2
 8001018:	d113      	bne.n	8001042 <HAL_GPIO_Init+0x62>
 800101a:	ea4f 0ed3 	mov.w	lr, r3, lsr #3
 800101e:	eb00 0e8e 	add.w	lr, r0, lr, lsl #2
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8001022:	f003 0b07 	and.w	fp, r3, #7
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 8001026:	f8de 7020 	ldr.w	r7, [lr, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800102a:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 800102e:	fa08 f60b 	lsl.w	r6, r8, fp
 8001032:	ea27 0706 	bic.w	r7, r7, r6
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8001036:	690e      	ldr	r6, [r1, #16]
 8001038:	fa06 f60b 	lsl.w	r6, r6, fp
 800103c:	433e      	orrs	r6, r7
        GPIOx->AFR[position >> 3] = temp;
 800103e:	f8ce 6020 	str.w	r6, [lr, #32]
 8001042:	ea4f 0e43 	mov.w	lr, r3, lsl #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 8001046:	2603      	movs	r6, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8001048:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 800104a:	fa06 f60e 	lsl.w	r6, r6, lr
 800104e:	43f6      	mvns	r6, r6
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001050:	f002 0b03 	and.w	fp, r2, #3
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 8001054:	4037      	ands	r7, r6
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001056:	fa0b fb0e 	lsl.w	fp, fp, lr
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800105a:	f10a 3aff 	add.w	sl, sl, #4294967295
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800105e:	ea4b 0707 	orr.w	r7, fp, r7
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001062:	f1ba 0f01 	cmp.w	sl, #1

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
      GPIOx->MODER = temp;
 8001066:	6007      	str	r7, [r0, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001068:	d811      	bhi.n	800108e <HAL_GPIO_Init+0xae>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 800106a:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2));
 800106c:	ea06 0a07 	and.w	sl, r6, r7
        temp |= (GPIO_Init->Speed << (position * 2));
 8001070:	68cf      	ldr	r7, [r1, #12]
 8001072:	fa07 f70e 	lsl.w	r7, r7, lr
 8001076:	ea47 070a 	orr.w	r7, r7, sl
        GPIOx->OSPEEDR = temp;
 800107a:	6087      	str	r7, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 800107c:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 800107e:	ea27 0909 	bic.w	r9, r7, r9
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8001082:	f3c2 1700 	ubfx	r7, r2, #4, #1
 8001086:	409f      	lsls	r7, r3
 8001088:	ea47 0709 	orr.w	r7, r7, r9
        GPIOx->OTYPER = temp;
 800108c:	6047      	str	r7, [r0, #4]
      }

#endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 800108e:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2));
 8001090:	403e      	ands	r6, r7
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8001092:	688f      	ldr	r7, [r1, #8]
 8001094:	fa07 f70e 	lsl.w	r7, r7, lr
 8001098:	433e      	orrs	r6, r7
      GPIOx->PUPDR = temp;
 800109a:	60c6      	str	r6, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800109c:	00d6      	lsls	r6, r2, #3
 800109e:	d550      	bpl.n	8001142 <HAL_GPIO_Init+0x162>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80010a0:	f8dc 6060 	ldr.w	r6, [ip, #96]	; 0x60
 80010a4:	f046 0601 	orr.w	r6, r6, #1
 80010a8:	f8cc 6060 	str.w	r6, [ip, #96]	; 0x60
 80010ac:	f8dc 6060 	ldr.w	r6, [ip, #96]	; 0x60
 80010b0:	f006 0601 	and.w	r6, r6, #1
 80010b4:	9603      	str	r6, [sp, #12]
 80010b6:	9e03      	ldr	r6, [sp, #12]
 80010b8:	f023 0603 	bic.w	r6, r3, #3
 80010bc:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
 80010c0:	f506 3680 	add.w	r6, r6, #65536	; 0x10000

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80010c4:	f003 0903 	and.w	r9, r3, #3
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
 80010c8:	68b7      	ldr	r7, [r6, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80010ca:	ea4f 0989 	mov.w	r9, r9, lsl #2
 80010ce:	fa08 fe09 	lsl.w	lr, r8, r9
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 80010d2:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80010d6:	ea27 0a0e 	bic.w	sl, r7, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 80010da:	d00b      	beq.n	80010f4 <HAL_GPIO_Init+0x114>
 80010dc:	4f1c      	ldr	r7, [pc, #112]	; (8001150 <HAL_GPIO_Init+0x170>)
 80010de:	42b8      	cmp	r0, r7
 80010e0:	d00b      	beq.n	80010fa <HAL_GPIO_Init+0x11a>
 80010e2:	f507 6780 	add.w	r7, r7, #1024	; 0x400
 80010e6:	42b8      	cmp	r0, r7
 80010e8:	bf14      	ite	ne
 80010ea:	f04f 0e07 	movne.w	lr, #7
 80010ee:	f04f 0e02 	moveq.w	lr, #2
 80010f2:	e004      	b.n	80010fe <HAL_GPIO_Init+0x11e>
 80010f4:	f04f 0e00 	mov.w	lr, #0
 80010f8:	e001      	b.n	80010fe <HAL_GPIO_Init+0x11e>
 80010fa:	f04f 0e01 	mov.w	lr, #1
 80010fe:	fa0e f909 	lsl.w	r9, lr, r9
 8001102:	ea49 070a 	orr.w	r7, r9, sl
        SYSCFG->EXTICR[position >> 2] = temp;
 8001106:	60b7      	str	r7, [r6, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8001108:	4e10      	ldr	r6, [pc, #64]	; (800114c <HAL_GPIO_Init+0x16c>)
 800110a:	6836      	ldr	r6, [r6, #0]
        temp &= ~((uint32_t)iocurrent);
 800110c:	43ef      	mvns	r7, r5
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800110e:	f412 3f80 	tst.w	r2, #65536	; 0x10000
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
        temp &= ~((uint32_t)iocurrent);
 8001112:	bf0c      	ite	eq
 8001114:	403e      	andeq	r6, r7
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
 8001116:	432e      	orrne	r6, r5
        }
        EXTI->IMR1 = temp;
 8001118:	6026      	str	r6, [r4, #0]

        temp = EXTI->EMR1;
 800111a:	6866      	ldr	r6, [r4, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800111c:	f412 3f00 	tst.w	r2, #131072	; 0x20000
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;

        temp = EXTI->EMR1;
        temp &= ~((uint32_t)iocurrent);
 8001120:	bf0c      	ite	eq
 8001122:	403e      	andeq	r6, r7
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
 8001124:	432e      	orrne	r6, r5
        }
        EXTI->EMR1 = temp;
 8001126:	6066      	str	r6, [r4, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8001128:	68a6      	ldr	r6, [r4, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800112a:	f412 1f80 	tst.w	r2, #1048576	; 0x100000
        }
        EXTI->EMR1 = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
        temp &= ~((uint32_t)iocurrent);
 800112e:	bf0c      	ite	eq
 8001130:	403e      	andeq	r6, r7
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
 8001132:	432e      	orrne	r6, r5
        }
        EXTI->RTSR1 = temp;
 8001134:	60a6      	str	r6, [r4, #8]

        temp = EXTI->FTSR1;
 8001136:	68e6      	ldr	r6, [r4, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001138:	0292      	lsls	r2, r2, #10
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;

        temp = EXTI->FTSR1;
        temp &= ~((uint32_t)iocurrent);
 800113a:	bf54      	ite	pl
 800113c:	403e      	andpl	r6, r7
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 800113e:	432e      	orrmi	r6, r5
        }
        EXTI->FTSR1 = temp;
 8001140:	60e6      	str	r6, [r4, #12]
      }
    }
    
    position++;
 8001142:	3301      	adds	r3, #1
 8001144:	e757      	b.n	8000ff6 <HAL_GPIO_Init+0x16>
  }
}
 8001146:	b005      	add	sp, #20
 8001148:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800114c:	40010400 	.word	0x40010400
 8001150:	48000400 	.word	0x48000400
 8001154:	40021000 	.word	0x40021000

08001158 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8001158:	b10a      	cbz	r2, 800115e <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 800115a:	6181      	str	r1, [r0, #24]
 800115c:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 800115e:	6281      	str	r1, [r0, #40]	; 0x28
 8001160:	4770      	bx	lr
	...

08001164 <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_RANGE1 or PWR_REGULATOR_VOLTAGE_RANGE2)
  */  
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return  (PWR->CR1 & PWR_CR1_VOS);
 8001164:	4b02      	ldr	r3, [pc, #8]	; (8001170 <HAL_PWREx_GetVoltageRange+0xc>)
 8001166:	6818      	ldr	r0, [r3, #0]
}
 8001168:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 800116c:	4770      	bx	lr
 800116e:	bf00      	nop
 8001170:	40007000 	.word	0x40007000

08001174 <HAL_PWREx_ControlVoltageScaling>:
  *        cleared before returning the status. If the flag is not cleared within
  *        50 microseconds, HAL_TIMEOUT status is reported.                    
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
 8001174:	4b17      	ldr	r3, [pc, #92]	; (80011d4 <HAL_PWREx_ControlVoltageScaling+0x60>)
  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
  
  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 8001176:	681a      	ldr	r2, [r3, #0]
  uint32_t wait_loop_index = 0;  

  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
  
  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 8001178:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 800117c:	f402 62c0 	and.w	r2, r2, #1536	; 0x600
  uint32_t wait_loop_index = 0;  

  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
  
  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 8001180:	d11a      	bne.n	80011b8 <HAL_PWREx_ControlVoltageScaling+0x44>
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 8001182:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8001186:	d020      	beq.n	80011ca <HAL_PWREx_ControlVoltageScaling+0x56>
    {
      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8001188:	681a      	ldr	r2, [r3, #0]
      
      /* Wait until VOSF is cleared */      
      wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 800118a:	4913      	ldr	r1, [pc, #76]	; (80011d8 <HAL_PWREx_ControlVoltageScaling+0x64>)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
    {
      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 800118c:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 8001190:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8001194:	601a      	str	r2, [r3, #0]
      
      /* Wait until VOSF is cleared */      
      wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 8001196:	4a11      	ldr	r2, [pc, #68]	; (80011dc <HAL_PWREx_ControlVoltageScaling+0x68>)
 8001198:	6812      	ldr	r2, [r2, #0]
 800119a:	fbb2 f1f1 	udiv	r1, r2, r1
 800119e:	2232      	movs	r2, #50	; 0x32
 80011a0:	434a      	muls	r2, r1
      while ((wait_loop_index != 0) && (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)))
 80011a2:	b122      	cbz	r2, 80011ae <HAL_PWREx_ControlVoltageScaling+0x3a>
 80011a4:	6959      	ldr	r1, [r3, #20]
 80011a6:	0549      	lsls	r1, r1, #21
 80011a8:	d501      	bpl.n	80011ae <HAL_PWREx_ControlVoltageScaling+0x3a>
      {
        wait_loop_index--;
 80011aa:	3a01      	subs	r2, #1
 80011ac:	e7f9      	b.n	80011a2 <HAL_PWREx_ControlVoltageScaling+0x2e>
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 80011ae:	4b09      	ldr	r3, [pc, #36]	; (80011d4 <HAL_PWREx_ControlVoltageScaling+0x60>)
 80011b0:	695b      	ldr	r3, [r3, #20]
 80011b2:	055b      	lsls	r3, r3, #21
 80011b4:	d40b      	bmi.n	80011ce <HAL_PWREx_ControlVoltageScaling+0x5a>
 80011b6:	e008      	b.n	80011ca <HAL_PWREx_ControlVoltageScaling+0x56>
      }
    }
  }
  else
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE2)
 80011b8:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
    {
      /* Set Range 2 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 80011bc:	bf1f      	itttt	ne
 80011be:	681a      	ldrne	r2, [r3, #0]
 80011c0:	f422 62c0 	bicne.w	r2, r2, #1536	; 0x600
 80011c4:	f442 6280 	orrne.w	r2, r2, #1024	; 0x400
 80011c8:	601a      	strne	r2, [r3, #0]
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
  
  return HAL_OK;
 80011ca:	2000      	movs	r0, #0
 80011cc:	4770      	bx	lr
      {
        wait_loop_index--;
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
      {
        return HAL_TIMEOUT;
 80011ce:	2003      	movs	r0, #3
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
  
  return HAL_OK;
}  
 80011d0:	4770      	bx	lr
 80011d2:	bf00      	nop
 80011d4:	40007000 	.word	0x40007000
 80011d8:	000f4240 	.word	0x000f4240
 80011dc:	200000a8 	.word	0x200000a8

080011e0 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 80011e0:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
  
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 80011e2:	4d1e      	ldr	r5, [pc, #120]	; (800125c <RCC_SetFlashLatencyFromMSIRange+0x7c>)
 80011e4:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80011e6:	00d9      	lsls	r1, r3, #3
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 80011e8:	4604      	mov	r4, r0
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
  
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 80011ea:	d502      	bpl.n	80011f2 <RCC_SetFlashLatencyFromMSIRange+0x12>
  {
    vos = HAL_PWREx_GetVoltageRange();
 80011ec:	f7ff ffba 	bl	8001164 <HAL_PWREx_GetVoltageRange>
 80011f0:	e00e      	b.n	8001210 <RCC_SetFlashLatencyFromMSIRange+0x30>
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
 80011f2:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80011f4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80011f8:	65ab      	str	r3, [r5, #88]	; 0x58
 80011fa:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80011fc:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001200:	9301      	str	r3, [sp, #4]
 8001202:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 8001204:	f7ff ffae 	bl	8001164 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 8001208:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800120a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800120e:	65ab      	str	r3, [r5, #88]	; 0x58
  }
  
  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8001210:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8001214:	d106      	bne.n	8001224 <RCC_SetFlashLatencyFromMSIRange+0x44>
  {
    if(msirange > RCC_MSIRANGE_8)
 8001216:	2c80      	cmp	r4, #128	; 0x80
 8001218:	d90c      	bls.n	8001234 <RCC_SetFlashLatencyFromMSIRange+0x54>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
 800121a:	2ca0      	cmp	r4, #160	; 0xa0
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else
      {
        /* MSI 24Mhz or 32Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 800121c:	bf8c      	ite	hi
 800121e:	2302      	movhi	r3, #2
 8001220:	2301      	movls	r3, #1
 8001222:	e00c      	b.n	800123e <RCC_SetFlashLatencyFromMSIRange+0x5e>
    }
    /* else MSI <= 16Mhz default FLASH_LATENCY_0 0WS */
  }
  else
  {
    if(msirange > RCC_MSIRANGE_8)
 8001224:	2c80      	cmp	r4, #128	; 0x80
 8001226:	d807      	bhi.n	8001238 <RCC_SetFlashLatencyFromMSIRange+0x58>
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
    }
    else
    {
      if(msirange == RCC_MSIRANGE_8)
 8001228:	d008      	beq.n	800123c <RCC_SetFlashLatencyFromMSIRange+0x5c>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
      {
        /* MSI 48Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 800122a:	f1a4 0270 	sub.w	r2, r4, #112	; 0x70
 800122e:	4253      	negs	r3, r2
 8001230:	4153      	adcs	r3, r2
 8001232:	e004      	b.n	800123e <RCC_SetFlashLatencyFromMSIRange+0x5e>
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 8001234:	2300      	movs	r3, #0
 8001236:	e002      	b.n	800123e <RCC_SetFlashLatencyFromMSIRange+0x5e>
  else
  {
    if(msirange > RCC_MSIRANGE_8)
    {
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
 8001238:	2303      	movs	r3, #3
 800123a:	e000      	b.n	800123e <RCC_SetFlashLatencyFromMSIRange+0x5e>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
      {
        /* MSI 48Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 800123c:	2302      	movs	r3, #2
      }
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
  }
       
  __HAL_FLASH_SET_LATENCY(latency);
 800123e:	4908      	ldr	r1, [pc, #32]	; (8001260 <RCC_SetFlashLatencyFromMSIRange+0x80>)
 8001240:	680a      	ldr	r2, [r1, #0]
 8001242:	f022 0207 	bic.w	r2, r2, #7
 8001246:	431a      	orrs	r2, r3
 8001248:	600a      	str	r2, [r1, #0]
  
  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
 800124a:	6808      	ldr	r0, [r1, #0]
 800124c:	f000 0007 	and.w	r0, r0, #7
  {
    return HAL_ERROR;
  }
  
  return HAL_OK;
}
 8001250:	1ac0      	subs	r0, r0, r3
 8001252:	bf18      	it	ne
 8001254:	2001      	movne	r0, #1
 8001256:	b003      	add	sp, #12
 8001258:	bd30      	pop	{r4, r5, pc}
 800125a:	bf00      	nop
 800125c:	40021000 	.word	0x40021000
 8001260:	40022000 	.word	0x40022000

08001264 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8001264:	b570      	push	{r4, r5, r6, lr}
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
  uint32_t sysclockfreq = 0U;

  if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
 8001266:	4c4a      	ldr	r4, [pc, #296]	; (8001390 <HAL_RCC_GetSysClockFreq+0x12c>)
 8001268:	68a3      	ldr	r3, [r4, #8]
 800126a:	f013 0f0c 	tst.w	r3, #12
 800126e:	d009      	beq.n	8001284 <HAL_RCC_GetSysClockFreq+0x20>
     ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
 8001270:	68a3      	ldr	r3, [r4, #8]
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
  uint32_t sysclockfreq = 0U;

  if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
 8001272:	f003 030c 	and.w	r3, r3, #12
 8001276:	2b0c      	cmp	r3, #12
 8001278:	d126      	bne.n	80012c8 <HAL_RCC_GetSysClockFreq+0x64>
     ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
 800127a:	68e3      	ldr	r3, [r4, #12]
 800127c:	f003 0303 	and.w	r3, r3, #3
 8001280:	2b01      	cmp	r3, #1
 8001282:	d121      	bne.n	80012c8 <HAL_RCC_GetSysClockFreq+0x64>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
 8001284:	6822      	ldr	r2, [r4, #0]
 8001286:	4b42      	ldr	r3, [pc, #264]	; (8001390 <HAL_RCC_GetSysClockFreq+0x12c>)
 8001288:	0712      	lsls	r2, r2, #28
 800128a:	d40a      	bmi.n	80012a2 <HAL_RCC_GetSysClockFreq+0x3e>
    { /* MSISRANGE from RCC_CSR applies */
      msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> POSITION_VAL(RCC_CSR_MSISRANGE);
 800128c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001290:	f44f 6270 	mov.w	r2, #3840	; 0xf00
 8001294:	fa92 f2a2 	rbit	r2, r2
 8001298:	fab2 f282 	clz	r2, r2
 800129c:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 80012a0:	e007      	b.n	80012b2 <HAL_RCC_GetSysClockFreq+0x4e>
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->CR & RCC_CR_MSIRANGE) >> POSITION_VAL(RCC_CR_MSIRANGE);
 80012a2:	681b      	ldr	r3, [r3, #0]
 80012a4:	22f0      	movs	r2, #240	; 0xf0
 80012a6:	fa92 f2a2 	rbit	r2, r2
 80012aa:	fab2 f282 	clz	r2, r2
 80012ae:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80012b2:	40d3      	lsrs	r3, r2
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 80012b4:	4a37      	ldr	r2, [pc, #220]	; (8001394 <HAL_RCC_GetSysClockFreq+0x130>)
 80012b6:	f852 6023 	ldr.w	r6, [r2, r3, lsl #2]

    if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI)
 80012ba:	68a3      	ldr	r3, [r4, #8]
    {
      /* MSI used as system clock source */
      sysclockfreq = msirange;
 80012bc:	f013 0f0c 	tst.w	r3, #12
 80012c0:	bf0c      	ite	eq
 80012c2:	4630      	moveq	r0, r6
 80012c4:	2000      	movne	r0, #0
 80012c6:	e011      	b.n	80012ec <HAL_RCC_GetSysClockFreq+0x88>
    }
  }
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
 80012c8:	68a3      	ldr	r3, [r4, #8]
 80012ca:	f003 030c 	and.w	r3, r3, #12
 80012ce:	2b04      	cmp	r3, #4
 80012d0:	d007      	beq.n	80012e2 <HAL_RCC_GetSysClockFreq+0x7e>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
  }
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
 80012d2:	4b2f      	ldr	r3, [pc, #188]	; (8001390 <HAL_RCC_GetSysClockFreq+0x12c>)
 80012d4:	689b      	ldr	r3, [r3, #8]
 80012d6:	f003 030c 	and.w	r3, r3, #12
 80012da:	2b08      	cmp	r3, #8
 80012dc:	d104      	bne.n	80012e8 <HAL_RCC_GetSysClockFreq+0x84>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
 80012de:	482e      	ldr	r0, [pc, #184]	; (8001398 <HAL_RCC_GetSysClockFreq+0x134>)
 80012e0:	e000      	b.n	80012e4 <HAL_RCC_GetSysClockFreq+0x80>
    }
  }
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 80012e2:	482e      	ldr	r0, [pc, #184]	; (800139c <HAL_RCC_GetSysClockFreq+0x138>)
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
 80012e4:	2600      	movs	r6, #0
 80012e6:	e001      	b.n	80012ec <HAL_RCC_GetSysClockFreq+0x88>
  uint32_t sysclockfreq = 0U;
 80012e8:	2000      	movs	r0, #0
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
 80012ea:	4606      	mov	r6, r0
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }

  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 80012ec:	68a3      	ldr	r3, [r4, #8]
 80012ee:	4a28      	ldr	r2, [pc, #160]	; (8001390 <HAL_RCC_GetSysClockFreq+0x12c>)
 80012f0:	f003 030c 	and.w	r3, r3, #12
 80012f4:	2b0c      	cmp	r3, #12
 80012f6:	d149      	bne.n	800138c <HAL_RCC_GetSysClockFreq+0x128>
    /* PLL used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 80012f8:	68d1      	ldr	r1, [r2, #12]
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> POSITION_VAL(RCC_PLLCFGR_PLLM)) + 1U ;
 80012fa:	68d3      	ldr	r3, [r2, #12]
 80012fc:	2070      	movs	r0, #112	; 0x70
 80012fe:	fa90 f0a0 	rbit	r0, r0
 8001302:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8001306:	fab0 f080 	clz	r0, r0
 800130a:	fa23 f000 	lsr.w	r0, r3, r0

    switch (pllsource)
 800130e:	f001 0303 	and.w	r3, r1, #3
 8001312:	2b02      	cmp	r3, #2

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> POSITION_VAL(RCC_PLLCFGR_PLLM)) + 1U ;
 8001314:	f100 0501 	add.w	r5, r0, #1
 8001318:	f44f 41fe 	mov.w	r1, #32512	; 0x7f00

    switch (pllsource)
 800131c:	d00c      	beq.n	8001338 <HAL_RCC_GetSysClockFreq+0xd4>
 800131e:	2b03      	cmp	r3, #3
 8001320:	d119      	bne.n	8001356 <HAL_RCC_GetSysClockFreq+0xf2>
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN));
      break;

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN));
 8001322:	68d3      	ldr	r3, [r2, #12]
 8001324:	fa91 f1a1 	rbit	r1, r1
 8001328:	fab1 f181 	clz	r1, r1
 800132c:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 8001330:	fa23 f101 	lsr.w	r1, r3, r1
 8001334:	4a18      	ldr	r2, [pc, #96]	; (8001398 <HAL_RCC_GetSysClockFreq+0x134>)
 8001336:	e009      	b.n	800134c <HAL_RCC_GetSysClockFreq+0xe8>
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> POSITION_VAL(RCC_PLLCFGR_PLLM)) + 1U ;

    switch (pllsource)
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN));
 8001338:	68d3      	ldr	r3, [r2, #12]
 800133a:	fa91 f1a1 	rbit	r1, r1
 800133e:	4a17      	ldr	r2, [pc, #92]	; (800139c <HAL_RCC_GetSysClockFreq+0x138>)
 8001340:	fab1 f181 	clz	r1, r1
 8001344:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 8001348:	fa23 f101 	lsr.w	r1, r3, r1
      break;

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN));
 800134c:	fbb2 f0f5 	udiv	r0, r2, r5
 8001350:	fb00 f301 	mul.w	r3, r0, r1
      break;
 8001354:	e00b      	b.n	800136e <HAL_RCC_GetSysClockFreq+0x10a>

    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
    default:
      pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN));
 8001356:	68d2      	ldr	r2, [r2, #12]
 8001358:	fa91 f1a1 	rbit	r1, r1
 800135c:	fab1 f181 	clz	r1, r1
 8001360:	f402 42fe 	and.w	r2, r2, #32512	; 0x7f00
 8001364:	40ca      	lsrs	r2, r1
 8001366:	fbb6 f0f5 	udiv	r0, r6, r5
 800136a:	fb00 f302 	mul.w	r3, r0, r2
      break;
    }
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> POSITION_VAL(RCC_PLLCFGR_PLLR)) + 1U ) * 2U;
 800136e:	68e2      	ldr	r2, [r4, #12]
 8001370:	f04f 60c0 	mov.w	r0, #100663296	; 0x6000000
 8001374:	fa90 f0a0 	rbit	r0, r0
 8001378:	fab0 f080 	clz	r0, r0
    sysclockfreq = pllvco/pllr;
 800137c:	f002 62c0 	and.w	r2, r2, #100663296	; 0x6000000
 8001380:	fa22 f000 	lsr.w	r0, r2, r0
 8001384:	3001      	adds	r0, #1
 8001386:	0040      	lsls	r0, r0, #1
 8001388:	fbb3 f0f0 	udiv	r0, r3, r0
  }

  return sysclockfreq;
}
 800138c:	bd70      	pop	{r4, r5, r6, pc}
 800138e:	bf00      	nop
 8001390:	40021000 	.word	0x40021000
 8001394:	08007a58 	.word	0x08007a58
 8001398:	007a1200 	.word	0x007a1200
 800139c:	00f42400 	.word	0x00f42400

080013a0 <HAL_RCC_OscConfig>:
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80013a0:	6803      	ldr	r3, [r0, #0]
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80013a2:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80013a6:	06dd      	lsls	r5, r3, #27
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80013a8:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80013aa:	f140 808f 	bpl.w	80014cc <HAL_RCC_OscConfig+0x12c>
    assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

    /* When the MSI is used as system clock it will not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
 80013ae:	4d9e      	ldr	r5, [pc, #632]	; (8001628 <HAL_RCC_OscConfig+0x288>)
 80013b0:	68ab      	ldr	r3, [r5, #8]
 80013b2:	f013 0f0c 	tst.w	r3, #12
 80013b6:	d153      	bne.n	8001460 <HAL_RCC_OscConfig+0xc0>
    {
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 80013b8:	682b      	ldr	r3, [r5, #0]
 80013ba:	0798      	lsls	r0, r3, #30
 80013bc:	d503      	bpl.n	80013c6 <HAL_RCC_OscConfig+0x26>
 80013be:	69a3      	ldr	r3, [r4, #24]
 80013c0:	2b00      	cmp	r3, #0
 80013c2:	f000 8256 	beq.w	8001872 <HAL_RCC_OscConfig+0x4d2>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device. */
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 80013c6:	682a      	ldr	r2, [r5, #0]
 80013c8:	4b97      	ldr	r3, [pc, #604]	; (8001628 <HAL_RCC_OscConfig+0x288>)
 80013ca:	6a20      	ldr	r0, [r4, #32]
 80013cc:	0711      	lsls	r1, r2, #28
 80013ce:	bf56      	itet	pl
 80013d0:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
 80013d4:	681b      	ldrmi	r3, [r3, #0]
 80013d6:	091b      	lsrpl	r3, r3, #4
 80013d8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80013dc:	4283      	cmp	r3, r0
 80013de:	d216      	bcs.n	800140e <HAL_RCC_OscConfig+0x6e>
        {
          /* First increase number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 80013e0:	f7ff fefe 	bl	80011e0 <RCC_SetFlashLatencyFromMSIRange>
 80013e4:	2800      	cmp	r0, #0
 80013e6:	f040 8244 	bne.w	8001872 <HAL_RCC_OscConfig+0x4d2>
          {
            return HAL_ERROR;
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80013ea:	682b      	ldr	r3, [r5, #0]
 80013ec:	f043 0308 	orr.w	r3, r3, #8
 80013f0:	602b      	str	r3, [r5, #0]
 80013f2:	682b      	ldr	r3, [r5, #0]
 80013f4:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 80013f8:	6a23      	ldr	r3, [r4, #32]
 80013fa:	4313      	orrs	r3, r2
 80013fc:	602b      	str	r3, [r5, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80013fe:	686b      	ldr	r3, [r5, #4]
 8001400:	69e2      	ldr	r2, [r4, #28]
 8001402:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8001406:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800140a:	606b      	str	r3, [r5, #4]
 800140c:	e014      	b.n	8001438 <HAL_RCC_OscConfig+0x98>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800140e:	682b      	ldr	r3, [r5, #0]
 8001410:	f043 0308 	orr.w	r3, r3, #8
 8001414:	602b      	str	r3, [r5, #0]
 8001416:	682b      	ldr	r3, [r5, #0]
 8001418:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800141c:	4303      	orrs	r3, r0
 800141e:	602b      	str	r3, [r5, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8001420:	686b      	ldr	r3, [r5, #4]
 8001422:	69e2      	ldr	r2, [r4, #28]
 8001424:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8001428:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800142c:	606b      	str	r3, [r5, #4]

          /* Decrease number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 800142e:	f7ff fed7 	bl	80011e0 <RCC_SetFlashLatencyFromMSIRange>
 8001432:	2800      	cmp	r0, #0
 8001434:	f040 821d 	bne.w	8001872 <HAL_RCC_OscConfig+0x4d2>
            return HAL_ERROR;
          }          
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8001438:	f7ff ff14 	bl	8001264 <HAL_RCC_GetSysClockFreq>
 800143c:	68ab      	ldr	r3, [r5, #8]
 800143e:	22f0      	movs	r2, #240	; 0xf0
 8001440:	fa92 f2a2 	rbit	r2, r2
 8001444:	fab2 f282 	clz	r2, r2
 8001448:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800144c:	40d3      	lsrs	r3, r2
 800144e:	4a77      	ldr	r2, [pc, #476]	; (800162c <HAL_RCC_OscConfig+0x28c>)
 8001450:	5cd3      	ldrb	r3, [r2, r3]
 8001452:	40d8      	lsrs	r0, r3
 8001454:	4b76      	ldr	r3, [pc, #472]	; (8001630 <HAL_RCC_OscConfig+0x290>)
 8001456:	6018      	str	r0, [r3, #0]
        
        /* Configure the source of time base considering new system clocks settings*/
        HAL_InitTick (TICK_INT_PRIORITY);
 8001458:	2000      	movs	r0, #0
 800145a:	f7ff fd17 	bl	8000e8c <HAL_InitTick>
 800145e:	e035      	b.n	80014cc <HAL_RCC_OscConfig+0x12c>
      }
    }
    else
    {
      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8001460:	6983      	ldr	r3, [r0, #24]
 8001462:	b31b      	cbz	r3, 80014ac <HAL_RCC_OscConfig+0x10c>
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 8001464:	682b      	ldr	r3, [r5, #0]
 8001466:	f043 0301 	orr.w	r3, r3, #1
 800146a:	602b      	str	r3, [r5, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();
 800146c:	f7ff fd36 	bl	8000edc <HAL_GetTick>
 8001470:	4606      	mov	r6, r0

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET)
 8001472:	682a      	ldr	r2, [r5, #0]
 8001474:	4b6c      	ldr	r3, [pc, #432]	; (8001628 <HAL_RCC_OscConfig+0x288>)
 8001476:	0792      	lsls	r2, r2, #30
 8001478:	d406      	bmi.n	8001488 <HAL_RCC_OscConfig+0xe8>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800147a:	f7ff fd2f 	bl	8000edc <HAL_GetTick>
 800147e:	1b80      	subs	r0, r0, r6
 8001480:	2802      	cmp	r0, #2
 8001482:	d9f6      	bls.n	8001472 <HAL_RCC_OscConfig+0xd2>
          {
            return HAL_TIMEOUT;
 8001484:	2003      	movs	r0, #3
 8001486:	e1f5      	b.n	8001874 <HAL_RCC_OscConfig+0x4d4>
          }
        }
         /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8001488:	681a      	ldr	r2, [r3, #0]
 800148a:	f042 0208 	orr.w	r2, r2, #8
 800148e:	601a      	str	r2, [r3, #0]
 8001490:	681a      	ldr	r2, [r3, #0]
 8001492:	f022 01f0 	bic.w	r1, r2, #240	; 0xf0
 8001496:	6a22      	ldr	r2, [r4, #32]
 8001498:	430a      	orrs	r2, r1
 800149a:	601a      	str	r2, [r3, #0]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800149c:	685a      	ldr	r2, [r3, #4]
 800149e:	69e1      	ldr	r1, [r4, #28]
 80014a0:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 80014a4:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80014a8:	605a      	str	r2, [r3, #4]
 80014aa:	e00f      	b.n	80014cc <HAL_RCC_OscConfig+0x12c>

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 80014ac:	682b      	ldr	r3, [r5, #0]
 80014ae:	f023 0301 	bic.w	r3, r3, #1
 80014b2:	602b      	str	r3, [r5, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();
 80014b4:	f7ff fd12 	bl	8000edc <HAL_GetTick>
 80014b8:	4606      	mov	r6, r0

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != RESET)
 80014ba:	682b      	ldr	r3, [r5, #0]
 80014bc:	079f      	lsls	r7, r3, #30
 80014be:	d505      	bpl.n	80014cc <HAL_RCC_OscConfig+0x12c>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80014c0:	f7ff fd0c 	bl	8000edc <HAL_GetTick>
 80014c4:	1b80      	subs	r0, r0, r6
 80014c6:	2802      	cmp	r0, #2
 80014c8:	d9f7      	bls.n	80014ba <HAL_RCC_OscConfig+0x11a>
 80014ca:	e7db      	b.n	8001484 <HAL_RCC_OscConfig+0xe4>
        }
      }
    }
  }
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80014cc:	6823      	ldr	r3, [r4, #0]
 80014ce:	07de      	lsls	r6, r3, #31
 80014d0:	d403      	bmi.n	80014da <HAL_RCC_OscConfig+0x13a>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80014d2:	6823      	ldr	r3, [r4, #0]
 80014d4:	079d      	lsls	r5, r3, #30
 80014d6:	d448      	bmi.n	800156a <HAL_RCC_OscConfig+0x1ca>
 80014d8:	e09f      	b.n	800161a <HAL_RCC_OscConfig+0x27a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || 
 80014da:	4d53      	ldr	r5, [pc, #332]	; (8001628 <HAL_RCC_OscConfig+0x288>)
 80014dc:	68ab      	ldr	r3, [r5, #8]
 80014de:	f003 030c 	and.w	r3, r3, #12
 80014e2:	2b08      	cmp	r3, #8
 80014e4:	d009      	beq.n	80014fa <HAL_RCC_OscConfig+0x15a>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80014e6:	68ab      	ldr	r3, [r5, #8]
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || 
 80014e8:	f003 030c 	and.w	r3, r3, #12
 80014ec:	2b0c      	cmp	r3, #12
 80014ee:	d10b      	bne.n	8001508 <HAL_RCC_OscConfig+0x168>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80014f0:	68eb      	ldr	r3, [r5, #12]
 80014f2:	f003 0303 	and.w	r3, r3, #3
 80014f6:	2b03      	cmp	r3, #3
 80014f8:	d106      	bne.n	8001508 <HAL_RCC_OscConfig+0x168>
    {
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80014fa:	682b      	ldr	r3, [r5, #0]
 80014fc:	0398      	lsls	r0, r3, #14
 80014fe:	d5e8      	bpl.n	80014d2 <HAL_RCC_OscConfig+0x132>
 8001500:	6863      	ldr	r3, [r4, #4]
 8001502:	2b00      	cmp	r3, #0
 8001504:	d1e5      	bne.n	80014d2 <HAL_RCC_OscConfig+0x132>
 8001506:	e1b4      	b.n	8001872 <HAL_RCC_OscConfig+0x4d2>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001508:	6863      	ldr	r3, [r4, #4]
 800150a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800150e:	d006      	beq.n	800151e <HAL_RCC_OscConfig+0x17e>
 8001510:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8001514:	d108      	bne.n	8001528 <HAL_RCC_OscConfig+0x188>
 8001516:	682b      	ldr	r3, [r5, #0]
 8001518:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800151c:	602b      	str	r3, [r5, #0]
 800151e:	682b      	ldr	r3, [r5, #0]
 8001520:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001524:	602b      	str	r3, [r5, #0]
 8001526:	e008      	b.n	800153a <HAL_RCC_OscConfig+0x19a>
 8001528:	682a      	ldr	r2, [r5, #0]
 800152a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800152e:	602a      	str	r2, [r5, #0]
 8001530:	682a      	ldr	r2, [r5, #0]
 8001532:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001536:	602a      	str	r2, [r5, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8001538:	b15b      	cbz	r3, 8001552 <HAL_RCC_OscConfig+0x1b2>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800153a:	f7ff fccf 	bl	8000edc <HAL_GetTick>
 800153e:	4606      	mov	r6, r0

        /* Wait till HSE is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET)
 8001540:	682b      	ldr	r3, [r5, #0]
 8001542:	0399      	lsls	r1, r3, #14
 8001544:	d4c5      	bmi.n	80014d2 <HAL_RCC_OscConfig+0x132>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001546:	f7ff fcc9 	bl	8000edc <HAL_GetTick>
 800154a:	1b80      	subs	r0, r0, r6
 800154c:	2864      	cmp	r0, #100	; 0x64
 800154e:	d9f7      	bls.n	8001540 <HAL_RCC_OscConfig+0x1a0>
 8001550:	e798      	b.n	8001484 <HAL_RCC_OscConfig+0xe4>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001552:	f7ff fcc3 	bl	8000edc <HAL_GetTick>
 8001556:	4606      	mov	r6, r0

        /* Wait till HSE is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)
 8001558:	682b      	ldr	r3, [r5, #0]
 800155a:	039a      	lsls	r2, r3, #14
 800155c:	d5b9      	bpl.n	80014d2 <HAL_RCC_OscConfig+0x132>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800155e:	f7ff fcbd 	bl	8000edc <HAL_GetTick>
 8001562:	1b80      	subs	r0, r0, r6
 8001564:	2864      	cmp	r0, #100	; 0x64
 8001566:	d9f7      	bls.n	8001558 <HAL_RCC_OscConfig+0x1b8>
 8001568:	e78c      	b.n	8001484 <HAL_RCC_OscConfig+0xe4>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
 800156a:	4d2f      	ldr	r5, [pc, #188]	; (8001628 <HAL_RCC_OscConfig+0x288>)
 800156c:	68ab      	ldr	r3, [r5, #8]
 800156e:	f003 030c 	and.w	r3, r3, #12
 8001572:	2b04      	cmp	r3, #4
 8001574:	d009      	beq.n	800158a <HAL_RCC_OscConfig+0x1ea>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8001576:	68ab      	ldr	r3, [r5, #8]
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
 8001578:	f003 030c 	and.w	r3, r3, #12
 800157c:	2b0c      	cmp	r3, #12
 800157e:	d11a      	bne.n	80015b6 <HAL_RCC_OscConfig+0x216>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8001580:	68eb      	ldr	r3, [r5, #12]
 8001582:	f003 0303 	and.w	r3, r3, #3
 8001586:	2b02      	cmp	r3, #2
 8001588:	d115      	bne.n	80015b6 <HAL_RCC_OscConfig+0x216>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 800158a:	682b      	ldr	r3, [r5, #0]
 800158c:	055b      	lsls	r3, r3, #21
 800158e:	d503      	bpl.n	8001598 <HAL_RCC_OscConfig+0x1f8>
 8001590:	68e3      	ldr	r3, [r4, #12]
 8001592:	2b00      	cmp	r3, #0
 8001594:	f000 816d 	beq.w	8001872 <HAL_RCC_OscConfig+0x4d2>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001598:	686b      	ldr	r3, [r5, #4]
 800159a:	f04f 52f8 	mov.w	r2, #520093696	; 0x1f000000
 800159e:	fa92 f2a2 	rbit	r2, r2
 80015a2:	6921      	ldr	r1, [r4, #16]
 80015a4:	fab2 f282 	clz	r2, r2
 80015a8:	fa01 f202 	lsl.w	r2, r1, r2
 80015ac:	f023 53f8 	bic.w	r3, r3, #520093696	; 0x1f000000
 80015b0:	4313      	orrs	r3, r2
 80015b2:	606b      	str	r3, [r5, #4]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
    {
      /* When HSI is used as system clock it will not be disabled */
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80015b4:	e031      	b.n	800161a <HAL_RCC_OscConfig+0x27a>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80015b6:	68e3      	ldr	r3, [r4, #12]
 80015b8:	b1fb      	cbz	r3, 80015fa <HAL_RCC_OscConfig+0x25a>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80015ba:	682b      	ldr	r3, [r5, #0]
 80015bc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80015c0:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80015c2:	f7ff fc8b 	bl	8000edc <HAL_GetTick>
 80015c6:	4606      	mov	r6, r0

        /* Wait till HSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
 80015c8:	682b      	ldr	r3, [r5, #0]
 80015ca:	4817      	ldr	r0, [pc, #92]	; (8001628 <HAL_RCC_OscConfig+0x288>)
 80015cc:	055f      	lsls	r7, r3, #21
 80015ce:	d405      	bmi.n	80015dc <HAL_RCC_OscConfig+0x23c>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80015d0:	f7ff fc84 	bl	8000edc <HAL_GetTick>
 80015d4:	1b80      	subs	r0, r0, r6
 80015d6:	2802      	cmp	r0, #2
 80015d8:	d9f6      	bls.n	80015c8 <HAL_RCC_OscConfig+0x228>
 80015da:	e753      	b.n	8001484 <HAL_RCC_OscConfig+0xe4>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80015dc:	6843      	ldr	r3, [r0, #4]
 80015de:	f04f 52f8 	mov.w	r2, #520093696	; 0x1f000000
 80015e2:	fa92 f2a2 	rbit	r2, r2
 80015e6:	6921      	ldr	r1, [r4, #16]
 80015e8:	fab2 f282 	clz	r2, r2
 80015ec:	fa01 f202 	lsl.w	r2, r1, r2
 80015f0:	f023 53f8 	bic.w	r3, r3, #520093696	; 0x1f000000
 80015f4:	4313      	orrs	r3, r2
 80015f6:	6043      	str	r3, [r0, #4]
 80015f8:	e00f      	b.n	800161a <HAL_RCC_OscConfig+0x27a>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 80015fa:	682b      	ldr	r3, [r5, #0]
 80015fc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001600:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001602:	f7ff fc6b 	bl	8000edc <HAL_GetTick>
 8001606:	4606      	mov	r6, r0

        /* Wait till HSI is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != RESET)
 8001608:	682b      	ldr	r3, [r5, #0]
 800160a:	0558      	lsls	r0, r3, #21
 800160c:	d505      	bpl.n	800161a <HAL_RCC_OscConfig+0x27a>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800160e:	f7ff fc65 	bl	8000edc <HAL_GetTick>
 8001612:	1b80      	subs	r0, r0, r6
 8001614:	2802      	cmp	r0, #2
 8001616:	d9f7      	bls.n	8001608 <HAL_RCC_OscConfig+0x268>
 8001618:	e734      	b.n	8001484 <HAL_RCC_OscConfig+0xe4>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800161a:	6823      	ldr	r3, [r4, #0]
 800161c:	0719      	lsls	r1, r3, #28
 800161e:	d409      	bmi.n	8001634 <HAL_RCC_OscConfig+0x294>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8001620:	6823      	ldr	r3, [r4, #0]
 8001622:	075a      	lsls	r2, r3, #29
 8001624:	d42f      	bmi.n	8001686 <HAL_RCC_OscConfig+0x2e6>
 8001626:	e097      	b.n	8001758 <HAL_RCC_OscConfig+0x3b8>
 8001628:	40021000 	.word	0x40021000
 800162c:	08007a3e 	.word	0x08007a3e
 8001630:	200000a8 	.word	0x200000a8
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8001634:	6963      	ldr	r3, [r4, #20]
 8001636:	4d91      	ldr	r5, [pc, #580]	; (800187c <HAL_RCC_OscConfig+0x4dc>)
 8001638:	b193      	cbz	r3, 8001660 <HAL_RCC_OscConfig+0x2c0>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800163a:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 800163e:	f043 0301 	orr.w	r3, r3, #1
 8001642:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001646:	f7ff fc49 	bl	8000edc <HAL_GetTick>
 800164a:	4606      	mov	r6, r0

      /* Wait till LSI is ready */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == RESET)
 800164c:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8001650:	079b      	lsls	r3, r3, #30
 8001652:	d4e5      	bmi.n	8001620 <HAL_RCC_OscConfig+0x280>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001654:	f7ff fc42 	bl	8000edc <HAL_GetTick>
 8001658:	1b80      	subs	r0, r0, r6
 800165a:	2802      	cmp	r0, #2
 800165c:	d9f6      	bls.n	800164c <HAL_RCC_OscConfig+0x2ac>
 800165e:	e711      	b.n	8001484 <HAL_RCC_OscConfig+0xe4>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8001660:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8001664:	f023 0301 	bic.w	r3, r3, #1
 8001668:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800166c:	f7ff fc36 	bl	8000edc <HAL_GetTick>
 8001670:	4606      	mov	r6, r0

      /* Wait till LSI is disabled */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != RESET)
 8001672:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8001676:	079f      	lsls	r7, r3, #30
 8001678:	d5d2      	bpl.n	8001620 <HAL_RCC_OscConfig+0x280>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800167a:	f7ff fc2f 	bl	8000edc <HAL_GetTick>
 800167e:	1b80      	subs	r0, r0, r6
 8001680:	2802      	cmp	r0, #2
 8001682:	d9f6      	bls.n	8001672 <HAL_RCC_OscConfig+0x2d2>
 8001684:	e6fe      	b.n	8001484 <HAL_RCC_OscConfig+0xe4>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 8001686:	4d7d      	ldr	r5, [pc, #500]	; (800187c <HAL_RCC_OscConfig+0x4dc>)
 8001688:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800168a:	00d8      	lsls	r0, r3, #3
 800168c:	d40a      	bmi.n	80016a4 <HAL_RCC_OscConfig+0x304>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800168e:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8001690:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001694:	65ab      	str	r3, [r5, #88]	; 0x58
 8001696:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8001698:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800169c:	9301      	str	r3, [sp, #4]
 800169e:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 80016a0:	2701      	movs	r7, #1
 80016a2:	e000      	b.n	80016a6 <HAL_RCC_OscConfig+0x306>
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
  {
    FlagStatus       pwrclkchanged = RESET;
 80016a4:	2700      	movs	r7, #0
    {
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80016a6:	4e76      	ldr	r6, [pc, #472]	; (8001880 <HAL_RCC_OscConfig+0x4e0>)
 80016a8:	6833      	ldr	r3, [r6, #0]
 80016aa:	05d9      	lsls	r1, r3, #23
 80016ac:	d503      	bpl.n	80016b6 <HAL_RCC_OscConfig+0x316>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80016ae:	68a3      	ldr	r3, [r4, #8]
 80016b0:	2b01      	cmp	r3, #1
 80016b2:	d111      	bne.n	80016d8 <HAL_RCC_OscConfig+0x338>
 80016b4:	e018      	b.n	80016e8 <HAL_RCC_OscConfig+0x348>
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80016b6:	6833      	ldr	r3, [r6, #0]
 80016b8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80016bc:	6033      	str	r3, [r6, #0]
      
      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 80016be:	f7ff fc0d 	bl	8000edc <HAL_GetTick>
 80016c2:	4680      	mov	r8, r0

      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80016c4:	6833      	ldr	r3, [r6, #0]
 80016c6:	05da      	lsls	r2, r3, #23
 80016c8:	d4f1      	bmi.n	80016ae <HAL_RCC_OscConfig+0x30e>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80016ca:	f7ff fc07 	bl	8000edc <HAL_GetTick>
 80016ce:	ebc8 0000 	rsb	r0, r8, r0
 80016d2:	2802      	cmp	r0, #2
 80016d4:	d9f6      	bls.n	80016c4 <HAL_RCC_OscConfig+0x324>
 80016d6:	e6d5      	b.n	8001484 <HAL_RCC_OscConfig+0xe4>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80016d8:	2b05      	cmp	r3, #5
 80016da:	d10c      	bne.n	80016f6 <HAL_RCC_OscConfig+0x356>
 80016dc:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 80016e0:	f043 0304 	orr.w	r3, r3, #4
 80016e4:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
 80016e8:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 80016ec:	f043 0301 	orr.w	r3, r3, #1
 80016f0:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
 80016f4:	e00c      	b.n	8001710 <HAL_RCC_OscConfig+0x370>
 80016f6:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 80016fa:	f022 0201 	bic.w	r2, r2, #1
 80016fe:	f8c5 2090 	str.w	r2, [r5, #144]	; 0x90
 8001702:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 8001706:	f022 0204 	bic.w	r2, r2, #4
 800170a:	f8c5 2090 	str.w	r2, [r5, #144]	; 0x90

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 800170e:	b173      	cbz	r3, 800172e <HAL_RCC_OscConfig+0x38e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001710:	f7ff fbe4 	bl	8000edc <HAL_GetTick>

      /* Wait till LSE is ready */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001714:	f241 3888 	movw	r8, #5000	; 0x1388

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001718:	4606      	mov	r6, r0

      /* Wait till LSE is ready */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
 800171a:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800171e:	079b      	lsls	r3, r3, #30
 8001720:	d40e      	bmi.n	8001740 <HAL_RCC_OscConfig+0x3a0>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001722:	f7ff fbdb 	bl	8000edc <HAL_GetTick>
 8001726:	1b80      	subs	r0, r0, r6
 8001728:	4540      	cmp	r0, r8
 800172a:	d9f6      	bls.n	800171a <HAL_RCC_OscConfig+0x37a>
 800172c:	e6aa      	b.n	8001484 <HAL_RCC_OscConfig+0xe4>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800172e:	f7ff fbd5 	bl	8000edc <HAL_GetTick>

      /* Wait till LSE is disabled */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001732:	f241 3888 	movw	r8, #5000	; 0x1388
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001736:	4606      	mov	r6, r0

      /* Wait till LSE is disabled */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != RESET)
 8001738:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800173c:	0798      	lsls	r0, r3, #30
 800173e:	d405      	bmi.n	800174c <HAL_RCC_OscConfig+0x3ac>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8001740:	b157      	cbz	r7, 8001758 <HAL_RCC_OscConfig+0x3b8>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8001742:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8001744:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8001748:	65ab      	str	r3, [r5, #88]	; 0x58
 800174a:	e005      	b.n	8001758 <HAL_RCC_OscConfig+0x3b8>
      tickstart = HAL_GetTick();

      /* Wait till LSE is disabled */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800174c:	f7ff fbc6 	bl	8000edc <HAL_GetTick>
 8001750:	1b80      	subs	r0, r0, r6
 8001752:	4540      	cmp	r0, r8
 8001754:	d9f0      	bls.n	8001738 <HAL_RCC_OscConfig+0x398>
 8001756:	e695      	b.n	8001484 <HAL_RCC_OscConfig+0xe4>
      __HAL_RCC_PWR_CLK_DISABLE();
    }
  }
#if defined(RCC_HSI48_SUPPORT)
  /*------------------------------ HSI48 Configuration -----------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8001758:	6823      	ldr	r3, [r4, #0]
 800175a:	0699      	lsls	r1, r3, #26
 800175c:	d402      	bmi.n	8001764 <HAL_RCC_OscConfig+0x3c4>
#endif /* RCC_HSI48_SUPPORT */
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 800175e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8001760:	bb4a      	cbnz	r2, 80017b6 <HAL_RCC_OscConfig+0x416>
 8001762:	e05f      	b.n	8001824 <HAL_RCC_OscConfig+0x484>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the LSI State */
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8001764:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001766:	4d45      	ldr	r5, [pc, #276]	; (800187c <HAL_RCC_OscConfig+0x4dc>)
 8001768:	b193      	cbz	r3, 8001790 <HAL_RCC_OscConfig+0x3f0>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 800176a:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 800176e:	f043 0301 	orr.w	r3, r3, #1
 8001772:	f8c5 3098 	str.w	r3, [r5, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001776:	f7ff fbb1 	bl	8000edc <HAL_GetTick>
 800177a:	4606      	mov	r6, r0

      /* Wait till HSI48 is ready */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == RESET)
 800177c:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 8001780:	079a      	lsls	r2, r3, #30
 8001782:	d4ec      	bmi.n	800175e <HAL_RCC_OscConfig+0x3be>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8001784:	f7ff fbaa 	bl	8000edc <HAL_GetTick>
 8001788:	1b80      	subs	r0, r0, r6
 800178a:	2802      	cmp	r0, #2
 800178c:	d9f6      	bls.n	800177c <HAL_RCC_OscConfig+0x3dc>
 800178e:	e679      	b.n	8001484 <HAL_RCC_OscConfig+0xe4>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
 8001790:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 8001794:	f023 0301 	bic.w	r3, r3, #1
 8001798:	f8c5 3098 	str.w	r3, [r5, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800179c:	f7ff fb9e 	bl	8000edc <HAL_GetTick>
 80017a0:	4606      	mov	r6, r0

      /* Wait till HSI48 is disabled */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != RESET)
 80017a2:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 80017a6:	079b      	lsls	r3, r3, #30
 80017a8:	d5d9      	bpl.n	800175e <HAL_RCC_OscConfig+0x3be>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 80017aa:	f7ff fb97 	bl	8000edc <HAL_GetTick>
 80017ae:	1b80      	subs	r0, r0, r6
 80017b0:	2802      	cmp	r0, #2
 80017b2:	d9f6      	bls.n	80017a2 <HAL_RCC_OscConfig+0x402>
 80017b4:	e666      	b.n	8001484 <HAL_RCC_OscConfig+0xe4>
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80017b6:	4d31      	ldr	r5, [pc, #196]	; (800187c <HAL_RCC_OscConfig+0x4dc>)
 80017b8:	68ab      	ldr	r3, [r5, #8]
 80017ba:	f003 030c 	and.w	r3, r3, #12
 80017be:	2b0c      	cmp	r3, #12
 80017c0:	d057      	beq.n	8001872 <HAL_RCC_OscConfig+0x4d2>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80017c2:	682b      	ldr	r3, [r5, #0]
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    {
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 80017c4:	2a02      	cmp	r2, #2
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80017c6:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80017ca:	602b      	str	r3, [r5, #0]
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    {
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 80017cc:	d138      	bne.n	8001840 <HAL_RCC_OscConfig+0x4a0>

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80017ce:	f7ff fb85 	bl	8000edc <HAL_GetTick>
 80017d2:	4606      	mov	r6, r0

        /* Wait till PLL is ready */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
 80017d4:	682b      	ldr	r3, [r5, #0]
 80017d6:	4829      	ldr	r0, [pc, #164]	; (800187c <HAL_RCC_OscConfig+0x4dc>)
 80017d8:	019f      	lsls	r7, r3, #6
 80017da:	d425      	bmi.n	8001828 <HAL_RCC_OscConfig+0x488>
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80017dc:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 80017de:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80017e0:	6b22      	ldr	r2, [r4, #48]	; 0x30
 80017e2:	06f6      	lsls	r6, r6, #27
 80017e4:	ea46 2103 	orr.w	r1, r6, r3, lsl #8
 80017e8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80017ea:	3a01      	subs	r2, #1
 80017ec:	430b      	orrs	r3, r1
 80017ee:	ea43 1102 	orr.w	r1, r3, r2, lsl #4
 80017f2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80017f4:	085b      	lsrs	r3, r3, #1
 80017f6:	3b01      	subs	r3, #1
 80017f8:	ea41 5243 	orr.w	r2, r1, r3, lsl #21
 80017fc:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80017fe:	085b      	lsrs	r3, r3, #1
 8001800:	3b01      	subs	r3, #1
 8001802:	ea42 6343 	orr.w	r3, r2, r3, lsl #25
 8001806:	60c3      	str	r3, [r0, #12]
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8001808:	6803      	ldr	r3, [r0, #0]
 800180a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800180e:	6003      	str	r3, [r0, #0]

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8001810:	68c3      	ldr	r3, [r0, #12]
 8001812:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001816:	60c3      	str	r3, [r0, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001818:	f7ff fb60 	bl	8000edc <HAL_GetTick>
 800181c:	4604      	mov	r4, r0

        /* Wait till PLL is ready */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 800181e:	682b      	ldr	r3, [r5, #0]
 8001820:	0199      	lsls	r1, r3, #6
 8001822:	d507      	bpl.n	8001834 <HAL_RCC_OscConfig+0x494>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8001824:	2000      	movs	r0, #0
 8001826:	e025      	b.n	8001874 <HAL_RCC_OscConfig+0x4d4>
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001828:	f7ff fb58 	bl	8000edc <HAL_GetTick>
 800182c:	1b80      	subs	r0, r0, r6
 800182e:	2802      	cmp	r0, #2
 8001830:	d9d0      	bls.n	80017d4 <HAL_RCC_OscConfig+0x434>
 8001832:	e627      	b.n	8001484 <HAL_RCC_OscConfig+0xe4>
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001834:	f7ff fb52 	bl	8000edc <HAL_GetTick>
 8001838:	1b00      	subs	r0, r0, r4
 800183a:	2802      	cmp	r0, #2
 800183c:	d9ef      	bls.n	800181e <HAL_RCC_OscConfig+0x47e>
 800183e:	e621      	b.n	8001484 <HAL_RCC_OscConfig+0xe4>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Disable all PLL outputs to save power if no PLLs on */
        if((READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == RESET)
 8001840:	682b      	ldr	r3, [r5, #0]
 8001842:	011a      	lsls	r2, r3, #4
           && 
           (READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == RESET)
#endif /* RCC_PLLSAI2_SUPPORT */
          )
        {  
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 8001844:	bf5e      	ittt	pl
 8001846:	68eb      	ldrpl	r3, [r5, #12]
 8001848:	f023 0303 	bicpl.w	r3, r3, #3
 800184c:	60eb      	strpl	r3, [r5, #12]
        }
        
#if defined(RCC_PLLSAI2_SUPPORT)
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
#else
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI2CLK);
 800184e:	68eb      	ldr	r3, [r5, #12]
 8001850:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 8001854:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001858:	60eb      	str	r3, [r5, #12]
#endif /* RCC_PLLSAI2_SUPPORT */

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800185a:	f7ff fb3f 	bl	8000edc <HAL_GetTick>
 800185e:	4604      	mov	r4, r0

        /* Wait till PLL is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
 8001860:	682b      	ldr	r3, [r5, #0]
 8001862:	019b      	lsls	r3, r3, #6
 8001864:	d5de      	bpl.n	8001824 <HAL_RCC_OscConfig+0x484>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001866:	f7ff fb39 	bl	8000edc <HAL_GetTick>
 800186a:	1b00      	subs	r0, r0, r4
 800186c:	2802      	cmp	r0, #2
 800186e:	d9f7      	bls.n	8001860 <HAL_RCC_OscConfig+0x4c0>
 8001870:	e608      	b.n	8001484 <HAL_RCC_OscConfig+0xe4>
        }
      }
    }
    else
    {
      return HAL_ERROR;
 8001872:	2001      	movs	r0, #1
    }
  }
  return HAL_OK;
}
 8001874:	b002      	add	sp, #8
 8001876:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800187a:	bf00      	nop
 800187c:	40021000 	.word	0x40021000
 8001880:	40007000 	.word	0x40007000

08001884 <HAL_RCC_ClockConfig>:
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001884:	4a57      	ldr	r2, [pc, #348]	; (80019e4 <HAL_RCC_ClockConfig+0x160>)
 8001886:	6813      	ldr	r3, [r2, #0]
 8001888:	f003 0307 	and.w	r3, r3, #7
 800188c:	428b      	cmp	r3, r1
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800188e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001892:	4605      	mov	r5, r0
 8001894:	460e      	mov	r6, r1
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001896:	d30a      	bcc.n	80018ae <HAL_RCC_ClockConfig+0x2a>
      return HAL_ERROR;
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001898:	6829      	ldr	r1, [r5, #0]
 800189a:	0788      	lsls	r0, r1, #30
 800189c:	d514      	bpl.n	80018c8 <HAL_RCC_ClockConfig+0x44>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800189e:	4852      	ldr	r0, [pc, #328]	; (80019e8 <HAL_RCC_ClockConfig+0x164>)
 80018a0:	6883      	ldr	r3, [r0, #8]
 80018a2:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 80018a6:	68ab      	ldr	r3, [r5, #8]
 80018a8:	4313      	orrs	r3, r2
 80018aa:	6083      	str	r3, [r0, #8]
 80018ac:	e00c      	b.n	80018c8 <HAL_RCC_ClockConfig+0x44>

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80018ae:	6813      	ldr	r3, [r2, #0]
 80018b0:	f023 0307 	bic.w	r3, r3, #7
 80018b4:	430b      	orrs	r3, r1
 80018b6:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80018b8:	6813      	ldr	r3, [r2, #0]
 80018ba:	f003 0307 	and.w	r3, r3, #7
 80018be:	4299      	cmp	r1, r3
 80018c0:	d0ea      	beq.n	8001898 <HAL_RCC_ClockConfig+0x14>
    {
      return HAL_ERROR;
 80018c2:	2001      	movs	r0, #1
 80018c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80018c8:	07ca      	lsls	r2, r1, #31
 80018ca:	d406      	bmi.n	80018da <HAL_RCC_ClockConfig+0x56>
      }
    }
  }
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 80018cc:	4a45      	ldr	r2, [pc, #276]	; (80019e4 <HAL_RCC_ClockConfig+0x160>)
 80018ce:	6813      	ldr	r3, [r2, #0]
 80018d0:	f003 0307 	and.w	r3, r3, #7
 80018d4:	429e      	cmp	r6, r3
 80018d6:	d351      	bcc.n	800197c <HAL_RCC_ClockConfig+0xf8>
 80018d8:	e05a      	b.n	8001990 <HAL_RCC_ClockConfig+0x10c>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80018da:	686b      	ldr	r3, [r5, #4]
 80018dc:	4c42      	ldr	r4, [pc, #264]	; (80019e8 <HAL_RCC_ClockConfig+0x164>)
 80018de:	2b02      	cmp	r3, #2
    {
      /* Check the HSE ready flag */
      if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET)
 80018e0:	6822      	ldr	r2, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80018e2:	d102      	bne.n	80018ea <HAL_RCC_ClockConfig+0x66>
    {
      /* Check the HSE ready flag */
      if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET)
 80018e4:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 80018e8:	e00a      	b.n	8001900 <HAL_RCC_ClockConfig+0x7c>
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80018ea:	2b03      	cmp	r3, #3
 80018ec:	d102      	bne.n	80018f4 <HAL_RCC_ClockConfig+0x70>
    {
      /* Check the PLL ready flag */
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 80018ee:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 80018f2:	e005      	b.n	8001900 <HAL_RCC_ClockConfig+0x7c>
      {
        return HAL_ERROR;
      }
    }
    /* MSI is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 80018f4:	b913      	cbnz	r3, 80018fc <HAL_RCC_ClockConfig+0x78>
    {
      /* Check the MSI ready flag */
      if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET)
 80018f6:	f012 0f02 	tst.w	r2, #2
 80018fa:	e001      	b.n	8001900 <HAL_RCC_ClockConfig+0x7c>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
 80018fc:	f412 6f80 	tst.w	r2, #1024	; 0x400
 8001900:	d0df      	beq.n	80018c2 <HAL_RCC_ClockConfig+0x3e>
      {
        return HAL_ERROR;
      }
    }
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8001902:	68a2      	ldr	r2, [r4, #8]
 8001904:	f022 0203 	bic.w	r2, r2, #3
 8001908:	4313      	orrs	r3, r2
 800190a:	60a3      	str	r3, [r4, #8]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800190c:	f7ff fae6 	bl	8000edc <HAL_GetTick>

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001910:	686b      	ldr	r3, [r5, #4]
 8001912:	2b02      	cmp	r3, #2
      }
    }
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001914:	4607      	mov	r7, r0

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
      {
        if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001916:	f241 3888 	movw	r8, #5000	; 0x1388
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800191a:	d10c      	bne.n	8001936 <HAL_RCC_ClockConfig+0xb2>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
 800191c:	68a3      	ldr	r3, [r4, #8]
 800191e:	f003 030c 	and.w	r3, r3, #12
 8001922:	2b08      	cmp	r3, #8
 8001924:	d0d2      	beq.n	80018cc <HAL_RCC_ClockConfig+0x48>
      {
        if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001926:	f7ff fad9 	bl	8000edc <HAL_GetTick>
 800192a:	1bc0      	subs	r0, r0, r7
 800192c:	4540      	cmp	r0, r8
 800192e:	d9f5      	bls.n	800191c <HAL_RCC_ClockConfig+0x98>
        {
          return HAL_TIMEOUT;
 8001930:	2003      	movs	r0, #3
 8001932:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001936:	2b03      	cmp	r3, #3
 8001938:	d10a      	bne.n	8001950 <HAL_RCC_ClockConfig+0xcc>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800193a:	68a3      	ldr	r3, [r4, #8]
 800193c:	f003 030c 	and.w	r3, r3, #12
 8001940:	2b0c      	cmp	r3, #12
 8001942:	d0c3      	beq.n	80018cc <HAL_RCC_ClockConfig+0x48>
      {
        if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001944:	f7ff faca 	bl	8000edc <HAL_GetTick>
 8001948:	1bc0      	subs	r0, r0, r7
 800194a:	4540      	cmp	r0, r8
 800194c:	d9f5      	bls.n	800193a <HAL_RCC_ClockConfig+0xb6>
 800194e:	e7ef      	b.n	8001930 <HAL_RCC_ClockConfig+0xac>
        {
          return HAL_TIMEOUT;
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8001950:	b973      	cbnz	r3, 8001970 <HAL_RCC_ClockConfig+0xec>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
 8001952:	68a3      	ldr	r3, [r4, #8]
 8001954:	f013 0f0c 	tst.w	r3, #12
 8001958:	d0b8      	beq.n	80018cc <HAL_RCC_ClockConfig+0x48>
      {
        if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800195a:	f7ff fabf 	bl	8000edc <HAL_GetTick>
 800195e:	1bc0      	subs	r0, r0, r7
 8001960:	4540      	cmp	r0, r8
 8001962:	d9f6      	bls.n	8001952 <HAL_RCC_ClockConfig+0xce>
 8001964:	e7e4      	b.n	8001930 <HAL_RCC_ClockConfig+0xac>
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
      {
        if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001966:	f7ff fab9 	bl	8000edc <HAL_GetTick>
 800196a:	1bc0      	subs	r0, r0, r7
 800196c:	4540      	cmp	r0, r8
 800196e:	d8df      	bhi.n	8001930 <HAL_RCC_ClockConfig+0xac>
        }
      }
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
 8001970:	68a3      	ldr	r3, [r4, #8]
 8001972:	f003 030c 	and.w	r3, r3, #12
 8001976:	2b04      	cmp	r3, #4
 8001978:	d1f5      	bne.n	8001966 <HAL_RCC_ClockConfig+0xe2>
 800197a:	e7a7      	b.n	80018cc <HAL_RCC_ClockConfig+0x48>
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800197c:	6813      	ldr	r3, [r2, #0]
 800197e:	f023 0307 	bic.w	r3, r3, #7
 8001982:	4333      	orrs	r3, r6
 8001984:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8001986:	6813      	ldr	r3, [r2, #0]
 8001988:	f003 0307 	and.w	r3, r3, #7
 800198c:	429e      	cmp	r6, r3
 800198e:	d198      	bne.n	80018c2 <HAL_RCC_ClockConfig+0x3e>
      return HAL_ERROR;
    }
  }
  
  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001990:	6829      	ldr	r1, [r5, #0]
 8001992:	4c15      	ldr	r4, [pc, #84]	; (80019e8 <HAL_RCC_ClockConfig+0x164>)
 8001994:	f011 0f04 	tst.w	r1, #4
 8001998:	d005      	beq.n	80019a6 <HAL_RCC_ClockConfig+0x122>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800199a:	68a3      	ldr	r3, [r4, #8]
 800199c:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 80019a0:	68eb      	ldr	r3, [r5, #12]
 80019a2:	4313      	orrs	r3, r2
 80019a4:	60a3      	str	r3, [r4, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80019a6:	070b      	lsls	r3, r1, #28
 80019a8:	d506      	bpl.n	80019b8 <HAL_RCC_ClockConfig+0x134>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 80019aa:	68a3      	ldr	r3, [r4, #8]
 80019ac:	692a      	ldr	r2, [r5, #16]
 80019ae:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 80019b2:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 80019b6:	60a3      	str	r3, [r4, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 80019b8:	f7ff fc54 	bl	8001264 <HAL_RCC_GetSysClockFreq>
 80019bc:	68a3      	ldr	r3, [r4, #8]
 80019be:	22f0      	movs	r2, #240	; 0xf0
 80019c0:	fa92 f2a2 	rbit	r2, r2
 80019c4:	fab2 f282 	clz	r2, r2
 80019c8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80019cc:	40d3      	lsrs	r3, r2
 80019ce:	4a07      	ldr	r2, [pc, #28]	; (80019ec <HAL_RCC_ClockConfig+0x168>)
 80019d0:	5cd3      	ldrb	r3, [r2, r3]
 80019d2:	40d8      	lsrs	r0, r3
 80019d4:	4b06      	ldr	r3, [pc, #24]	; (80019f0 <HAL_RCC_ClockConfig+0x16c>)
 80019d6:	6018      	str	r0, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 80019d8:	2000      	movs	r0, #0
 80019da:	f7ff fa57 	bl	8000e8c <HAL_InitTick>

  return HAL_OK;
 80019de:	2000      	movs	r0, #0
}
 80019e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80019e4:	40022000 	.word	0x40022000
 80019e8:	40021000 	.word	0x40021000
 80019ec:	08007a3e 	.word	0x08007a3e
 80019f0:	200000a8 	.word	0x200000a8

080019f4 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 80019f4:	4b01      	ldr	r3, [pc, #4]	; (80019fc <HAL_RCC_GetHCLKFreq+0x8>)
 80019f6:	6818      	ldr	r0, [r3, #0]
 80019f8:	4770      	bx	lr
 80019fa:	bf00      	nop
 80019fc:	200000a8 	.word	0x200000a8

08001a00 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 8001a00:	4b08      	ldr	r3, [pc, #32]	; (8001a24 <HAL_RCC_GetPCLK1Freq+0x24>)
 8001a02:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 8001a06:	689b      	ldr	r3, [r3, #8]
 8001a08:	fa92 f2a2 	rbit	r2, r2
 8001a0c:	fab2 f282 	clz	r2, r2
 8001a10:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8001a14:	40d3      	lsrs	r3, r2
 8001a16:	4a04      	ldr	r2, [pc, #16]	; (8001a28 <HAL_RCC_GetPCLK1Freq+0x28>)
 8001a18:	5cd3      	ldrb	r3, [r2, r3]
 8001a1a:	4a04      	ldr	r2, [pc, #16]	; (8001a2c <HAL_RCC_GetPCLK1Freq+0x2c>)
 8001a1c:	6810      	ldr	r0, [r2, #0]
}
 8001a1e:	40d8      	lsrs	r0, r3
 8001a20:	4770      	bx	lr
 8001a22:	bf00      	nop
 8001a24:	40021000 	.word	0x40021000
 8001a28:	08007a4e 	.word	0x08007a4e
 8001a2c:	200000a8 	.word	0x200000a8

08001a30 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 8001a30:	4b08      	ldr	r3, [pc, #32]	; (8001a54 <HAL_RCC_GetPCLK2Freq+0x24>)
 8001a32:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001a36:	689b      	ldr	r3, [r3, #8]
 8001a38:	fa92 f2a2 	rbit	r2, r2
 8001a3c:	fab2 f282 	clz	r2, r2
 8001a40:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
 8001a44:	40d3      	lsrs	r3, r2
 8001a46:	4a04      	ldr	r2, [pc, #16]	; (8001a58 <HAL_RCC_GetPCLK2Freq+0x28>)
 8001a48:	5cd3      	ldrb	r3, [r2, r3]
 8001a4a:	4a04      	ldr	r2, [pc, #16]	; (8001a5c <HAL_RCC_GetPCLK2Freq+0x2c>)
 8001a4c:	6810      	ldr	r0, [r2, #0]
}
 8001a4e:	40d8      	lsrs	r0, r3
 8001a50:	4770      	bx	lr
 8001a52:	bf00      	nop
 8001a54:	40021000 	.word	0x40021000
 8001a58:	08007a4e 	.word	0x08007a4e
 8001a5c:	200000a8 	.word	0x200000a8

08001a60 <RCCEx_PLLSAI1_Config>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *PllSai1, uint32_t Divider)
{
 8001a60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));
  
  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8001a62:	4b5a      	ldr	r3, [pc, #360]	; (8001bcc <RCCEx_PLLSAI1_Config+0x16c>)
 8001a64:	68da      	ldr	r2, [r3, #12]
 8001a66:	f012 0f03 	tst.w	r2, #3
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *PllSai1, uint32_t Divider)
{
 8001a6a:	4604      	mov	r4, r0
 8001a6c:	460e      	mov	r6, r1
 8001a6e:	461d      	mov	r5, r3
 8001a70:	6800      	ldr	r0, [r0, #0]
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));
  
  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8001a72:	d013      	beq.n	8001a9c <RCCEx_PLLSAI1_Config+0x3c>
  {
    /* PLL clock source and divider M already set, check that no request for change  */ 
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
 8001a74:	68da      	ldr	r2, [r3, #12]
 8001a76:	f002 0203 	and.w	r2, r2, #3
 8001a7a:	4282      	cmp	r2, r0
 8001a7c:	d124      	bne.n	8001ac8 <RCCEx_PLLSAI1_Config+0x68>
       || 
 8001a7e:	b31a      	cbz	r2, 8001ac8 <RCCEx_PLLSAI1_Config+0x68>
       (PllSai1->PLLSAI1Source == RCC_PLLSOURCE_NONE)
       || 
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> POSITION_VAL(RCC_PLLCFGR_PLLM)) + 1U) != PllSai1->PLLSAI1M)
 8001a80:	68da      	ldr	r2, [r3, #12]
 8001a82:	2370      	movs	r3, #112	; 0x70
 8001a84:	fa93 f3a3 	rbit	r3, r3
 8001a88:	fab3 f183 	clz	r1, r3
  {
    /* PLL clock source and divider M already set, check that no request for change  */ 
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
       || 
       (PllSai1->PLLSAI1Source == RCC_PLLSOURCE_NONE)
       || 
 8001a8c:	f002 0370 	and.w	r3, r2, #112	; 0x70
 8001a90:	40cb      	lsrs	r3, r1
 8001a92:	6862      	ldr	r2, [r4, #4]
 8001a94:	3301      	adds	r3, #1
 8001a96:	4293      	cmp	r3, r2
 8001a98:	d116      	bne.n	8001ac8 <RCCEx_PLLSAI1_Config+0x68>
 8001a9a:	e025      	b.n	8001ae8 <RCCEx_PLLSAI1_Config+0x88>
    }
  }
  else
  {
    /* Check PLLSAI1 clock source availability */
    switch(PllSai1->PLLSAI1Source)
 8001a9c:	2802      	cmp	r0, #2
 8001a9e:	d008      	beq.n	8001ab2 <RCCEx_PLLSAI1_Config+0x52>
 8001aa0:	2803      	cmp	r0, #3
 8001aa2:	d00a      	beq.n	8001aba <RCCEx_PLLSAI1_Config+0x5a>
 8001aa4:	2801      	cmp	r0, #1
 8001aa6:	d10f      	bne.n	8001ac8 <RCCEx_PLLSAI1_Config+0x68>
    {
    case RCC_PLLSOURCE_MSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 8001aa8:	681b      	ldr	r3, [r3, #0]
 8001aaa:	079f      	lsls	r7, r3, #30
 8001aac:	f140 808d 	bpl.w	8001bca <RCCEx_PLLSAI1_Config+0x16a>
 8001ab0:	e00c      	b.n	8001acc <RCCEx_PLLSAI1_Config+0x6c>
      {
        status = HAL_ERROR;
      }
      break;
    case RCC_PLLSOURCE_HSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 8001ab2:	681b      	ldr	r3, [r3, #0]
 8001ab4:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8001ab8:	e005      	b.n	8001ac6 <RCCEx_PLLSAI1_Config+0x66>
      {
        status = HAL_ERROR;
      }
      break;
    case RCC_PLLSOURCE_HSE:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY) && HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8001aba:	681a      	ldr	r2, [r3, #0]
 8001abc:	0391      	lsls	r1, r2, #14
 8001abe:	d405      	bmi.n	8001acc <RCCEx_PLLSAI1_Config+0x6c>
 8001ac0:	681b      	ldr	r3, [r3, #0]
 8001ac2:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 8001ac6:	d101      	bne.n	8001acc <RCCEx_PLLSAI1_Config+0x6c>
 8001ac8:	2001      	movs	r0, #1
 8001aca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
    
    if(status == HAL_OK)
    {
      /* Set PLLSAI1 clock source and divider M */
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai1->PLLSAI1Source | (PllSai1->PLLSAI1M - 1U) << POSITION_VAL(RCC_PLLCFGR_PLLM));
 8001acc:	68e9      	ldr	r1, [r5, #12]
 8001ace:	2370      	movs	r3, #112	; 0x70
 8001ad0:	fa93 f3a3 	rbit	r3, r3
 8001ad4:	fab3 f283 	clz	r2, r3
 8001ad8:	6863      	ldr	r3, [r4, #4]
 8001ada:	3b01      	subs	r3, #1
 8001adc:	4093      	lsls	r3, r2
 8001ade:	f021 0273 	bic.w	r2, r1, #115	; 0x73
 8001ae2:	4310      	orrs	r0, r2
 8001ae4:	4318      	orrs	r0, r3
 8001ae6:	60e8      	str	r0, [r5, #12]
  }
  
  if(status == HAL_OK)
  {
    /* Disable the PLLSAI1 */
    __HAL_RCC_PLLSAI1_DISABLE();
 8001ae8:	682b      	ldr	r3, [r5, #0]
 8001aea:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8001aee:	602b      	str	r3, [r5, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001af0:	f7ff f9f4 	bl	8000edc <HAL_GetTick>
 8001af4:	4607      	mov	r7, r0

    /* Wait till PLLSAI1 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != RESET)
 8001af6:	682b      	ldr	r3, [r5, #0]
 8001af8:	4934      	ldr	r1, [pc, #208]	; (8001bcc <RCCEx_PLLSAI1_Config+0x16c>)
 8001afa:	011a      	lsls	r2, r3, #4
 8001afc:	d506      	bpl.n	8001b0c <RCCEx_PLLSAI1_Config+0xac>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8001afe:	f7ff f9ed 	bl	8000edc <HAL_GetTick>
 8001b02:	1bc0      	subs	r0, r0, r7
 8001b04:	2802      	cmp	r0, #2
 8001b06:	d9f6      	bls.n	8001af6 <RCCEx_PLLSAI1_Config+0x96>
      {
        status = HAL_TIMEOUT;
 8001b08:	2003      	movs	r0, #3
 8001b0a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001b0c:	f44f 43fe 	mov.w	r3, #32512	; 0x7f00
 8001b10:	68a7      	ldr	r7, [r4, #8]
      }
    }

    if(status == HAL_OK)    
    {
      if(Divider == DIVIDER_P_UPDATE)
 8001b12:	b9b6      	cbnz	r6, 8001b42 <RCCEx_PLLSAI1_Config+0xe2>
      {
        assert_param(IS_RCC_PLLSAI1P_VALUE(PllSai1->PLLSAI1P));
        /* Configure the PLLSAI1 Division factor P and Multiplication factor N*/
#if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
        MODIFY_REG(RCC->PLLSAI1CFGR, 
 8001b14:	6908      	ldr	r0, [r1, #16]
 8001b16:	fa93 f2a3 	rbit	r2, r3
 8001b1a:	f04f 4678 	mov.w	r6, #4160749568	; 0xf8000000
 8001b1e:	fab2 f282 	clz	r2, r2
 8001b22:	fa96 f6a6 	rbit	r6, r6
 8001b26:	fa07 f302 	lsl.w	r3, r7, r2
 8001b2a:	68e2      	ldr	r2, [r4, #12]
 8001b2c:	fab6 f686 	clz	r6, r6
 8001b30:	40b2      	lsls	r2, r6
 8001b32:	4313      	orrs	r3, r2
 8001b34:	f020 4278 	bic.w	r2, r0, #4160749568	; 0xf8000000
 8001b38:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
 8001b3c:	431a      	orrs	r2, r3
 8001b3e:	610a      	str	r2, [r1, #16]
 8001b40:	e02d      	b.n	8001b9e <RCCEx_PLLSAI1_Config+0x13e>
                   RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1P, 
                   (PllSai1->PLLSAI1N << POSITION_VAL(RCC_PLLSAI1CFGR_PLLSAI1N)) | 
                   ((PllSai1->PLLSAI1P >> 4U) << POSITION_VAL(RCC_PLLSAI1CFGR_PLLSAI1P)));
#endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */
      }
      else if(Divider == DIVIDER_Q_UPDATE)
 8001b42:	2e01      	cmp	r6, #1
      {
        assert_param(IS_RCC_PLLSAI1Q_VALUE(PllSai1->PLLSAI1Q));
        /* Configure the PLLSAI1 Division factor Q and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR, 
 8001b44:	6908      	ldr	r0, [r1, #16]
                   RCC_PLLSAI1CFGR_PLLSAI1N | RCC_PLLSAI1CFGR_PLLSAI1P, 
                   (PllSai1->PLLSAI1N << POSITION_VAL(RCC_PLLSAI1CFGR_PLLSAI1N)) | 
                   ((PllSai1->PLLSAI1P >> 4U) << POSITION_VAL(RCC_PLLSAI1CFGR_PLLSAI1P)));
#endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */
      }
      else if(Divider == DIVIDER_Q_UPDATE)
 8001b46:	d113      	bne.n	8001b70 <RCCEx_PLLSAI1_Config+0x110>
 8001b48:	fa93 f2a3 	rbit	r2, r3
 8001b4c:	f44f 03c0 	mov.w	r3, #6291456	; 0x600000
      {
        assert_param(IS_RCC_PLLSAI1Q_VALUE(PllSai1->PLLSAI1Q));
        /* Configure the PLLSAI1 Division factor Q and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR, 
 8001b50:	fab2 f282 	clz	r2, r2
 8001b54:	fa93 f3a3 	rbit	r3, r3
 8001b58:	6926      	ldr	r6, [r4, #16]
 8001b5a:	0876      	lsrs	r6, r6, #1
 8001b5c:	fab3 f383 	clz	r3, r3
 8001b60:	3e01      	subs	r6, #1
 8001b62:	409e      	lsls	r6, r3
 8001b64:	fa07 f302 	lsl.w	r3, r7, r2
 8001b68:	4333      	orrs	r3, r6
 8001b6a:	f420 02c0 	bic.w	r2, r0, #6291456	; 0x600000
 8001b6e:	e012      	b.n	8001b96 <RCCEx_PLLSAI1_Config+0x136>
 8001b70:	fa93 f2a3 	rbit	r2, r3
 8001b74:	f04f 63c0 	mov.w	r3, #100663296	; 0x6000000
      }
      else
      {
        assert_param(IS_RCC_PLLSAI1R_VALUE(PllSai1->PLLSAI1R));
        /* Configure the PLLSAI1 Division factor R and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR, 
 8001b78:	fab2 f282 	clz	r2, r2
 8001b7c:	fa93 f3a3 	rbit	r3, r3
 8001b80:	6966      	ldr	r6, [r4, #20]
 8001b82:	0876      	lsrs	r6, r6, #1
 8001b84:	fab3 f383 	clz	r3, r3
 8001b88:	3e01      	subs	r6, #1
 8001b8a:	409e      	lsls	r6, r3
 8001b8c:	fa07 f302 	lsl.w	r3, r7, r2
 8001b90:	4333      	orrs	r3, r6
 8001b92:	f020 62c0 	bic.w	r2, r0, #100663296	; 0x6000000
 8001b96:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
 8001b9a:	4313      	orrs	r3, r2
 8001b9c:	610b      	str	r3, [r1, #16]
                   (PllSai1->PLLSAI1N << POSITION_VAL(RCC_PLLSAI1CFGR_PLLSAI1N)) | 
                   (((PllSai1->PLLSAI1R >> 1U) - 1U) << POSITION_VAL(RCC_PLLSAI1CFGR_PLLSAI1R)));
      }

      /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
      __HAL_RCC_PLLSAI1_ENABLE();
 8001b9e:	682b      	ldr	r3, [r5, #0]
 8001ba0:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8001ba4:	602b      	str	r3, [r5, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001ba6:	f7ff f999 	bl	8000edc <HAL_GetTick>
 8001baa:	4606      	mov	r6, r0

      /* Wait till PLLSAI1 is ready */
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == RESET)
 8001bac:	682b      	ldr	r3, [r5, #0]
 8001bae:	4a07      	ldr	r2, [pc, #28]	; (8001bcc <RCCEx_PLLSAI1_Config+0x16c>)
 8001bb0:	011b      	lsls	r3, r3, #4
 8001bb2:	d405      	bmi.n	8001bc0 <RCCEx_PLLSAI1_Config+0x160>
      {
        if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8001bb4:	f7ff f992 	bl	8000edc <HAL_GetTick>
 8001bb8:	1b80      	subs	r0, r0, r6
 8001bba:	2802      	cmp	r0, #2
 8001bbc:	d9f6      	bls.n	8001bac <RCCEx_PLLSAI1_Config+0x14c>
 8001bbe:	e7a3      	b.n	8001b08 <RCCEx_PLLSAI1_Config+0xa8>
      }

      if(status == HAL_OK)    
      {
        /* Configure the PLLSAI1 Clock output(s) */
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 8001bc0:	6911      	ldr	r1, [r2, #16]
 8001bc2:	69a3      	ldr	r3, [r4, #24]
 8001bc4:	430b      	orrs	r3, r1
 8001bc6:	6113      	str	r3, [r2, #16]
 8001bc8:	2000      	movs	r0, #0
      }
    }
  }
  
  return status;
}
 8001bca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001bcc:	40021000 	.word	0x40021000

08001bd0 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8001bd0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8001bd4:	6805      	ldr	r5, [r0, #0]
 8001bd6:	f415 6500 	ands.w	r5, r5, #2048	; 0x800
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8001bda:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8001bdc:	d01f      	beq.n	8001c1e <HAL_RCCEx_PeriphCLKConfig+0x4e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(PeriphClkInit->Sai1ClockSelection));

    switch(PeriphClkInit->Sai1ClockSelection)
 8001bde:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
 8001be0:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8001be4:	d004      	beq.n	8001bf0 <HAL_RCCEx_PeriphCLKConfig+0x20>
 8001be6:	f5b1 0f40 	cmp.w	r1, #12582912	; 0xc00000
 8001bea:	d00c      	beq.n	8001c06 <HAL_RCCEx_PeriphCLKConfig+0x36>
 8001bec:	b9b1      	cbnz	r1, 8001c1c <HAL_RCCEx_PeriphCLKConfig+0x4c>
 8001bee:	e005      	b.n	8001bfc <HAL_RCCEx_PeriphCLKConfig+0x2c>
    case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
      /* Enable SAI Clock output generated form System PLL . */
#if defined(RCC_PLLSAI2_SUPPORT)
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
#else
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI2CLK);
 8001bf0:	4a96      	ldr	r2, [pc, #600]	; (8001e4c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001bf2:	68d3      	ldr	r3, [r2, #12]
 8001bf4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001bf8:	60d3      	str	r3, [r2, #12]
#endif /* RCC_PLLSAI2_SUPPORT */
      /* SAI1 clock source config set later after clock selection check */
      break;
 8001bfa:	e004      	b.n	8001c06 <HAL_RCCEx_PeriphCLKConfig+0x36>

    case RCC_SAI1CLKSOURCE_PLLSAI1:  /* PLLSAI1 is used as clock source for SAI1*/
      /* PLLSAI1 input clock, parameters M, N & P configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8001bfc:	3004      	adds	r0, #4
 8001bfe:	f7ff ff2f 	bl	8001a60 <RCCEx_PLLSAI1_Config>
    default:
      ret = HAL_ERROR;
      break;
    }

    if(ret == HAL_OK)
 8001c02:	4605      	mov	r5, r0
 8001c04:	b958      	cbnz	r0, 8001c1e <HAL_RCCEx_PeriphCLKConfig+0x4e>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8001c06:	4991      	ldr	r1, [pc, #580]	; (8001e4c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001c08:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8001c0c:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 8001c10:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001c12:	4313      	orrs	r3, r2
 8001c14:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 8001c18:	2500      	movs	r5, #0
 8001c1a:	e000      	b.n	8001c1e <HAL_RCCEx_PeriphCLKConfig+0x4e>
    case RCC_SAI1CLKSOURCE_PIN:      /* External clock is used as source of SAI1 clock*/
      /* SAI1 clock source config set later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8001c1c:	2501      	movs	r5, #1
    }
  }
#endif /* SAI2 */

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8001c1e:	6823      	ldr	r3, [r4, #0]
 8001c20:	039e      	lsls	r6, r3, #14
 8001c22:	d55a      	bpl.n	8001cda <HAL_RCCEx_PeriphCLKConfig+0x10a>
    
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8001c24:	4e89      	ldr	r6, [pc, #548]	; (8001e4c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001c26:	6db3      	ldr	r3, [r6, #88]	; 0x58
 8001c28:	00d8      	lsls	r0, r3, #3
 8001c2a:	d40a      	bmi.n	8001c42 <HAL_RCCEx_PeriphCLKConfig+0x72>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8001c2c:	6db3      	ldr	r3, [r6, #88]	; 0x58
 8001c2e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001c32:	65b3      	str	r3, [r6, #88]	; 0x58
 8001c34:	6db3      	ldr	r3, [r6, #88]	; 0x58
 8001c36:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001c3a:	9301      	str	r3, [sp, #4]
 8001c3c:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8001c3e:	2701      	movs	r7, #1
 8001c40:	e000      	b.n	8001c44 <HAL_RCCEx_PeriphCLKConfig+0x74>
#endif /* SAI2 */

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
  {
    FlagStatus       pwrclkchanged = RESET;
 8001c42:	2700      	movs	r7, #0
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }
      
    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8001c44:	f8df 8208 	ldr.w	r8, [pc, #520]	; 8001e50 <HAL_RCCEx_PeriphCLKConfig+0x280>
 8001c48:	f8d8 3000 	ldr.w	r3, [r8]
 8001c4c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001c50:	f8c8 3000 	str.w	r3, [r8]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8001c54:	f7ff f942 	bl	8000edc <HAL_GetTick>
 8001c58:	4681      	mov	r9, r0

    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8001c5a:	f8d8 3000 	ldr.w	r3, [r8]
 8001c5e:	05d9      	lsls	r1, r3, #23
 8001c60:	d406      	bmi.n	8001c70 <HAL_RCCEx_PeriphCLKConfig+0xa0>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001c62:	f7ff f93b 	bl	8000edc <HAL_GetTick>
 8001c66:	ebc9 0000 	rsb	r0, r9, r0
 8001c6a:	2802      	cmp	r0, #2
 8001c6c:	d9f5      	bls.n	8001c5a <HAL_RCCEx_PeriphCLKConfig+0x8a>
 8001c6e:	e02e      	b.n	8001cce <HAL_RCCEx_PeriphCLKConfig+0xfe>
        ret = HAL_TIMEOUT;
        break;
      }
    }

    if(ret == HAL_OK)
 8001c70:	bb75      	cbnz	r5, 8001cd0 <HAL_RCCEx_PeriphCLKConfig+0x100>
    { 
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8001c72:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
 8001c76:	4a75      	ldr	r2, [pc, #468]	; (8001e4c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
      
      if((tmpregister != RCC_RTCCLKSOURCE_NO_CLK) && (tmpregister != PeriphClkInit->RTCClockSelection))
 8001c78:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8001c7c:	d014      	beq.n	8001ca8 <HAL_RCCEx_PeriphCLKConfig+0xd8>
 8001c7e:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8001c80:	428b      	cmp	r3, r1
 8001c82:	d011      	beq.n	8001ca8 <HAL_RCCEx_PeriphCLKConfig+0xd8>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8001c84:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 8001c88:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
 8001c8c:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 8001c90:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 8001c94:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
      
      if((tmpregister != RCC_RTCCLKSOURCE_NO_CLK) && (tmpregister != PeriphClkInit->RTCClockSelection))
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8001c98:	f423 7340 	bic.w	r3, r3, #768	; 0x300
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
        __HAL_RCC_BACKUPRESET_RELEASE();
 8001c9c:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 8001ca0:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
 8001ca4:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8001ca8:	07da      	lsls	r2, r3, #31
 8001caa:	f140 80c2 	bpl.w	8001e32 <HAL_RCCEx_PeriphCLKConfig+0x262>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001cae:	f7ff f915 	bl	8000edc <HAL_GetTick>

        /* Wait till LSE is ready */
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001cb2:	f241 3988 	movw	r9, #5000	; 0x1388

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001cb6:	4680      	mov	r8, r0

        /* Wait till LSE is ready */
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
 8001cb8:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
 8001cbc:	079b      	lsls	r3, r3, #30
 8001cbe:	f100 80b8 	bmi.w	8001e32 <HAL_RCCEx_PeriphCLKConfig+0x262>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001cc2:	f7ff f90b 	bl	8000edc <HAL_GetTick>
 8001cc6:	ebc8 0000 	rsb	r0, r8, r0
 8001cca:	4548      	cmp	r0, r9
 8001ccc:	d9f4      	bls.n	8001cb8 <HAL_RCCEx_PeriphCLKConfig+0xe8>

    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
      {
        ret = HAL_TIMEOUT;
 8001cce:	2503      	movs	r5, #3
      /* set overall return value */
      status = ret;
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8001cd0:	b11f      	cbz	r7, 8001cda <HAL_RCCEx_PeriphCLKConfig+0x10a>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8001cd2:	6db3      	ldr	r3, [r6, #88]	; 0x58
 8001cd4:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8001cd8:	65b3      	str	r3, [r6, #88]	; 0x58
    }
  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8001cda:	6823      	ldr	r3, [r4, #0]
 8001cdc:	07df      	lsls	r7, r3, #31
 8001cde:	d508      	bpl.n	8001cf2 <HAL_RCCEx_PeriphCLKConfig+0x122>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8001ce0:	485a      	ldr	r0, [pc, #360]	; (8001e4c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001ce2:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8001ce6:	f022 0103 	bic.w	r1, r2, #3
 8001cea:	6a22      	ldr	r2, [r4, #32]
 8001cec:	430a      	orrs	r2, r1
 8001cee:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- USART2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8001cf2:	079e      	lsls	r6, r3, #30
 8001cf4:	d508      	bpl.n	8001d08 <HAL_RCCEx_PeriphCLKConfig+0x138>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8001cf6:	4855      	ldr	r0, [pc, #340]	; (8001e4c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001cf8:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8001cfc:	f022 010c 	bic.w	r1, r2, #12
 8001d00:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001d02:	430a      	orrs	r2, r1
 8001d04:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

#endif /* UART5 */

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8001d08:	0698      	lsls	r0, r3, #26
 8001d0a:	d508      	bpl.n	8001d1e <HAL_RCCEx_PeriphCLKConfig+0x14e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8001d0c:	484f      	ldr	r0, [pc, #316]	; (8001e4c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001d0e:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8001d12:	f422 6140 	bic.w	r1, r2, #3072	; 0xc00
 8001d16:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8001d18:	430a      	orrs	r2, r1
 8001d1a:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- LPTIM1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8001d1e:	0599      	lsls	r1, r3, #22
 8001d20:	d508      	bpl.n	8001d34 <HAL_RCCEx_PeriphCLKConfig+0x164>
  {
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8001d22:	484a      	ldr	r0, [pc, #296]	; (8001e4c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001d24:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8001d28:	f422 2140 	bic.w	r1, r2, #786432	; 0xc0000
 8001d2c:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8001d2e:	430a      	orrs	r2, r1
 8001d30:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- LPTIM2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8001d34:	055a      	lsls	r2, r3, #21
 8001d36:	d508      	bpl.n	8001d4a <HAL_RCCEx_PeriphCLKConfig+0x17a>
  {
    assert_param(IS_RCC_LPTIM2CLK(PeriphClkInit->Lptim2ClockSelection));
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8001d38:	4844      	ldr	r0, [pc, #272]	; (8001e4c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001d3a:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8001d3e:	f422 1140 	bic.w	r1, r2, #3145728	; 0x300000
 8001d42:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8001d44:	430a      	orrs	r2, r1
 8001d46:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8001d4a:	065f      	lsls	r7, r3, #25
 8001d4c:	d508      	bpl.n	8001d60 <HAL_RCCEx_PeriphCLKConfig+0x190>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8001d4e:	483f      	ldr	r0, [pc, #252]	; (8001e4c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001d50:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8001d54:	f422 5140 	bic.w	r1, r2, #12288	; 0x3000
 8001d58:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001d5a:	430a      	orrs	r2, r1
 8001d5c:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

#endif /* I2C2 */

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8001d60:	05de      	lsls	r6, r3, #23
 8001d62:	d508      	bpl.n	8001d76 <HAL_RCCEx_PeriphCLKConfig+0x1a6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8001d64:	4839      	ldr	r0, [pc, #228]	; (8001e4c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001d66:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8001d6a:	f422 3140 	bic.w	r1, r2, #196608	; 0x30000
 8001d6e:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8001d70:	430a      	orrs	r2, r1
 8001d72:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
#endif /* I2C4 */

#if defined(USB_OTG_FS) || defined(USB)

  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8001d76:	0498      	lsls	r0, r3, #18
 8001d78:	d51a      	bpl.n	8001db0 <HAL_RCCEx_PeriphCLKConfig+0x1e0>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8001d7a:	4a34      	ldr	r2, [pc, #208]	; (8001e4c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001d7c:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8001d7e:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8001d82:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 8001d86:	430b      	orrs	r3, r1

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8001d88:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000

  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8001d8c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8001d90:	d104      	bne.n	8001d9c <HAL_RCCEx_PeriphCLKConfig+0x1cc>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8001d92:	68d3      	ldr	r3, [r2, #12]
 8001d94:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8001d98:	60d3      	str	r3, [r2, #12]
 8001d9a:	e009      	b.n	8001db0 <HAL_RCCEx_PeriphCLKConfig+0x1e0>
    }
    else
    {
      if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 8001d9c:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 8001da0:	d106      	bne.n	8001db0 <HAL_RCCEx_PeriphCLKConfig+0x1e0>
      {
        /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8001da2:	2101      	movs	r1, #1
 8001da4:	1d20      	adds	r0, r4, #4
 8001da6:	f7ff fe5b 	bl	8001a60 <RCCEx_PLLSAI1_Config>
      
        if(ret != HAL_OK)
 8001daa:	2800      	cmp	r0, #0
 8001dac:	bf18      	it	ne
 8001dae:	4605      	movne	r5, r0
  }

#endif /* SDMMC1 */

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8001db0:	6823      	ldr	r3, [r4, #0]
 8001db2:	0359      	lsls	r1, r3, #13
 8001db4:	d51a      	bpl.n	8001dec <HAL_RCCEx_PeriphCLKConfig+0x21c>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8001db6:	4a25      	ldr	r2, [pc, #148]	; (8001e4c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001db8:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8001dba:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8001dbe:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 8001dc2:	430b      	orrs	r3, r1

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8001dc4:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8001dc8:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8001dcc:	d104      	bne.n	8001dd8 <HAL_RCCEx_PeriphCLKConfig+0x208>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8001dce:	68d3      	ldr	r3, [r2, #12]
 8001dd0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8001dd4:	60d3      	str	r3, [r2, #12]
 8001dd6:	e009      	b.n	8001dec <HAL_RCCEx_PeriphCLKConfig+0x21c>
    }
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 8001dd8:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 8001ddc:	d106      	bne.n	8001dec <HAL_RCCEx_PeriphCLKConfig+0x21c>
    {
      /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8001dde:	2101      	movs	r1, #1
 8001de0:	1d20      	adds	r0, r4, #4
 8001de2:	f7ff fe3d 	bl	8001a60 <RCCEx_PLLSAI1_Config>
      
      if(ret != HAL_OK)
 8001de6:	2800      	cmp	r0, #0
 8001de8:	bf18      	it	ne
 8001dea:	4605      	movne	r5, r0
      }
    }
  }

  /*-------------------------- ADC clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8001dec:	6823      	ldr	r3, [r4, #0]
 8001dee:	045a      	lsls	r2, r3, #17
 8001df0:	d512      	bpl.n	8001e18 <HAL_RCCEx_PeriphCLKConfig+0x248>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8001df2:	4916      	ldr	r1, [pc, #88]	; (8001e4c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001df4:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8001df6:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8001dfa:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 8001dfe:	4313      	orrs	r3, r2
    
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8001e00:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8001e04:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8001e08:	d106      	bne.n	8001e18 <HAL_RCCEx_PeriphCLKConfig+0x248>
    {
      /* PLLSAI1 input clock, parameters M, N & R configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 8001e0a:	2102      	movs	r1, #2
 8001e0c:	1d20      	adds	r0, r4, #4
 8001e0e:	f7ff fe27 	bl	8001a60 <RCCEx_PLLSAI1_Config>

      if(ret != HAL_OK)
 8001e12:	2800      	cmp	r0, #0
 8001e14:	bf18      	it	ne
 8001e16:	4605      	movne	r5, r0
  }

#if defined(SWPMI1)

  /*-------------------------- SWPMI1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 8001e18:	6823      	ldr	r3, [r4, #0]
 8001e1a:	041b      	lsls	r3, r3, #16
 8001e1c:	d512      	bpl.n	8001e44 <HAL_RCCEx_PeriphCLKConfig+0x274>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));

    /* Configure the SWPMI1 clock source */
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
 8001e1e:	490b      	ldr	r1, [pc, #44]	; (8001e4c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001e20:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8001e24:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
 8001e28:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8001e2a:	4313      	orrs	r3, r2
 8001e2c:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
  }

#endif /* DFSDM1_Filter0 */

  return status;
 8001e30:	e008      	b.n	8001e44 <HAL_RCCEx_PeriphCLKConfig+0x274>
      }
      
      if(ret == HAL_OK)
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8001e32:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
 8001e36:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8001e3a:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8001e3c:	4313      	orrs	r3, r2
 8001e3e:	f8c6 3090 	str.w	r3, [r6, #144]	; 0x90
 8001e42:	e745      	b.n	8001cd0 <HAL_RCCEx_PeriphCLKConfig+0x100>
  }

#endif /* DFSDM1_Filter0 */

  return status;
}
 8001e44:	4628      	mov	r0, r5
 8001e46:	b003      	add	sp, #12
 8001e48:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8001e4c:	40021000 	.word	0x40021000
 8001e50:	40007000 	.word	0x40007000

08001e54 <SPI_WaitFifoStateUntilTimeout.part.1>:
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
           on both master and slave sides in order to resynchronize the master
           and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8001e54:	6803      	ldr	r3, [r0, #0]
 8001e56:	685a      	ldr	r2, [r3, #4]
 8001e58:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 8001e5c:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8001e5e:	6842      	ldr	r2, [r0, #4]
 8001e60:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
 8001e64:	d10a      	bne.n	8001e7c <SPI_WaitFifoStateUntilTimeout.part.1+0x28>
 8001e66:	6882      	ldr	r2, [r0, #8]
 8001e68:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 8001e6c:	d002      	beq.n	8001e74 <SPI_WaitFifoStateUntilTimeout.part.1+0x20>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8001e6e:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8001e72:	d103      	bne.n	8001e7c <SPI_WaitFifoStateUntilTimeout.part.1+0x28>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 8001e74:	681a      	ldr	r2, [r3, #0]
 8001e76:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001e7a:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8001e7c:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8001e7e:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8001e82:	d107      	bne.n	8001e94 <SPI_WaitFifoStateUntilTimeout.part.1+0x40>
        {
          SPI_RESET_CRC(hspi);
 8001e84:	681a      	ldr	r2, [r3, #0]
 8001e86:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8001e8a:	601a      	str	r2, [r3, #0]
 8001e8c:	681a      	ldr	r2, [r3, #0]
 8001e8e:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8001e92:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 8001e94:	2301      	movs	r3, #1
 8001e96:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8001e9a:	2300      	movs	r3, #0
 8001e9c:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
      }
    }
  }

  return HAL_OK;
}
 8001ea0:	2003      	movs	r0, #3
 8001ea2:	4770      	bx	lr

08001ea4 <SPI_WaitFlagStateUntilTimeout.constprop.10>:
  * @param State: flag state to check
  * @param Timeout: Timeout duration
  * @param Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State,
 8001ea4:	b570      	push	{r4, r5, r6, lr}
 8001ea6:	4605      	mov	r5, r0
 8001ea8:	460c      	mov	r4, r1
 8001eaa:	4616      	mov	r6, r2
                                                       uint32_t Timeout, uint32_t Tickstart)
{
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8001eac:	682a      	ldr	r2, [r5, #0]
 8001eae:	6893      	ldr	r3, [r2, #8]
 8001eb0:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8001eb4:	b16b      	cbz	r3, 8001ed2 <SPI_WaitFlagStateUntilTimeout.constprop.10+0x2e>
  {
    if (Timeout != HAL_MAX_DELAY)
 8001eb6:	1c63      	adds	r3, r4, #1
 8001eb8:	d0f9      	beq.n	8001eae <SPI_WaitFlagStateUntilTimeout.constprop.10+0xa>
    {
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 8001eba:	b924      	cbnz	r4, 8001ec6 <SPI_WaitFlagStateUntilTimeout.constprop.10+0x22>
 8001ebc:	4628      	mov	r0, r5
      }
    }
  }

  return HAL_OK;
}
 8001ebe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8001ec2:	f7ff bfc7 	b.w	8001e54 <SPI_WaitFifoStateUntilTimeout.part.1>
{
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
  {
    if (Timeout != HAL_MAX_DELAY)
    {
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 8001ec6:	f7ff f809 	bl	8000edc <HAL_GetTick>
 8001eca:	1b80      	subs	r0, r0, r6
 8001ecc:	4284      	cmp	r4, r0
 8001ece:	d8ed      	bhi.n	8001eac <SPI_WaitFlagStateUntilTimeout.constprop.10+0x8>
 8001ed0:	e7f4      	b.n	8001ebc <SPI_WaitFlagStateUntilTimeout.constprop.10+0x18>
      }
    }
  }

  return HAL_OK;
}
 8001ed2:	2000      	movs	r0, #0
 8001ed4:	bd70      	pop	{r4, r5, r6, pc}

08001ed6 <SPI_WaitFifoStateUntilTimeout.constprop.11>:
  * @param State: Fifo state to check
  * @param Timeout: Timeout duration
  * @param Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
 8001ed6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8001ed8:	4606      	mov	r6, r0
 8001eda:	460c      	mov	r4, r1
 8001edc:	4615      	mov	r5, r2
 8001ede:	461f      	mov	r7, r3
                                                       uint32_t Timeout, uint32_t Tickstart)
{
  __IO uint8_t tmpreg;

  while ((hspi->Instance->SR & Fifo) != State)
 8001ee0:	6831      	ldr	r1, [r6, #0]
 8001ee2:	6888      	ldr	r0, [r1, #8]
 8001ee4:	4020      	ands	r0, r4
 8001ee6:	d015      	beq.n	8001f14 <SPI_WaitFifoStateUntilTimeout.constprop.11+0x3e>
  {
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 8001ee8:	f5b4 6fc0 	cmp.w	r4, #1536	; 0x600
    {
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 8001eec:	bf01      	itttt	eq
 8001eee:	7b0a      	ldrbeq	r2, [r1, #12]
 8001ef0:	b2d2      	uxtbeq	r2, r2
 8001ef2:	f88d 2007 	strbeq.w	r2, [sp, #7]
      /* To avoid GCC warning */
      UNUSED(tmpreg);
 8001ef6:	f89d 3007 	ldrbeq.w	r3, [sp, #7]
    }

    if (Timeout != HAL_MAX_DELAY)
 8001efa:	1c6b      	adds	r3, r5, #1
 8001efc:	d0f1      	beq.n	8001ee2 <SPI_WaitFifoStateUntilTimeout.constprop.11+0xc>
    {
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 8001efe:	b91d      	cbnz	r5, 8001f08 <SPI_WaitFifoStateUntilTimeout.constprop.11+0x32>
 8001f00:	4630      	mov	r0, r6
 8001f02:	f7ff ffa7 	bl	8001e54 <SPI_WaitFifoStateUntilTimeout.part.1>
 8001f06:	e005      	b.n	8001f14 <SPI_WaitFifoStateUntilTimeout.constprop.11+0x3e>
 8001f08:	f7fe ffe8 	bl	8000edc <HAL_GetTick>
 8001f0c:	1bc0      	subs	r0, r0, r7
 8001f0e:	4285      	cmp	r5, r0
 8001f10:	d8e6      	bhi.n	8001ee0 <SPI_WaitFifoStateUntilTimeout.constprop.11+0xa>
 8001f12:	e7f5      	b.n	8001f00 <SPI_WaitFifoStateUntilTimeout.constprop.11+0x2a>
      }
    }
  }

  return HAL_OK;
}
 8001f14:	b003      	add	sp, #12
 8001f16:	bdf0      	pop	{r4, r5, r6, r7, pc}

08001f18 <SPI_EndRxTxTransaction>:
  * @param  Timeout: Timeout duration
  * @param  Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8001f18:	b570      	push	{r4, r5, r6, lr}
  /* Control if the TX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001f1a:	4613      	mov	r3, r2
  * @param  Timeout: Timeout duration
  * @param  Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8001f1c:	460d      	mov	r5, r1
 8001f1e:	4616      	mov	r6, r2
  /* Control if the TX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001f20:	460a      	mov	r2, r1
 8001f22:	f44f 51c0 	mov.w	r1, #6144	; 0x1800
  * @param  Timeout: Timeout duration
  * @param  Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8001f26:	4604      	mov	r4, r0
  /* Control if the TX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001f28:	f7ff ffd5 	bl	8001ed6 <SPI_WaitFifoStateUntilTimeout.constprop.11>
 8001f2c:	b968      	cbnz	r0, 8001f4a <SPI_EndRxTxTransaction+0x32>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }
  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8001f2e:	4632      	mov	r2, r6
 8001f30:	4629      	mov	r1, r5
 8001f32:	4620      	mov	r0, r4
 8001f34:	f7ff ffb6 	bl	8001ea4 <SPI_WaitFlagStateUntilTimeout.constprop.10>
 8001f38:	b938      	cbnz	r0, 8001f4a <SPI_EndRxTxTransaction+0x32>

  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
  {
    /* Empty the FRLVL fifo */
    if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001f3a:	4633      	mov	r3, r6
 8001f3c:	462a      	mov	r2, r5
 8001f3e:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 8001f42:	4620      	mov	r0, r4
 8001f44:	f7ff ffc7 	bl	8001ed6 <SPI_WaitFifoStateUntilTimeout.constprop.11>
 8001f48:	b120      	cbz	r0, 8001f54 <SPI_EndRxTxTransaction+0x3c>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8001f4a:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8001f4c:	f043 0320 	orr.w	r3, r3, #32
 8001f50:	6623      	str	r3, [r4, #96]	; 0x60
      return HAL_TIMEOUT;
 8001f52:	2003      	movs	r0, #3
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }
  return HAL_OK;
}
 8001f54:	bd70      	pop	{r4, r5, r6, pc}

08001f56 <HAL_SPI_Init>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8001f56:	b570      	push	{r4, r5, r6, lr}
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 8001f58:	4604      	mov	r4, r0
 8001f5a:	2800      	cmp	r0, #0
 8001f5c:	d04b      	beq.n	8001ff6 <HAL_SPI_Init+0xa0>
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8001f5e:	2300      	movs	r3, #0
 8001f60:	6283      	str	r3, [r0, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 8001f62:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
 8001f66:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001f6a:	b91b      	cbnz	r3, 8001f74 <HAL_SPI_Init+0x1e>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 8001f6c:	f880 205c 	strb.w	r2, [r0, #92]	; 0x5c

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 8001f70:	f001 fd98 	bl	8003aa4 <HAL_SPI_MspInit>
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8001f74:	2302      	movs	r3, #2

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001f76:	6820      	ldr	r0, [r4, #0]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8001f78:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001f7c:	6803      	ldr	r3, [r0, #0]

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001f7e:	68e2      	ldr	r2, [r4, #12]
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001f80:	f023 0340 	bic.w	r3, r3, #64	; 0x40

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001f84:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001f88:	6003      	str	r3, [r0, #0]
 8001f8a:	f04f 0300 	mov.w	r3, #0

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001f8e:	d903      	bls.n	8001f98 <HAL_SPI_Init+0x42>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8001f90:	4619      	mov	r1, r3
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8001f92:	f5b2 6f70 	cmp.w	r2, #3840	; 0xf00
 8001f96:	e001      	b.n	8001f9c <HAL_SPI_Init+0x46>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
  }
  else
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 8001f98:	f44f 5180 	mov.w	r1, #4096	; 0x1000

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8001f9c:	bf18      	it	ne
 8001f9e:	62a3      	strne	r3, [r4, #40]	; 0x28
  }

  /* Align the CRC Length on the data size */
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8001fa0:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001fa2:	b92b      	cbnz	r3, 8001fb0 <HAL_SPI_Init+0x5a>
  {
    /* CRC Length aligned on the data size : value set by default */
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001fa4:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 8001fa8:	bf8c      	ite	hi
 8001faa:	2302      	movhi	r3, #2
    }
    else
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 8001fac:	2301      	movls	r3, #1
 8001fae:	6323      	str	r3, [r4, #48]	; 0x30
  }

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8001fb0:	68a5      	ldr	r5, [r4, #8]
 8001fb2:	6866      	ldr	r6, [r4, #4]
 8001fb4:	69a3      	ldr	r3, [r4, #24]
 8001fb6:	432e      	orrs	r6, r5
 8001fb8:	6925      	ldr	r5, [r4, #16]
 8001fba:	432e      	orrs	r6, r5
 8001fbc:	6965      	ldr	r5, [r4, #20]
 8001fbe:	432e      	orrs	r6, r5
 8001fc0:	69e5      	ldr	r5, [r4, #28]
 8001fc2:	432e      	orrs	r6, r5
 8001fc4:	6a25      	ldr	r5, [r4, #32]
 8001fc6:	432e      	orrs	r6, r5
 8001fc8:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 8001fca:	432e      	orrs	r6, r5
 8001fcc:	f403 7500 	and.w	r5, r3, #512	; 0x200
 8001fd0:	4335      	orrs	r5, r6
 8001fd2:	6005      	str	r5, [r0, #0]
    hspi->Instance->CR1 |= SPI_CR1_CRCL;
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo Threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8001fd4:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8001fd6:	432a      	orrs	r2, r5
 8001fd8:	6b65      	ldr	r5, [r4, #52]	; 0x34
 8001fda:	0c1b      	lsrs	r3, r3, #16
 8001fdc:	4315      	orrs	r5, r2
 8001fde:	f003 0204 	and.w	r2, r3, #4
 8001fe2:	ea45 0302 	orr.w	r3, r5, r2
 8001fe6:	430b      	orrs	r3, r1
 8001fe8:	6043      	str	r3, [r0, #4]
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8001fea:	2000      	movs	r0, #0
  hspi->State     = HAL_SPI_STATE_READY;
 8001fec:	2301      	movs	r3, #1
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8001fee:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 8001ff0:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d

  return HAL_OK;
 8001ff4:	bd70      	pop	{r4, r5, r6, pc}
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
  {
    return HAL_ERROR;
 8001ff6:	2001      	movs	r0, #1

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  hspi->State     = HAL_SPI_STATE_READY;

  return HAL_OK;
}
 8001ff8:	bd70      	pop	{r4, r5, r6, pc}

08001ffa <HAL_SPI_Transmit>:
  * @param  Size: amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8001ffa:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8001ffe:	461e      	mov	r6, r3

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8002000:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
 8002004:	2b01      	cmp	r3, #1
  * @param  Size: amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8002006:	4604      	mov	r4, r0
 8002008:	460d      	mov	r5, r1
 800200a:	4690      	mov	r8, r2

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 800200c:	f000 80b1 	beq.w	8002172 <HAL_SPI_Transmit+0x178>
 8002010:	2301      	movs	r3, #1
 8002012:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8002016:	f7fe ff61 	bl	8000edc <HAL_GetTick>
 800201a:	4607      	mov	r7, r0

  if (hspi->State != HAL_SPI_STATE_READY)
 800201c:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
 8002020:	b2c0      	uxtb	r0, r0
 8002022:	2801      	cmp	r0, #1
 8002024:	f040 809d 	bne.w	8002162 <HAL_SPI_Transmit+0x168>
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if ((pData == NULL) || (Size == 0U))
 8002028:	2d00      	cmp	r5, #0
 800202a:	f000 809b 	beq.w	8002164 <HAL_SPI_Transmit+0x16a>
 800202e:	f1b8 0f00 	cmp.w	r8, #0
 8002032:	f000 8097 	beq.w	8002164 <HAL_SPI_Transmit+0x16a>
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8002036:	2303      	movs	r3, #3
 8002038:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800203c:	2300      	movs	r3, #0
 800203e:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8002040:	6423      	str	r3, [r4, #64]	; 0x40
  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;
 8002042:	f8a4 803e 	strh.w	r8, [r4, #62]	; 0x3e

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
  hspi->RxXferSize  = 0U;
 8002046:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
  hspi->RxXferCount = 0U;
 800204a:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
  hspi->TxISR       = NULL;
 800204e:	6523      	str	r3, [r4, #80]	; 0x50
  hspi->RxISR       = NULL;
 8002050:	64e3      	str	r3, [r4, #76]	; 0x4c

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002052:	68a3      	ldr	r3, [r4, #8]
 8002054:	6820      	ldr	r0, [r4, #0]
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8002056:	63a5      	str	r5, [r4, #56]	; 0x38
  hspi->RxXferCount = 0U;
  hspi->TxISR       = NULL;
  hspi->RxISR       = NULL;

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002058:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  {
    SPI_1LINE_TX(hspi);
 800205c:	bf08      	it	eq
 800205e:	6803      	ldreq	r3, [r0, #0]

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
 8002060:	f8a4 803c 	strh.w	r8, [r4, #60]	; 0x3c
  hspi->RxISR       = NULL;

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_TX(hspi);
 8002064:	bf04      	itt	eq
 8002066:	f443 4380 	orreq.w	r3, r3, #16384	; 0x4000
 800206a:	6003      	streq	r3, [r0, #0]
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 800206c:	6803      	ldr	r3, [r0, #0]
 800206e:	065b      	lsls	r3, r3, #25
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 8002070:	bf5e      	ittt	pl
 8002072:	6803      	ldrpl	r3, [r0, #0]
 8002074:	f043 0340 	orrpl.w	r3, r3, #64	; 0x40
 8002078:	6003      	strpl	r3, [r0, #0]
  }

  /* Transmit data in 16 Bit mode */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800207a:	68e3      	ldr	r3, [r4, #12]
 800207c:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8002080:	6863      	ldr	r3, [r4, #4]
 8002082:	d921      	bls.n	80020c8 <HAL_SPI_Transmit+0xce>
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
 8002084:	b11b      	cbz	r3, 800208e <HAL_SPI_Transmit+0x94>
 8002086:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002088:	b29b      	uxth	r3, r3
 800208a:	2b01      	cmp	r3, #1
 800208c:	d10a      	bne.n	80020a4 <HAL_SPI_Transmit+0xaa>
    {
      hspi->Instance->DR = *((uint16_t *)pData);
 800208e:	f835 3b02 	ldrh.w	r3, [r5], #2
 8002092:	60c3      	str	r3, [r0, #12]
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
      {
        hspi->Instance->DR = *((uint16_t *)pData);
        pData += sizeof(uint16_t);
        hspi->TxXferCount--;
 8002094:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002096:	3b01      	subs	r3, #1
 8002098:	b29b      	uxth	r3, r3
 800209a:	87e3      	strh	r3, [r4, #62]	; 0x3e
 800209c:	e002      	b.n	80020a4 <HAL_SPI_Transmit+0xaa>
      }
      else
      {
        /* Timeout management */
        if ((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout)))
 800209e:	b18e      	cbz	r6, 80020c4 <HAL_SPI_Transmit+0xca>
 80020a0:	1c71      	adds	r1, r6, #1
 80020a2:	d10a      	bne.n	80020ba <HAL_SPI_Transmit+0xc0>
      hspi->Instance->DR = *((uint16_t *)pData);
      pData += sizeof(uint16_t);
      hspi->TxXferCount--;
    }
    /* Transmit data in 16 Bit mode */
    while (hspi->TxXferCount > 0U)
 80020a4:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80020a6:	b29b      	uxth	r3, r3
 80020a8:	b1b3      	cbz	r3, 80020d8 <HAL_SPI_Transmit+0xde>
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 80020aa:	6823      	ldr	r3, [r4, #0]
 80020ac:	689a      	ldr	r2, [r3, #8]
 80020ae:	0790      	lsls	r0, r2, #30
 80020b0:	d5f5      	bpl.n	800209e <HAL_SPI_Transmit+0xa4>
      {
        hspi->Instance->DR = *((uint16_t *)pData);
 80020b2:	f835 2b02 	ldrh.w	r2, [r5], #2
 80020b6:	60da      	str	r2, [r3, #12]
 80020b8:	e7ec      	b.n	8002094 <HAL_SPI_Transmit+0x9a>
        hspi->TxXferCount--;
      }
      else
      {
        /* Timeout management */
        if ((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout)))
 80020ba:	f7fe ff0f 	bl	8000edc <HAL_GetTick>
 80020be:	1bc0      	subs	r0, r0, r7
 80020c0:	4286      	cmp	r6, r0
 80020c2:	d8ef      	bhi.n	80020a4 <HAL_SPI_Transmit+0xaa>
        {
          errorcode = HAL_TIMEOUT;
 80020c4:	2003      	movs	r0, #3
 80020c6:	e04d      	b.n	8002164 <HAL_SPI_Transmit+0x16a>
    }
  }
  /* Transmit data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
 80020c8:	b183      	cbz	r3, 80020ec <HAL_SPI_Transmit+0xf2>
 80020ca:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80020cc:	b29b      	uxth	r3, r3
 80020ce:	2b01      	cmp	r3, #1
 80020d0:	d00c      	beq.n	80020ec <HAL_SPI_Transmit+0xf2>
      {
        *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
        hspi->TxXferCount--;
      }
    }
    while (hspi->TxXferCount > 0U)
 80020d2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80020d4:	b29b      	uxth	r3, r3
 80020d6:	b9a3      	cbnz	r3, 8002102 <HAL_SPI_Transmit+0x108>
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 80020d8:	463a      	mov	r2, r7
 80020da:	4631      	mov	r1, r6
 80020dc:	4620      	mov	r0, r4
 80020de:	f7ff ff1b 	bl	8001f18 <SPI_EndRxTxTransaction>
 80020e2:	2800      	cmp	r0, #0
 80020e4:	d02f      	beq.n	8002146 <HAL_SPI_Transmit+0x14c>
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 80020e6:	2320      	movs	r3, #32
 80020e8:	6623      	str	r3, [r4, #96]	; 0x60
 80020ea:	e02c      	b.n	8002146 <HAL_SPI_Transmit+0x14c>
  /* Transmit data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
    {
      if (hspi->TxXferCount > 1U)
 80020ec:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80020ee:	b29b      	uxth	r3, r3
 80020f0:	2b01      	cmp	r3, #1
 80020f2:	d903      	bls.n	80020fc <HAL_SPI_Transmit+0x102>
      {
        /* write on the data register in packing mode */
        hspi->Instance->DR = *((uint16_t *)pData);
 80020f4:	f835 3b02 	ldrh.w	r3, [r5], #2
 80020f8:	60c3      	str	r3, [r0, #12]
 80020fa:	e00d      	b.n	8002118 <HAL_SPI_Transmit+0x11e>
        pData += sizeof(uint16_t);
        hspi->TxXferCount -= 2U;
      }
      else
      {
        *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
 80020fc:	782b      	ldrb	r3, [r5, #0]
 80020fe:	7303      	strb	r3, [r0, #12]
 8002100:	e011      	b.n	8002126 <HAL_SPI_Transmit+0x12c>
      }
    }
    while (hspi->TxXferCount > 0U)
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002102:	6823      	ldr	r3, [r4, #0]
 8002104:	689a      	ldr	r2, [r3, #8]
 8002106:	0792      	lsls	r2, r2, #30
 8002108:	d513      	bpl.n	8002132 <HAL_SPI_Transmit+0x138>
      {
        if (hspi->TxXferCount > 1U)
 800210a:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 800210c:	b292      	uxth	r2, r2
 800210e:	2a01      	cmp	r2, #1
 8002110:	d907      	bls.n	8002122 <HAL_SPI_Transmit+0x128>
        {
          /* write on the data register in packing mode */
          hspi->Instance->DR = *((uint16_t *)pData);
 8002112:	f835 2b02 	ldrh.w	r2, [r5], #2
 8002116:	60da      	str	r2, [r3, #12]
          pData += sizeof(uint16_t);
          hspi->TxXferCount -= 2U;
 8002118:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800211a:	3b02      	subs	r3, #2
 800211c:	b29b      	uxth	r3, r3
 800211e:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8002120:	e7d7      	b.n	80020d2 <HAL_SPI_Transmit+0xd8>
        }
        else
        {
          *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
 8002122:	782a      	ldrb	r2, [r5, #0]
 8002124:	731a      	strb	r2, [r3, #12]
          hspi->TxXferCount--;
 8002126:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002128:	3b01      	subs	r3, #1
 800212a:	b29b      	uxth	r3, r3
 800212c:	87e3      	strh	r3, [r4, #62]	; 0x3e
          pData += sizeof(uint16_t);
          hspi->TxXferCount -= 2U;
        }
        else
        {
          *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
 800212e:	3501      	adds	r5, #1
 8002130:	e7cf      	b.n	80020d2 <HAL_SPI_Transmit+0xd8>
        }
      }
      else
      {
        /* Timeout management */
        if ((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout)))
 8002132:	2e00      	cmp	r6, #0
 8002134:	d0c6      	beq.n	80020c4 <HAL_SPI_Transmit+0xca>
 8002136:	1c73      	adds	r3, r6, #1
 8002138:	d0cb      	beq.n	80020d2 <HAL_SPI_Transmit+0xd8>
 800213a:	f7fe fecf 	bl	8000edc <HAL_GetTick>
 800213e:	1bc0      	subs	r0, r0, r7
 8002140:	4286      	cmp	r6, r0
 8002142:	d8c6      	bhi.n	80020d2 <HAL_SPI_Transmit+0xd8>
 8002144:	e7be      	b.n	80020c4 <HAL_SPI_Transmit+0xca>
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8002146:	68a3      	ldr	r3, [r4, #8]
 8002148:	b933      	cbnz	r3, 8002158 <HAL_SPI_Transmit+0x15e>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800214a:	9301      	str	r3, [sp, #4]
 800214c:	6823      	ldr	r3, [r4, #0]
 800214e:	68da      	ldr	r2, [r3, #12]
 8002150:	9201      	str	r2, [sp, #4]
 8002152:	689b      	ldr	r3, [r3, #8]
 8002154:	9301      	str	r3, [sp, #4]
 8002156:	9b01      	ldr	r3, [sp, #4]
  }

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8002158:	6e20      	ldr	r0, [r4, #96]	; 0x60
  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();

  if (hspi->State != HAL_SPI_STATE_READY)
  {
    errorcode = HAL_BUSY;
 800215a:	3000      	adds	r0, #0
 800215c:	bf18      	it	ne
 800215e:	2001      	movne	r0, #1
 8002160:	e000      	b.n	8002164 <HAL_SPI_Transmit+0x16a>
 8002162:	2002      	movs	r0, #2
  {
    errorcode = HAL_ERROR;
  }

error:
  hspi->State = HAL_SPI_STATE_READY;
 8002164:	2301      	movs	r3, #1
 8002166:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 800216a:	2300      	movs	r3, #0
 800216c:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  return errorcode;
 8002170:	e000      	b.n	8002174 <HAL_SPI_Transmit+0x17a>

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8002172:	2002      	movs	r0, #2
error:
  hspi->State = HAL_SPI_STATE_READY;
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 8002174:	b002      	add	sp, #8
 8002176:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

0800217c <TIM_OC1_SetConfig>:
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

   /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800217c:	6a03      	ldr	r3, [r0, #32]
 800217e:	f023 0301 	bic.w	r3, r3, #1
 8002182:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8002184:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8002186:	6842      	ldr	r2, [r0, #4]
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The ouput configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8002188:	b570      	push	{r4, r5, r6, lr}
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800218a:	6984      	ldr	r4, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800218c:	680d      	ldr	r5, [r1, #0]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800218e:	f424 3480 	bic.w	r4, r4, #65536	; 0x10000
 8002192:	f024 0473 	bic.w	r4, r4, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8002196:	432c      	orrs	r4, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8002198:	688d      	ldr	r5, [r1, #8]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 800219a:	f023 0302 	bic.w	r3, r3, #2
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 800219e:	432b      	orrs	r3, r5

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 80021a0:	4d12      	ldr	r5, [pc, #72]	; (80021ec <TIM_OC1_SetConfig+0x70>)
 80021a2:	42a8      	cmp	r0, r5
 80021a4:	d006      	beq.n	80021b4 <TIM_OC1_SetConfig+0x38>
 80021a6:	4e12      	ldr	r6, [pc, #72]	; (80021f0 <TIM_OC1_SetConfig+0x74>)
 80021a8:	42b0      	cmp	r0, r6
 80021aa:	d003      	beq.n	80021b4 <TIM_OC1_SetConfig+0x38>
 80021ac:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 80021b0:	42b0      	cmp	r0, r6
 80021b2:	d114      	bne.n	80021de <TIM_OC1_SetConfig+0x62>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 80021b4:	68ce      	ldr	r6, [r1, #12]
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 80021b6:	f023 0308 	bic.w	r3, r3, #8
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 80021ba:	4333      	orrs	r3, r6
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
  }

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 80021bc:	42a8      	cmp	r0, r5
    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 80021be:	f023 0304 	bic.w	r3, r3, #4
  }

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 80021c2:	d006      	beq.n	80021d2 <TIM_OC1_SetConfig+0x56>
 80021c4:	4d0a      	ldr	r5, [pc, #40]	; (80021f0 <TIM_OC1_SetConfig+0x74>)
 80021c6:	42a8      	cmp	r0, r5
 80021c8:	d003      	beq.n	80021d2 <TIM_OC1_SetConfig+0x56>
 80021ca:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80021ce:	42a8      	cmp	r0, r5
 80021d0:	d105      	bne.n	80021de <TIM_OC1_SetConfig+0x62>
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 80021d2:	694e      	ldr	r6, [r1, #20]
 80021d4:	698d      	ldr	r5, [r1, #24]
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
 80021d6:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 80021da:	4335      	orrs	r5, r6
 80021dc:	432a      	orrs	r2, r5
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80021de:	6042      	str	r2, [r0, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 80021e0:	684a      	ldr	r2, [r1, #4]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 80021e2:	6184      	str	r4, [r0, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 80021e4:	6342      	str	r2, [r0, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80021e6:	6203      	str	r3, [r0, #32]
 80021e8:	bd70      	pop	{r4, r5, r6, pc}
 80021ea:	bf00      	nop
 80021ec:	40012c00 	.word	0x40012c00
 80021f0:	40014000 	.word	0x40014000

080021f4 <TIM_OC3_SetConfig>:
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 80021f4:	6a03      	ldr	r3, [r0, #32]
 80021f6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80021fa:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80021fc:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80021fe:	6842      	ldr	r2, [r0, #4]
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The ouput configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8002200:	b530      	push	{r4, r5, lr}
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8002202:	69c4      	ldr	r4, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8002204:	680d      	ldr	r5, [r1, #0]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8002206:	f424 3480 	bic.w	r4, r4, #65536	; 0x10000
 800220a:	f024 0473 	bic.w	r4, r4, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800220e:	432c      	orrs	r4, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8);
 8002210:	688d      	ldr	r5, [r1, #8]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 8002212:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8);
 8002216:	ea43 2305 	orr.w	r3, r3, r5, lsl #8

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 800221a:	4d0f      	ldr	r5, [pc, #60]	; (8002258 <TIM_OC3_SetConfig+0x64>)
 800221c:	42a8      	cmp	r0, r5
 800221e:	d107      	bne.n	8002230 <TIM_OC3_SetConfig+0x3c>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8);
 8002220:	68cd      	ldr	r5, [r1, #12]
  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 8002222:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8);
 8002226:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 800222a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800222e:	e005      	b.n	800223c <TIM_OC3_SetConfig+0x48>
  }

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8002230:	4d0a      	ldr	r5, [pc, #40]	; (800225c <TIM_OC3_SetConfig+0x68>)
 8002232:	42a8      	cmp	r0, r5
 8002234:	d002      	beq.n	800223c <TIM_OC3_SetConfig+0x48>
 8002236:	4d0a      	ldr	r5, [pc, #40]	; (8002260 <TIM_OC3_SetConfig+0x6c>)
 8002238:	42a8      	cmp	r0, r5
 800223a:	d107      	bne.n	800224c <TIM_OC3_SetConfig+0x58>

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4);
 800223c:	694d      	ldr	r5, [r1, #20]
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
 800223e:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4);
 8002242:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4);
 8002246:	698d      	ldr	r5, [r1, #24]
 8002248:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800224c:	6042      	str	r2, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 800224e:	684a      	ldr	r2, [r1, #4]

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8002250:	61c4      	str	r4, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8002252:	63c2      	str	r2, [r0, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8002254:	6203      	str	r3, [r0, #32]
}
 8002256:	bd30      	pop	{r4, r5, pc}
 8002258:	40012c00 	.word	0x40012c00
 800225c:	40014000 	.word	0x40014000
 8002260:	40014400 	.word	0x40014400

08002264 <TIM_OC4_SetConfig>:
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8002264:	6a03      	ldr	r3, [r0, #32]
 8002266:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800226a:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800226c:	6a02      	ldr	r2, [r0, #32]
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The ouput configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800226e:	b530      	push	{r4, r5, lr}
  TIMx->CCER &= ~TIM_CCER_CC4E;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8002270:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8002272:	69c3      	ldr	r3, [r0, #28]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 8002274:	680d      	ldr	r5, [r1, #0]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8002276:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800227a:	f423 43e6 	bic.w	r3, r3, #29440	; 0x7300

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 800227e:	ea43 2305 	orr.w	r3, r3, r5, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12);
 8002282:	688d      	ldr	r5, [r1, #8]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8002284:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12);
 8002288:	ea42 3205 	orr.w	r2, r2, r5, lsl #12

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 800228c:	4d0a      	ldr	r5, [pc, #40]	; (80022b8 <TIM_OC4_SetConfig+0x54>)
 800228e:	42a8      	cmp	r0, r5
 8002290:	d007      	beq.n	80022a2 <TIM_OC4_SetConfig+0x3e>
 8002292:	f505 55a0 	add.w	r5, r5, #5120	; 0x1400
 8002296:	42a8      	cmp	r0, r5
 8002298:	d003      	beq.n	80022a2 <TIM_OC4_SetConfig+0x3e>
 800229a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800229e:	42a8      	cmp	r0, r5
 80022a0:	d104      	bne.n	80022ac <TIM_OC4_SetConfig+0x48>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

   /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6);
 80022a2:	694d      	ldr	r5, [r1, #20]
  if(IS_TIM_BREAK_INSTANCE(TIMx))
  {
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

   /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 80022a4:	f424 4480 	bic.w	r4, r4, #16384	; 0x4000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6);
 80022a8:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80022ac:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 80022ae:	61c3      	str	r3, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 80022b0:	684b      	ldr	r3, [r1, #4]
 80022b2:	6403      	str	r3, [r0, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80022b4:	6202      	str	r2, [r0, #32]
 80022b6:	bd30      	pop	{r4, r5, pc}
 80022b8:	40012c00 	.word	0x40012c00

080022bc <TIM_OC5_SetConfig>:
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 80022bc:	6a03      	ldr	r3, [r0, #32]
 80022be:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80022c2:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80022c4:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80022c6:	6842      	ldr	r2, [r0, #4]
  * @param  OC_Config: The ouput configuration structure
  * @retval None
  */
static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 80022c8:	b530      	push	{r4, r5, lr}
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 80022ca:	6d44      	ldr	r4, [r0, #84]	; 0x54

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 80022cc:	680d      	ldr	r5, [r1, #0]
  tmpcr2 =  TIMx->CR2;
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 80022ce:	f424 3480 	bic.w	r4, r4, #65536	; 0x10000
 80022d2:	f024 0470 	bic.w	r4, r4, #112	; 0x70
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 80022d6:	432c      	orrs	r4, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16);
 80022d8:	688d      	ldr	r5, [r1, #8]
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
 80022da:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16);
 80022de:	ea43 4305 	orr.w	r3, r3, r5, lsl #16

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 80022e2:	4d0b      	ldr	r5, [pc, #44]	; (8002310 <TIM_OC5_SetConfig+0x54>)
 80022e4:	42a8      	cmp	r0, r5
 80022e6:	d007      	beq.n	80022f8 <TIM_OC5_SetConfig+0x3c>
 80022e8:	f505 55a0 	add.w	r5, r5, #5120	; 0x1400
 80022ec:	42a8      	cmp	r0, r5
 80022ee:	d003      	beq.n	80022f8 <TIM_OC5_SetConfig+0x3c>
 80022f0:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80022f4:	42a8      	cmp	r0, r5
 80022f6:	d104      	bne.n	8002302 <TIM_OC5_SetConfig+0x46>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8);
 80022f8:	694d      	ldr	r5, [r1, #20]
  tmpccer |= (OC_Config->OCPolarity << 16);

  if(IS_TIM_BREAK_INSTANCE(TIMx))
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
 80022fa:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8);
 80022fe:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8002302:	6042      	str	r2, [r0, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 8002304:	684a      	ldr	r2, [r1, #4]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 8002306:	6544      	str	r4, [r0, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 8002308:	6582      	str	r2, [r0, #88]	; 0x58

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800230a:	6203      	str	r3, [r0, #32]
 800230c:	bd30      	pop	{r4, r5, pc}
 800230e:	bf00      	nop
 8002310:	40012c00 	.word	0x40012c00

08002314 <TIM_OC6_SetConfig>:
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 8002314:	6a03      	ldr	r3, [r0, #32]
 8002316:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 800231a:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800231c:	6a02      	ldr	r2, [r0, #32]
  * @param  OC_Config: The ouput configuration structure
  * @retval None
  */
static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 800231e:	b530      	push	{r4, r5, lr}
  TIMx->CCER &= ~TIM_CCER_CC6E;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8002320:	6844      	ldr	r4, [r0, #4]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 8002322:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 8002324:	680d      	ldr	r5, [r1, #0]
  tmpcr2 =  TIMx->CR2;
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 8002326:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800232a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 800232e:	ea43 2305 	orr.w	r3, r3, r5, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20);
 8002332:	688d      	ldr	r5, [r1, #8]
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 8002334:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20);
 8002338:	ea42 5205 	orr.w	r2, r2, r5, lsl #20

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 800233c:	4d0a      	ldr	r5, [pc, #40]	; (8002368 <TIM_OC6_SetConfig+0x54>)
 800233e:	42a8      	cmp	r0, r5
 8002340:	d007      	beq.n	8002352 <TIM_OC6_SetConfig+0x3e>
 8002342:	f505 55a0 	add.w	r5, r5, #5120	; 0x1400
 8002346:	42a8      	cmp	r0, r5
 8002348:	d003      	beq.n	8002352 <TIM_OC6_SetConfig+0x3e>
 800234a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800234e:	42a8      	cmp	r0, r5
 8002350:	d104      	bne.n	800235c <TIM_OC6_SetConfig+0x48>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10);
 8002352:	694d      	ldr	r5, [r1, #20]
  tmpccer |= (OC_Config->OCPolarity << 20);

  if(IS_TIM_BREAK_INSTANCE(TIMx))
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
 8002354:	f424 2480 	bic.w	r4, r4, #262144	; 0x40000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10);
 8002358:	ea44 2485 	orr.w	r4, r4, r5, lsl #10
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800235c:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 800235e:	6543      	str	r3, [r0, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 8002360:	684b      	ldr	r3, [r1, #4]
 8002362:	65c3      	str	r3, [r0, #92]	; 0x5c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8002364:	6202      	str	r2, [r0, #32]
 8002366:	bd30      	pop	{r4, r5, pc}
 8002368:	40012c00 	.word	0x40012c00

0800236c <TIM_Base_SetConfig>:
{
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800236c:	4a18      	ldr	r2, [pc, #96]	; (80023d0 <TIM_Base_SetConfig+0x64>)
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;
 800236e:	6803      	ldr	r3, [r0, #0]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002370:	4290      	cmp	r0, r2
  * @param  TIMx: TIM peripheral
  * @param  Structure: TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 8002372:	b510      	push	{r4, lr}
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002374:	d002      	beq.n	800237c <TIM_Base_SetConfig+0x10>
 8002376:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 800237a:	d109      	bne.n	8002390 <TIM_Base_SetConfig+0x24>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
 800237c:	684c      	ldr	r4, [r1, #4]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800237e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
  }

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8002382:	4290      	cmp	r0, r2
  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
 8002384:	ea43 0304 	orr.w	r3, r3, r4
  }

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8002388:	d009      	beq.n	800239e <TIM_Base_SetConfig+0x32>
 800238a:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 800238e:	d006      	beq.n	800239e <TIM_Base_SetConfig+0x32>
 8002390:	4a10      	ldr	r2, [pc, #64]	; (80023d4 <TIM_Base_SetConfig+0x68>)
 8002392:	4290      	cmp	r0, r2
 8002394:	d003      	beq.n	800239e <TIM_Base_SetConfig+0x32>
 8002396:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800239a:	4290      	cmp	r0, r2
 800239c:	d103      	bne.n	80023a6 <TIM_Base_SetConfig+0x3a>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800239e:	68ca      	ldr	r2, [r1, #12]
  }

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 80023a0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80023a4:	4313      	orrs	r3, r2
  }

  TIMx->CR1 = tmpcr1;
 80023a6:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 80023a8:	688b      	ldr	r3, [r1, #8]
 80023aa:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 80023ac:	680b      	ldr	r3, [r1, #0]
 80023ae:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 80023b0:	4b07      	ldr	r3, [pc, #28]	; (80023d0 <TIM_Base_SetConfig+0x64>)
 80023b2:	4298      	cmp	r0, r3
 80023b4:	d007      	beq.n	80023c6 <TIM_Base_SetConfig+0x5a>
 80023b6:	f503 53a0 	add.w	r3, r3, #5120	; 0x1400
 80023ba:	4298      	cmp	r0, r3
 80023bc:	d003      	beq.n	80023c6 <TIM_Base_SetConfig+0x5a>
 80023be:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80023c2:	4298      	cmp	r0, r3
 80023c4:	d101      	bne.n	80023ca <TIM_Base_SetConfig+0x5e>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 80023c6:	690b      	ldr	r3, [r1, #16]
 80023c8:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter(only for TIM1 and TIM8) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 80023ca:	2301      	movs	r3, #1
 80023cc:	6143      	str	r3, [r0, #20]
 80023ce:	bd10      	pop	{r4, pc}
 80023d0:	40012c00 	.word	0x40012c00
 80023d4:	40014000 	.word	0x40014000

080023d8 <HAL_TIM_PWM_Init>:
  *         parameters in the TIM_HandleTypeDef and initialize the associated handle.
  * @param  htim: TIM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
 80023d8:	b510      	push	{r4, lr}
  /* Check the TIM handle allocation */
  if(htim == NULL)
 80023da:	4604      	mov	r4, r0
 80023dc:	b1a0      	cbz	r0, 8002408 <HAL_TIM_PWM_Init+0x30>
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));

  if(htim->State == HAL_TIM_STATE_RESET)
 80023de:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 80023e2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80023e6:	b91b      	cbnz	r3, 80023f0 <HAL_TIM_PWM_Init+0x18>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 80023e8:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38

    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
 80023ec:	f001 fb80 	bl	8003af0 <HAL_TIM_PWM_MspInit>
  }

  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;
 80023f0:	2302      	movs	r3, #2
 80023f2:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  /* Init the base time for the PWM */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80023f6:	6820      	ldr	r0, [r4, #0]
 80023f8:	1d21      	adds	r1, r4, #4
 80023fa:	f7ff ffb7 	bl	800236c <TIM_Base_SetConfig>

  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 80023fe:	2301      	movs	r3, #1
 8002400:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  return HAL_OK;
 8002404:	2000      	movs	r0, #0
 8002406:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if(htim == NULL)
  {
    return HAL_ERROR;
 8002408:	2001      	movs	r0, #1

  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;

  return HAL_OK;
}
 800240a:	bd10      	pop	{r4, pc}

0800240c <TIM_OC2_SetConfig>:
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800240c:	6a03      	ldr	r3, [r0, #32]
 800240e:	f023 0310 	bic.w	r3, r3, #16
 8002412:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8002414:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8002416:	6842      	ldr	r2, [r0, #4]
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The ouput configuration structure
  * @retval None
  */
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8002418:	b530      	push	{r4, r5, lr}
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800241a:	6984      	ldr	r4, [r0, #24]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
  tmpccmrx &= ~TIM_CCMR1_CC2S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 800241c:	680d      	ldr	r5, [r1, #0]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 800241e:	f024 7480 	bic.w	r4, r4, #16777216	; 0x1000000
 8002422:	f424 44e6 	bic.w	r4, r4, #29440	; 0x7300

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 8002426:	ea44 2405 	orr.w	r4, r4, r5, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4);
 800242a:	688d      	ldr	r5, [r1, #8]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 800242c:	f023 0320 	bic.w	r3, r3, #32
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4);
 8002430:	ea43 1305 	orr.w	r3, r3, r5, lsl #4

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8002434:	4d0f      	ldr	r5, [pc, #60]	; (8002474 <TIM_OC2_SetConfig+0x68>)
 8002436:	42a8      	cmp	r0, r5
 8002438:	d107      	bne.n	800244a <TIM_OC2_SetConfig+0x3e>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4);
 800243a:	68cd      	ldr	r5, [r1, #12]
  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
 800243c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4);
 8002440:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;
 8002444:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002448:	e005      	b.n	8002456 <TIM_OC2_SetConfig+0x4a>

  }

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 800244a:	4d0b      	ldr	r5, [pc, #44]	; (8002478 <TIM_OC2_SetConfig+0x6c>)
 800244c:	42a8      	cmp	r0, r5
 800244e:	d002      	beq.n	8002456 <TIM_OC2_SetConfig+0x4a>
 8002450:	4d0a      	ldr	r5, [pc, #40]	; (800247c <TIM_OC2_SetConfig+0x70>)
 8002452:	42a8      	cmp	r0, r5
 8002454:	d107      	bne.n	8002466 <TIM_OC2_SetConfig+0x5a>

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
    tmpcr2 &= ~TIM_CR2_OIS2N;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2);
 8002456:	694d      	ldr	r5, [r1, #20]
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8002458:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2);
 800245c:	ea42 0285 	orr.w	r2, r2, r5, lsl #2
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2);
 8002460:	698d      	ldr	r5, [r1, #24]
 8002462:	ea42 0285 	orr.w	r2, r2, r5, lsl #2
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8002466:	6042      	str	r2, [r0, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 8002468:	684a      	ldr	r2, [r1, #4]

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800246a:	6184      	str	r4, [r0, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 800246c:	6382      	str	r2, [r0, #56]	; 0x38

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800246e:	6203      	str	r3, [r0, #32]
}
 8002470:	bd30      	pop	{r4, r5, pc}
 8002472:	bf00      	nop
 8002474:	40012c00 	.word	0x40012c00
 8002478:	40014000 	.word	0x40014000
 800247c:	40014400 	.word	0x40014400

08002480 <HAL_TIM_PWM_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
                                            TIM_OC_InitTypeDef* sConfig,
                                            uint32_t Channel)
{
 8002480:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  /* Process Locked */
  __HAL_LOCK(htim);
 8002482:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8002486:	2b01      	cmp	r3, #1
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
                                            TIM_OC_InitTypeDef* sConfig,
                                            uint32_t Channel)
{
 8002488:	4604      	mov	r4, r0
 800248a:	460d      	mov	r5, r1
 800248c:	f04f 0002 	mov.w	r0, #2
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  /* Process Locked */
  __HAL_LOCK(htim);
 8002490:	d07b      	beq.n	800258a <HAL_TIM_PWM_ConfigChannel+0x10a>
 8002492:	2301      	movs	r3, #1

  htim->State = HAL_TIM_STATE_BUSY;

  switch (Channel)
 8002494:	2a08      	cmp	r2, #8
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  /* Process Locked */
  __HAL_LOCK(htim);
 8002496:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38

  htim->State = HAL_TIM_STATE_BUSY;
 800249a:	f884 0039 	strb.w	r0, [r4, #57]	; 0x39

  switch (Channel)
 800249e:	d03c      	beq.n	800251a <HAL_TIM_PWM_ConfigChannel+0x9a>
 80024a0:	d813      	bhi.n	80024ca <HAL_TIM_PWM_ConfigChannel+0x4a>
 80024a2:	b34a      	cbz	r2, 80024f8 <HAL_TIM_PWM_ConfigChannel+0x78>
 80024a4:	2a04      	cmp	r2, #4
 80024a6:	d16a      	bne.n	800257e <HAL_TIM_PWM_ConfigChannel+0xfe>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 80024a8:	6820      	ldr	r0, [r4, #0]
 80024aa:	f7ff ffaf 	bl	800240c <TIM_OC2_SetConfig>

      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 80024ae:	6823      	ldr	r3, [r4, #0]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
 80024b0:	6909      	ldr	r1, [r1, #16]

      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);

      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 80024b2:	699a      	ldr	r2, [r3, #24]
 80024b4:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80024b8:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 80024ba:	699a      	ldr	r2, [r3, #24]
 80024bc:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80024c0:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
 80024c2:	699a      	ldr	r2, [r3, #24]
 80024c4:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80024c8:	e025      	b.n	8002516 <HAL_TIM_PWM_ConfigChannel+0x96>
  /* Process Locked */
  __HAL_LOCK(htim);

  htim->State = HAL_TIM_STATE_BUSY;

  switch (Channel)
 80024ca:	2a10      	cmp	r2, #16
 80024cc:	d036      	beq.n	800253c <HAL_TIM_PWM_ConfigChannel+0xbc>
 80024ce:	2a14      	cmp	r2, #20
 80024d0:	d044      	beq.n	800255c <HAL_TIM_PWM_ConfigChannel+0xdc>
 80024d2:	2a0c      	cmp	r2, #12
 80024d4:	d153      	bne.n	800257e <HAL_TIM_PWM_ConfigChannel+0xfe>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));

      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 80024d6:	6820      	ldr	r0, [r4, #0]
 80024d8:	f7ff fec4 	bl	8002264 <TIM_OC4_SetConfig>

      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 80024dc:	6823      	ldr	r3, [r4, #0]

     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;
 80024de:	6909      	ldr	r1, [r1, #16]

      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);

      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 80024e0:	69da      	ldr	r2, [r3, #28]
 80024e2:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80024e6:	61da      	str	r2, [r3, #28]

     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 80024e8:	69da      	ldr	r2, [r3, #28]
 80024ea:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80024ee:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;
 80024f0:	69da      	ldr	r2, [r3, #28]
 80024f2:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80024f6:	e01f      	b.n	8002538 <HAL_TIM_PWM_ConfigChannel+0xb8>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

      /* Configure the Channel 1 in PWM mode */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 80024f8:	6820      	ldr	r0, [r4, #0]
 80024fa:	f7ff fe3f 	bl	800217c <TIM_OC1_SetConfig>

      /* Set the Preload enable bit for channel1 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 80024fe:	6823      	ldr	r3, [r4, #0]
 8002500:	699a      	ldr	r2, [r3, #24]
 8002502:	f042 0208 	orr.w	r2, r2, #8
 8002506:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8002508:	699a      	ldr	r2, [r3, #24]
 800250a:	f022 0204 	bic.w	r2, r2, #4
 800250e:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8002510:	6999      	ldr	r1, [r3, #24]
 8002512:	692a      	ldr	r2, [r5, #16]
 8002514:	430a      	orrs	r2, r1
      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
 8002516:	619a      	str	r2, [r3, #24]
    }
    break;
 8002518:	e031      	b.n	800257e <HAL_TIM_PWM_ConfigChannel+0xfe>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));

      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 800251a:	6820      	ldr	r0, [r4, #0]
 800251c:	f7ff fe6a 	bl	80021f4 <TIM_OC3_SetConfig>

      /* Set the Preload enable bit for channel3 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8002520:	6823      	ldr	r3, [r4, #0]
 8002522:	69da      	ldr	r2, [r3, #28]
 8002524:	f042 0208 	orr.w	r2, r2, #8
 8002528:	61da      	str	r2, [r3, #28]

     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 800252a:	69da      	ldr	r2, [r3, #28]
 800252c:	f022 0204 	bic.w	r2, r2, #4
 8002530:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8002532:	69d9      	ldr	r1, [r3, #28]
 8002534:	692a      	ldr	r2, [r5, #16]
 8002536:	430a      	orrs	r2, r1
      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;

     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;
 8002538:	61da      	str	r2, [r3, #28]
    }
    break;
 800253a:	e020      	b.n	800257e <HAL_TIM_PWM_ConfigChannel+0xfe>
    {
       /* Check the parameters */
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));

     /* Configure the Channel 5 in PWM mode */
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 800253c:	6820      	ldr	r0, [r4, #0]
 800253e:	f7ff febd 	bl	80022bc <TIM_OC5_SetConfig>

      /* Set the Preload enable bit for channel5*/
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8002542:	6823      	ldr	r3, [r4, #0]
 8002544:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8002546:	f042 0208 	orr.w	r2, r2, #8
 800254a:	655a      	str	r2, [r3, #84]	; 0x54

     /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 800254c:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800254e:	f022 0204 	bic.w	r2, r2, #4
 8002552:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8002554:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8002556:	692a      	ldr	r2, [r5, #16]
 8002558:	430a      	orrs	r2, r1
 800255a:	e00f      	b.n	800257c <HAL_TIM_PWM_ConfigChannel+0xfc>
    {
       /* Check the parameters */
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));

     /* Configure the Channel 5 in PWM mode */
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 800255c:	6820      	ldr	r0, [r4, #0]
 800255e:	f7ff fed9 	bl	8002314 <TIM_OC6_SetConfig>

      /* Set the Preload enable bit for channel6 */
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8002562:	6823      	ldr	r3, [r4, #0]

     /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8;
 8002564:	6909      	ldr	r1, [r1, #16]

     /* Configure the Channel 5 in PWM mode */
      TIM_OC6_SetConfig(htim->Instance, sConfig);

      /* Set the Preload enable bit for channel6 */
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8002566:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8002568:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800256c:	655a      	str	r2, [r3, #84]	; 0x54

     /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 800256e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8002570:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8002574:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8;
 8002576:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8002578:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800257c:	655a      	str	r2, [r3, #84]	; 0x54

    default:
    break;
  }

  htim->State = HAL_TIM_STATE_READY;
 800257e:	2301      	movs	r3, #1

  __HAL_UNLOCK(htim);
 8002580:	2000      	movs	r0, #0

    default:
    break;
  }

  htim->State = HAL_TIM_STATE_READY;
 8002582:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  __HAL_UNLOCK(htim);
 8002586:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38

  return HAL_OK;
}
 800258a:	bd38      	pop	{r3, r4, r5, pc}

0800258c <TIM_CCxChannelCmd>:
  * @param  ChannelState: specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable.
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
{
 800258c:	b510      	push	{r4, lr}
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << Channel;

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 800258e:	2301      	movs	r3, #1
 8002590:	6a04      	ldr	r4, [r0, #32]
 8002592:	408b      	lsls	r3, r1
 8002594:	ea24 0303 	bic.w	r3, r4, r3
 8002598:	6203      	str	r3, [r0, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
 800259a:	6a03      	ldr	r3, [r0, #32]
 800259c:	408a      	lsls	r2, r1
 800259e:	ea42 0103 	orr.w	r1, r2, r3
 80025a2:	6201      	str	r1, [r0, #32]
 80025a4:	bd10      	pop	{r4, pc}
	...

080025a8 <HAL_TIM_PWM_Start>:
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @retval HAL status
*/
HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 80025a8:	b510      	push	{r4, lr}
 80025aa:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Enable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 80025ac:	2201      	movs	r2, #1
 80025ae:	6800      	ldr	r0, [r0, #0]
 80025b0:	f7ff ffec 	bl	800258c <TIM_CCxChannelCmd>

  if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 80025b4:	6823      	ldr	r3, [r4, #0]
 80025b6:	4a0a      	ldr	r2, [pc, #40]	; (80025e0 <HAL_TIM_PWM_Start+0x38>)
 80025b8:	4293      	cmp	r3, r2
 80025ba:	d007      	beq.n	80025cc <HAL_TIM_PWM_Start+0x24>
 80025bc:	f502 52a0 	add.w	r2, r2, #5120	; 0x1400
 80025c0:	4293      	cmp	r3, r2
 80025c2:	d003      	beq.n	80025cc <HAL_TIM_PWM_Start+0x24>
 80025c4:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80025c8:	4293      	cmp	r3, r2
 80025ca:	d103      	bne.n	80025d4 <HAL_TIM_PWM_Start+0x2c>
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
 80025cc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80025ce:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80025d2:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 80025d4:	681a      	ldr	r2, [r3, #0]
 80025d6:	f042 0201 	orr.w	r2, r2, #1
 80025da:	601a      	str	r2, [r3, #0]

  /* Return function status */
  return HAL_OK;
}
 80025dc:	2000      	movs	r0, #0
 80025de:	bd10      	pop	{r4, pc}
 80025e0:	40012c00 	.word	0x40012c00

080025e4 <TIM_CCxNChannelCmd>:
  * @param  ChannelNState: specifies the TIM Channel CCxNE bit new state.
  *          This parameter can be: TIM_CCxN_ENABLE or TIM_CCxN_Disable.
  * @retval None
  */
static void TIM_CCxNChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelNState)
{
 80025e4:	b510      	push	{r4, lr}
  uint32_t tmp = 0;

  tmp = TIM_CCER_CC1NE << Channel;

  /* Reset the CCxNE Bit */
  TIMx->CCER &=  ~tmp;
 80025e6:	2304      	movs	r3, #4
 80025e8:	6a04      	ldr	r4, [r0, #32]
 80025ea:	408b      	lsls	r3, r1
 80025ec:	ea24 0303 	bic.w	r3, r4, r3
 80025f0:	6203      	str	r3, [r0, #32]

  /* Set or reset the CCxNE Bit */
  TIMx->CCER |=  (uint32_t)(ChannelNState << Channel);
 80025f2:	6a03      	ldr	r3, [r0, #32]
 80025f4:	408a      	lsls	r2, r1
 80025f6:	ea42 0103 	orr.w	r1, r2, r3
 80025fa:	6201      	str	r1, [r0, #32]
 80025fc:	bd10      	pop	{r4, pc}

080025fe <HAL_TIMEx_PWMN_Start>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 80025fe:	b510      	push	{r4, lr}
 8002600:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));

  /* Enable the complementary PWM output  */
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
 8002602:	2204      	movs	r2, #4
 8002604:	6800      	ldr	r0, [r0, #0]
 8002606:	f7ff ffed 	bl	80025e4 <TIM_CCxNChannelCmd>

  /* Enable the Main Ouput */
  __HAL_TIM_MOE_ENABLE(htim);
 800260a:	6823      	ldr	r3, [r4, #0]
 800260c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800260e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8002612:	645a      	str	r2, [r3, #68]	; 0x44

  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 8002614:	681a      	ldr	r2, [r3, #0]
 8002616:	f042 0201 	orr.w	r2, r2, #1
 800261a:	601a      	str	r2, [r3, #0]

  /* Return function status */
  return HAL_OK;
}
 800261c:	2000      	movs	r0, #0
 800261e:	bd10      	pop	{r4, pc}

08002620 <HAL_TIMEx_OnePulseN_Stop>:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
{
 8002620:	b510      	push	{r4, lr}
 8002622:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));

  /* Disable the complementary One Pulse output */
  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
 8002624:	2200      	movs	r2, #0
 8002626:	6800      	ldr	r0, [r0, #0]
 8002628:	f7ff ffdc 	bl	80025e4 <TIM_CCxNChannelCmd>

  /* Disable the Main Ouput */
  __HAL_TIM_MOE_DISABLE(htim);
 800262c:	6823      	ldr	r3, [r4, #0]
 800262e:	6a19      	ldr	r1, [r3, #32]
 8002630:	f241 1211 	movw	r2, #4369	; 0x1111
 8002634:	400a      	ands	r2, r1
 8002636:	b942      	cbnz	r2, 800264a <HAL_TIMEx_OnePulseN_Stop+0x2a>
 8002638:	6a19      	ldr	r1, [r3, #32]
 800263a:	f240 4244 	movw	r2, #1092	; 0x444
 800263e:	400a      	ands	r2, r1
 8002640:	b91a      	cbnz	r2, 800264a <HAL_TIMEx_OnePulseN_Stop+0x2a>
 8002642:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8002644:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8002648:	645a      	str	r2, [r3, #68]	; 0x44

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
 800264a:	6a19      	ldr	r1, [r3, #32]
 800264c:	f241 1211 	movw	r2, #4369	; 0x1111
 8002650:	400a      	ands	r2, r1
 8002652:	b942      	cbnz	r2, 8002666 <HAL_TIMEx_OnePulseN_Stop+0x46>
 8002654:	6a19      	ldr	r1, [r3, #32]
 8002656:	f240 4244 	movw	r2, #1092	; 0x444
 800265a:	400a      	ands	r2, r1
 800265c:	b91a      	cbnz	r2, 8002666 <HAL_TIMEx_OnePulseN_Stop+0x46>
 800265e:	681a      	ldr	r2, [r3, #0]
 8002660:	f022 0201 	bic.w	r2, r2, #1
 8002664:	601a      	str	r2, [r3, #0]

  /* Return function status */
  return HAL_OK;
}
 8002666:	2000      	movs	r0, #0
 8002668:	bd10      	pop	{r4, pc}

0800266a <HAL_TIMEx_PWMN_Stop>:
 800266a:	f7ff bfd9 	b.w	8002620 <HAL_TIMEx_OnePulseN_Stop>
	...

08002670 <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8002670:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8002674:	2b01      	cmp	r3, #1
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                      TIM_MasterConfigTypeDef * sMasterConfig)
{
 8002676:	b530      	push	{r4, r5, lr}
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8002678:	d018      	beq.n	80026ac <HAL_TIMEx_MasterConfigSynchronization+0x3c>

 /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 800267a:	6802      	ldr	r2, [r0, #0]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 800267c:	4c0c      	ldr	r4, [pc, #48]	; (80026b0 <HAL_TIMEx_MasterConfigSynchronization+0x40>)

  /* Check input state */
  __HAL_LOCK(htim);

 /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 800267e:	6853      	ldr	r3, [r2, #4]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 8002680:	6895      	ldr	r5, [r2, #8]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8002682:	42a2      	cmp	r2, r4
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8002684:	bf02      	ittt	eq
 8002686:	684c      	ldreq	r4, [r1, #4]
  {
    /* Check the parameters */
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
 8002688:	f423 0370 	biceq.w	r3, r3, #15728640	; 0xf00000
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 800268c:	4323      	orreq	r3, r4
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800268e:	680c      	ldr	r4, [r1, #0]

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8002690:	6889      	ldr	r1, [r1, #8]
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 8002692:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8002696:	4323      	orrs	r3, r4

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
 8002698:	f025 0480 	bic.w	r4, r5, #128	; 0x80
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 800269c:	6053      	str	r3, [r2, #4]
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800269e:	4321      	orrs	r1, r4
  htim->Instance->CR2 = tmpcr2;

  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;

  __HAL_UNLOCK(htim);
 80026a0:	2300      	movs	r3, #0

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;

  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;
 80026a2:	6091      	str	r1, [r2, #8]

  __HAL_UNLOCK(htim);
 80026a4:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38

  return HAL_OK;
 80026a8:	4618      	mov	r0, r3
 80026aa:	bd30      	pop	{r4, r5, pc}
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 80026ac:	2002      	movs	r0, #2
  htim->Instance->SMCR = tmpsmcr;

  __HAL_UNLOCK(htim);

  return HAL_OK;
}
 80026ae:	bd30      	pop	{r4, r5, pc}
 80026b0:	40012c00 	.word	0x40012c00

080026b4 <HAL_TIMEx_ConfigBreakDeadTime>:
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
  assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
  
  /* Check input state */
  __HAL_LOCK(htim);
 80026b4:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 80026b8:	2b01      	cmp	r3, #1
  *         contains the BDTR Register configuration  information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
                                                TIM_BreakDeadTimeConfigTypeDef * sBreakDeadTimeConfig)
{
 80026ba:	b510      	push	{r4, lr}
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
  assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
  
  /* Check input state */
  __HAL_LOCK(htim);
 80026bc:	d034      	beq.n	8002728 <HAL_TIMEx_ConfigBreakDeadTime+0x74>
  the OSSI State, the dead time value and the Automatic Output Enable Bit */
  
  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 80026be:	68cb      	ldr	r3, [r1, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << BDTR_BKF_SHIFT));
  
  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 80026c0:	6804      	ldr	r4, [r0, #0]
  the OSSI State, the dead time value and the Automatic Output Enable Bit */
  
  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 80026c2:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 80026c6:	688b      	ldr	r3, [r1, #8]
 80026c8:	4313      	orrs	r3, r2
 80026ca:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 80026ce:	684b      	ldr	r3, [r1, #4]
 80026d0:	4313      	orrs	r3, r2
 80026d2:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 80026d6:	680b      	ldr	r3, [r1, #0]
 80026d8:	4313      	orrs	r3, r2
 80026da:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 80026de:	690b      	ldr	r3, [r1, #16]
 80026e0:	4313      	orrs	r3, r2
 80026e2:	f423 5200 	bic.w	r2, r3, #8192	; 0x2000
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 80026e6:	694b      	ldr	r3, [r1, #20]
 80026e8:	4313      	orrs	r3, r2
 80026ea:	6a8a      	ldr	r2, [r1, #40]	; 0x28
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
 80026ec:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << BDTR_BKF_SHIFT));
 80026f0:	431a      	orrs	r2, r3
 80026f2:	698b      	ldr	r3, [r1, #24]
 80026f4:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
 80026f8:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
  
  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 80026fc:	4a0b      	ldr	r2, [pc, #44]	; (800272c <HAL_TIMEx_ConfigBreakDeadTime+0x78>)
 80026fe:	4294      	cmp	r4, r2
 8002700:	d10c      	bne.n	800271c <HAL_TIMEx_ConfigBreakDeadTime+0x68>
    assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));
    assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));
    
    /* Set the BREAK2 input related BDTR bits */
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << BDTR_BK2F_SHIFT));
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
 8002702:	6a4a      	ldr	r2, [r1, #36]	; 0x24
    assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig->Break2State));
    assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));
    assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));
    
    /* Set the BREAK2 input related BDTR bits */
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << BDTR_BK2F_SHIFT));
 8002704:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
 8002708:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 800270c:	69ca      	ldr	r2, [r1, #28]
    assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));
    assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));
    
    /* Set the BREAK2 input related BDTR bits */
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << BDTR_BK2F_SHIFT));
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
 800270e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 8002712:	4313      	orrs	r3, r2
 8002714:	f023 7200 	bic.w	r2, r3, #33554432	; 0x2000000
 8002718:	6a0b      	ldr	r3, [r1, #32]
 800271a:	4313      	orrs	r3, r2
  }
  
  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;
 800271c:	6463      	str	r3, [r4, #68]	; 0x44
  
  __HAL_UNLOCK(htim);
 800271e:	2300      	movs	r3, #0
 8002720:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38

  return HAL_OK;
 8002724:	4618      	mov	r0, r3
 8002726:	bd10      	pop	{r4, pc}
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
  assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
  
  /* Check input state */
  __HAL_LOCK(htim);
 8002728:	2002      	movs	r0, #2
  htim->Instance->BDTR = tmpbdtr;
  
  __HAL_UNLOCK(htim);

  return HAL_OK;
}
 800272a:	bd10      	pop	{r4, pc}
 800272c:	40012c00 	.word	0x40012c00

08002730 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart: UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8002730:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002732:	4604      	mov	r4, r0
   *  set the M bits according to huart->Init.WordLength value
   *  set PCE and PS bits according to huart->Init.Parity value
   *  set TE and RE bits according to huart->Init.Mode value
   *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 8002734:	6805      	ldr	r5, [r0, #0]
 8002736:	6923      	ldr	r3, [r4, #16]
 8002738:	68a2      	ldr	r2, [r4, #8]
   *  the UART Word Length, Parity, Mode and oversampling:
   *  set the M bits according to huart->Init.WordLength value
   *  set PCE and PS bits according to huart->Init.Parity value
   *  set TE and RE bits according to huart->Init.Mode value
   *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800273a:	69c1      	ldr	r1, [r0, #28]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 800273c:	6828      	ldr	r0, [r5, #0]
 800273e:	431a      	orrs	r2, r3
 8002740:	6963      	ldr	r3, [r4, #20]
 8002742:	4313      	orrs	r3, r2
 8002744:	ea43 0201 	orr.w	r2, r3, r1
 8002748:	4b7d      	ldr	r3, [pc, #500]	; (8002940 <UART_SetConfig+0x210>)
 800274a:	4003      	ands	r3, r0
 800274c:	4313      	orrs	r3, r2
 800274e:	602b      	str	r3, [r5, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
   * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8002750:	686b      	ldr	r3, [r5, #4]
 8002752:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
 8002756:	68e3      	ldr	r3, [r4, #12]
 8002758:	4313      	orrs	r3, r2
   * - UART HardWare Flow Control: set CTSE and RTSE bits according
   *   to huart->Init.HwFlowCtl value
   * - one-bit sampling method versus three samples' majority rule according
   *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800275a:	4a7a      	ldr	r2, [pc, #488]	; (8002944 <UART_SetConfig+0x214>)
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
   * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800275c:	606b      	str	r3, [r5, #4]
   * - UART HardWare Flow Control: set CTSE and RTSE bits according
   *   to huart->Init.HwFlowCtl value
   * - one-bit sampling method versus three samples' majority rule according
   *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800275e:	4295      	cmp	r5, r2
  {
    tmpreg |= huart->Init.OneBitSampling;
 8002760:	bf18      	it	ne
 8002762:	6a22      	ldrne	r2, [r4, #32]
  /* Configure
   * - UART HardWare Flow Control: set CTSE and RTSE bits according
   *   to huart->Init.HwFlowCtl value
   * - one-bit sampling method versus three samples' majority rule according
   *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8002764:	69a3      	ldr	r3, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
  {
    tmpreg |= huart->Init.OneBitSampling;
 8002766:	bf18      	it	ne
 8002768:	4313      	orrne	r3, r2
  }
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 800276a:	68aa      	ldr	r2, [r5, #8]
 800276c:	f422 6230 	bic.w	r2, r2, #2816	; 0xb00
 8002770:	4313      	orrs	r3, r2
 8002772:	60ab      	str	r3, [r5, #8]

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8002774:	4b74      	ldr	r3, [pc, #464]	; (8002948 <UART_SetConfig+0x218>)
 8002776:	429d      	cmp	r5, r3
 8002778:	d107      	bne.n	800278a <UART_SetConfig+0x5a>
 800277a:	f503 4358 	add.w	r3, r3, #55296	; 0xd800
 800277e:	4a73      	ldr	r2, [pc, #460]	; (800294c <UART_SetConfig+0x21c>)
 8002780:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8002784:	f003 0303 	and.w	r3, r3, #3
 8002788:	e009      	b.n	800279e <UART_SetConfig+0x6e>
 800278a:	4b71      	ldr	r3, [pc, #452]	; (8002950 <UART_SetConfig+0x220>)
 800278c:	429d      	cmp	r5, r3
 800278e:	d10b      	bne.n	80027a8 <UART_SetConfig+0x78>
 8002790:	f503 33e6 	add.w	r3, r3, #117760	; 0x1cc00
 8002794:	4a6f      	ldr	r2, [pc, #444]	; (8002954 <UART_SetConfig+0x224>)
 8002796:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800279a:	f003 030c 	and.w	r3, r3, #12
        }
      }  /*   if ( (tmpreg < (3 * huart->Init.BaudRate) ) || (tmpreg > (4096 * huart->Init.BaudRate) )) */
    } /* if (tmpreg != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800279e:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 80027a2:	5cd3      	ldrb	r3, [r2, r3]
 80027a4:	d065      	beq.n	8002872 <UART_SetConfig+0x142>
 80027a6:	e099      	b.n	80028dc <UART_SetConfig+0x1ac>
    tmpreg |= huart->Init.OneBitSampling;
  }
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 80027a8:	4b66      	ldr	r3, [pc, #408]	; (8002944 <UART_SetConfig+0x214>)
 80027aa:	429d      	cmp	r5, r3
 80027ac:	f040 8089 	bne.w	80028c2 <UART_SetConfig+0x192>
 80027b0:	f503 33c8 	add.w	r3, r3, #102400	; 0x19000
 80027b4:	f8d3 5088 	ldr.w	r5, [r3, #136]	; 0x88
 80027b8:	f405 6540 	and.w	r5, r5, #3072	; 0xc00
 80027bc:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 80027c0:	d014      	beq.n	80027ec <UART_SetConfig+0xbc>
 80027c2:	d805      	bhi.n	80027d0 <UART_SetConfig+0xa0>
 80027c4:	2d00      	cmp	r5, #0
 80027c6:	f040 80b7 	bne.w	8002938 <UART_SetConfig+0x208>
    tmpreg = 0;

    switch (clocksource)
    {
    case UART_CLOCKSOURCE_PCLK1:
      tmpreg = HAL_RCC_GetPCLK1Freq();
 80027ca:	f7ff f919 	bl	8001a00 <HAL_RCC_GetPCLK1Freq>
      break;
 80027ce:	e010      	b.n	80027f2 <UART_SetConfig+0xc2>
    tmpreg |= huart->Init.OneBitSampling;
  }
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 80027d0:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 80027d4:	d007      	beq.n	80027e6 <UART_SetConfig+0xb6>
 80027d6:	f5b5 6f40 	cmp.w	r5, #3072	; 0xc00
 80027da:	f040 80ad 	bne.w	8002938 <UART_SetConfig+0x208>
 80027de:	2508      	movs	r5, #8
      break;
    case UART_CLOCKSOURCE_SYSCLK:
      tmpreg = HAL_RCC_GetSysClockFreq();
      break;
    case UART_CLOCKSOURCE_LSE:
      tmpreg = (uint32_t) LSE_VALUE;
 80027e0:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80027e4:	e008      	b.n	80027f8 <UART_SetConfig+0xc8>
    tmpreg |= huart->Init.OneBitSampling;
  }
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 80027e6:	2502      	movs	r5, #2
    {
    case UART_CLOCKSOURCE_PCLK1:
      tmpreg = HAL_RCC_GetPCLK1Freq();
      break;
    case UART_CLOCKSOURCE_HSI:
      tmpreg = (uint32_t) HSI_VALUE;
 80027e8:	485b      	ldr	r0, [pc, #364]	; (8002958 <UART_SetConfig+0x228>)
 80027ea:	e005      	b.n	80027f8 <UART_SetConfig+0xc8>
      break;
    case UART_CLOCKSOURCE_SYSCLK:
      tmpreg = HAL_RCC_GetSysClockFreq();
 80027ec:	f7fe fd3a 	bl	8001264 <HAL_RCC_GetSysClockFreq>
      break;
 80027f0:	2504      	movs	r5, #4
        ret = HAL_ERROR;
      break;
    }

    /* if proper clock source reported */
    if (tmpreg != 0)
 80027f2:	2800      	cmp	r0, #0
 80027f4:	f000 809e 	beq.w	8002934 <UART_SetConfig+0x204>
    {
      /* ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ( (tmpreg < (3 * huart->Init.BaudRate) ) ||
 80027f8:	6862      	ldr	r2, [r4, #4]
 80027fa:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 80027fe:	4283      	cmp	r3, r0
 8002800:	f200 809a 	bhi.w	8002938 <UART_SetConfig+0x208>
 8002804:	ebb0 3f02 	cmp.w	r0, r2, lsl #12
 8002808:	f200 8096 	bhi.w	8002938 <UART_SetConfig+0x208>
      {
        ret = HAL_ERROR;
      }
      else
      {
        switch (clocksource)
 800280c:	2d08      	cmp	r5, #8
 800280e:	d827      	bhi.n	8002860 <UART_SetConfig+0x130>
 8002810:	e8df f005 	tbb	[pc, r5]
 8002814:	26082605 	.word	0x26082605
 8002818:	2626260e 	.word	0x2626260e
 800281c:	1b          	.byte	0x1b
 800281d:	00          	.byte	0x00
        {
        case UART_CLOCKSOURCE_PCLK1:
          tmpreg = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 800281e:	f7ff f8ef 	bl	8001a00 <HAL_RCC_GetPCLK1Freq>
 8002822:	e007      	b.n	8002834 <UART_SetConfig+0x104>
          break;
        case UART_CLOCKSOURCE_HSI:
          tmpreg = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate));
 8002824:	484d      	ldr	r0, [pc, #308]	; (800295c <UART_SetConfig+0x22c>)
 8002826:	0855      	lsrs	r5, r2, #1
 8002828:	2300      	movs	r3, #0
 800282a:	2100      	movs	r1, #0
 800282c:	1940      	adds	r0, r0, r5
 800282e:	e011      	b.n	8002854 <UART_SetConfig+0x124>
          break;
        case UART_CLOCKSOURCE_SYSCLK:
          tmpreg = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8002830:	f7fe fd18 	bl	8001264 <HAL_RCC_GetSysClockFreq>
 8002834:	6862      	ldr	r2, [r4, #4]
 8002836:	f44f 7180 	mov.w	r1, #256	; 0x100
 800283a:	0856      	lsrs	r6, r2, #1
 800283c:	2700      	movs	r7, #0
 800283e:	fbe1 6700 	umlal	r6, r7, r1, r0
 8002842:	2300      	movs	r3, #0
 8002844:	4630      	mov	r0, r6
 8002846:	4639      	mov	r1, r7
 8002848:	e006      	b.n	8002858 <UART_SetConfig+0x128>
          break;
        case UART_CLOCKSOURCE_LSE:
          tmpreg = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate));
 800284a:	0850      	lsrs	r0, r2, #1
 800284c:	2100      	movs	r1, #0
 800284e:	2300      	movs	r3, #0
 8002850:	f510 0000 	adds.w	r0, r0, #8388608	; 0x800000
 8002854:	f141 0100 	adc.w	r1, r1, #0
 8002858:	f7fe f98c 	bl	8000b74 <__aeabi_uldivmod>
          break;
 800285c:	2200      	movs	r2, #0
 800285e:	e000      	b.n	8002862 <UART_SetConfig+0x132>
        case UART_CLOCKSOURCE_UNDEFINED:
        default:
          ret = HAL_ERROR;
 8002860:	2201      	movs	r2, #1
          break;
        }
   
        if ((tmpreg >= UART_LPUART_BRR_MIN) && (tmpreg <= UART_LPUART_BRR_MAX))
 8002862:	4b3f      	ldr	r3, [pc, #252]	; (8002960 <UART_SetConfig+0x230>)
 8002864:	f5a0 7140 	sub.w	r1, r0, #768	; 0x300
 8002868:	4299      	cmp	r1, r3
 800286a:	d865      	bhi.n	8002938 <UART_SetConfig+0x208>
        {
           huart->Instance->BRR = tmpreg;
 800286c:	6823      	ldr	r3, [r4, #0]
 800286e:	60d8      	str	r0, [r3, #12]
 8002870:	e063      	b.n	800293a <UART_SetConfig+0x20a>
    } /* if (tmpreg != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
  {
    switch (clocksource)
 8002872:	2b08      	cmp	r3, #8
 8002874:	d828      	bhi.n	80028c8 <UART_SetConfig+0x198>
 8002876:	e8df f003 	tbb	[pc, r3]
 800287a:	0805      	.short	0x0805
 800287c:	2712270b 	.word	0x2712270b
 8002880:	2727      	.short	0x2727
 8002882:	1b          	.byte	0x1b
 8002883:	00          	.byte	0x00
    {
    case UART_CLOCKSOURCE_PCLK1:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8002884:	f7ff f8bc 	bl	8001a00 <HAL_RCC_GetPCLK1Freq>
 8002888:	e00b      	b.n	80028a2 <UART_SetConfig+0x172>
      break;
    case UART_CLOCKSOURCE_PCLK2:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 800288a:	f7ff f8d1 	bl	8001a30 <HAL_RCC_GetPCLK2Freq>
 800288e:	e008      	b.n	80028a2 <UART_SetConfig+0x172>
      break;
    case UART_CLOCKSOURCE_HSI:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 8002890:	6860      	ldr	r0, [r4, #4]
 8002892:	0842      	lsrs	r2, r0, #1
 8002894:	f102 73f4 	add.w	r3, r2, #31981568	; 0x1e80000
 8002898:	f503 4390 	add.w	r3, r3, #18432	; 0x4800
 800289c:	e00c      	b.n	80028b8 <UART_SetConfig+0x188>
      break;
    case UART_CLOCKSOURCE_SYSCLK:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800289e:	f7fe fce1 	bl	8001264 <HAL_RCC_GetSysClockFreq>
 80028a2:	6863      	ldr	r3, [r4, #4]
 80028a4:	085a      	lsrs	r2, r3, #1
 80028a6:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 80028aa:	fbb0 f3f3 	udiv	r3, r0, r3
 80028ae:	e005      	b.n	80028bc <UART_SetConfig+0x18c>
      break;
    case UART_CLOCKSOURCE_LSE:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 80028b0:	6860      	ldr	r0, [r4, #4]
 80028b2:	0843      	lsrs	r3, r0, #1
 80028b4:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 80028b8:	fbb3 f3f0 	udiv	r3, r3, r0
 80028bc:	b29b      	uxth	r3, r3
{
  uint32_t tmpreg                     = 0x00000000;
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
  uint16_t brrtemp                    = 0x0000;
  uint16_t usartdiv                   = 0x0000;
  HAL_StatusTypeDef ret               = HAL_OK;
 80028be:	2200      	movs	r2, #0
    case UART_CLOCKSOURCE_SYSCLK:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
      break;
    case UART_CLOCKSOURCE_LSE:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
      break;
 80028c0:	e004      	b.n	80028cc <UART_SetConfig+0x19c>
        }
      }  /*   if ( (tmpreg < (3 * huart->Init.BaudRate) ) || (tmpreg > (4096 * huart->Init.BaudRate) )) */
    } /* if (tmpreg != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80028c2:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 80028c6:	d137      	bne.n	8002938 <UART_SetConfig+0x208>
    case UART_CLOCKSOURCE_LSE:
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
      break;
    case UART_CLOCKSOURCE_UNDEFINED:
    default:
        ret = HAL_ERROR;
 80028c8:	2201      	movs	r2, #1
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
  uint32_t tmpreg                     = 0x00000000;
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
  uint16_t brrtemp                    = 0x0000;
  uint16_t usartdiv                   = 0x0000;
 80028ca:	2300      	movs	r3, #0
        ret = HAL_ERROR;
      break;
    }

    brrtemp = usartdiv & 0xFFF0;
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000F) >> 1U);
 80028cc:	f3c3 0042 	ubfx	r0, r3, #1, #3
    huart->Instance->BRR = brrtemp;
 80028d0:	6821      	ldr	r1, [r4, #0]
        ret = HAL_ERROR;
      break;
    }

    brrtemp = usartdiv & 0xFFF0;
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000F) >> 1U);
 80028d2:	f023 030f 	bic.w	r3, r3, #15
    huart->Instance->BRR = brrtemp;
 80028d6:	4303      	orrs	r3, r0
 80028d8:	60cb      	str	r3, [r1, #12]
 80028da:	e02e      	b.n	800293a <UART_SetConfig+0x20a>
  }
  else
  {
    switch (clocksource)
 80028dc:	2b08      	cmp	r3, #8
 80028de:	d82b      	bhi.n	8002938 <UART_SetConfig+0x208>
 80028e0:	e8df f003 	tbb	[pc, r3]
 80028e4:	2a0b0805 	.word	0x2a0b0805
 80028e8:	2a2a2a14 	.word	0x2a2a2a14
 80028ec:	1e          	.byte	0x1e
 80028ed:	00          	.byte	0x00
    {
    case UART_CLOCKSOURCE_PCLK1:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 80028ee:	f7ff f887 	bl	8001a00 <HAL_RCC_GetPCLK1Freq>
 80028f2:	e00d      	b.n	8002910 <UART_SetConfig+0x1e0>
      break;
    case UART_CLOCKSOURCE_PCLK2:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 80028f4:	f7ff f89c 	bl	8001a30 <HAL_RCC_GetPCLK2Freq>
 80028f8:	e00a      	b.n	8002910 <UART_SetConfig+0x1e0>
      break;
    case UART_CLOCKSOURCE_HSI:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 80028fa:	6861      	ldr	r1, [r4, #4]
 80028fc:	084a      	lsrs	r2, r1, #1
 80028fe:	f502 0374 	add.w	r3, r2, #15990784	; 0xf40000
 8002902:	f503 5310 	add.w	r3, r3, #9216	; 0x2400
 8002906:	fbb3 f3f1 	udiv	r3, r3, r1
 800290a:	e00f      	b.n	800292c <UART_SetConfig+0x1fc>
      break;
    case UART_CLOCKSOURCE_SYSCLK:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800290c:	f7fe fcaa 	bl	8001264 <HAL_RCC_GetSysClockFreq>
 8002910:	6863      	ldr	r3, [r4, #4]
 8002912:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 8002916:	fbb0 f0f3 	udiv	r0, r0, r3
 800291a:	b280      	uxth	r0, r0
 800291c:	60e8      	str	r0, [r5, #12]
 800291e:	e007      	b.n	8002930 <UART_SetConfig+0x200>
      break;
    case UART_CLOCKSOURCE_LSE:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 8002920:	6862      	ldr	r2, [r4, #4]
 8002922:	0853      	lsrs	r3, r2, #1
 8002924:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
 8002928:	fbb3 f3f2 	udiv	r3, r3, r2
 800292c:	b29b      	uxth	r3, r3
 800292e:	60eb      	str	r3, [r5, #12]
{
  uint32_t tmpreg                     = 0x00000000;
  UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
  uint16_t brrtemp                    = 0x0000;
  uint16_t usartdiv                   = 0x0000;
  HAL_StatusTypeDef ret               = HAL_OK;
 8002930:	2200      	movs	r2, #0
    case UART_CLOCKSOURCE_SYSCLK:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
      break;
    case UART_CLOCKSOURCE_LSE:
      huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
      break;
 8002932:	e002      	b.n	800293a <UART_SetConfig+0x20a>
 8002934:	4602      	mov	r2, r0
 8002936:	e000      	b.n	800293a <UART_SetConfig+0x20a>
    case UART_CLOCKSOURCE_UNDEFINED:
    default:
        ret = HAL_ERROR;
 8002938:	2201      	movs	r2, #1
    }
  }

  return ret;

}
 800293a:	4610      	mov	r0, r2
 800293c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800293e:	bf00      	nop
 8002940:	efff69f3 	.word	0xefff69f3
 8002944:	40008000 	.word	0x40008000
 8002948:	40013800 	.word	0x40013800
 800294c:	0800631c 	.word	0x0800631c
 8002950:	40004400 	.word	0x40004400
 8002954:	08006320 	.word	0x08006320
 8002958:	00f42400 	.word	0x00f42400
 800295c:	f4240000 	.word	0xf4240000
 8002960:	000ffcff 	.word	0x000ffcff

08002964 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8002964:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8002966:	07da      	lsls	r2, r3, #31
  * @brief Configure the UART peripheral advanced features.
  * @param huart: UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 8002968:	b510      	push	{r4, lr}
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800296a:	d506      	bpl.n	800297a <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800296c:	6804      	ldr	r4, [r0, #0]
 800296e:	6862      	ldr	r2, [r4, #4]
 8002970:	f422 3100 	bic.w	r1, r2, #131072	; 0x20000
 8002974:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8002976:	430a      	orrs	r2, r1
 8002978:	6062      	str	r2, [r4, #4]
  }

  /* if required, configure RX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800297a:	079c      	lsls	r4, r3, #30
 800297c:	d506      	bpl.n	800298c <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800297e:	6804      	ldr	r4, [r0, #0]
 8002980:	6862      	ldr	r2, [r4, #4]
 8002982:	f422 3180 	bic.w	r1, r2, #65536	; 0x10000
 8002986:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8002988:	430a      	orrs	r2, r1
 800298a:	6062      	str	r2, [r4, #4]
  }

  /* if required, configure data inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800298c:	0759      	lsls	r1, r3, #29
 800298e:	d506      	bpl.n	800299e <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8002990:	6804      	ldr	r4, [r0, #0]
 8002992:	6862      	ldr	r2, [r4, #4]
 8002994:	f422 2180 	bic.w	r1, r2, #262144	; 0x40000
 8002998:	6b02      	ldr	r2, [r0, #48]	; 0x30
 800299a:	430a      	orrs	r2, r1
 800299c:	6062      	str	r2, [r4, #4]
  }

  /* if required, configure RX/TX pins swap */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800299e:	071a      	lsls	r2, r3, #28
 80029a0:	d506      	bpl.n	80029b0 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 80029a2:	6804      	ldr	r4, [r0, #0]
 80029a4:	6862      	ldr	r2, [r4, #4]
 80029a6:	f422 4100 	bic.w	r1, r2, #32768	; 0x8000
 80029aa:	6b42      	ldr	r2, [r0, #52]	; 0x34
 80029ac:	430a      	orrs	r2, r1
 80029ae:	6062      	str	r2, [r4, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 80029b0:	06dc      	lsls	r4, r3, #27
 80029b2:	d506      	bpl.n	80029c2 <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 80029b4:	6804      	ldr	r4, [r0, #0]
 80029b6:	68a2      	ldr	r2, [r4, #8]
 80029b8:	f422 5180 	bic.w	r1, r2, #4096	; 0x1000
 80029bc:	6b82      	ldr	r2, [r0, #56]	; 0x38
 80029be:	430a      	orrs	r2, r1
 80029c0:	60a2      	str	r2, [r4, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 80029c2:	0699      	lsls	r1, r3, #26
 80029c4:	d506      	bpl.n	80029d4 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 80029c6:	6804      	ldr	r4, [r0, #0]
 80029c8:	68a2      	ldr	r2, [r4, #8]
 80029ca:	f422 5100 	bic.w	r1, r2, #8192	; 0x2000
 80029ce:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 80029d0:	430a      	orrs	r2, r1
 80029d2:	60a2      	str	r2, [r4, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 80029d4:	065a      	lsls	r2, r3, #25
 80029d6:	d50f      	bpl.n	80029f8 <UART_AdvFeatureConfig+0x94>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80029d8:	6801      	ldr	r1, [r0, #0]
 80029da:	6c04      	ldr	r4, [r0, #64]	; 0x40
 80029dc:	684a      	ldr	r2, [r1, #4]
 80029de:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 80029e2:	4322      	orrs	r2, r4
    /* set auto Baudrate detection parameters if detection is enabled */
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80029e4:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
  /* if required, configure auto Baud rate detection scheme */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80029e8:	604a      	str	r2, [r1, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80029ea:	d105      	bne.n	80029f8 <UART_AdvFeatureConfig+0x94>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 80029ec:	684a      	ldr	r2, [r1, #4]
 80029ee:	f422 04c0 	bic.w	r4, r2, #6291456	; 0x600000
 80029f2:	6c42      	ldr	r2, [r0, #68]	; 0x44
 80029f4:	4322      	orrs	r2, r4
 80029f6:	604a      	str	r2, [r1, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 80029f8:	061b      	lsls	r3, r3, #24
 80029fa:	d506      	bpl.n	8002a0a <UART_AdvFeatureConfig+0xa6>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 80029fc:	6801      	ldr	r1, [r0, #0]
 80029fe:	684b      	ldr	r3, [r1, #4]
 8002a00:	f423 2200 	bic.w	r2, r3, #524288	; 0x80000
 8002a04:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8002a06:	4313      	orrs	r3, r2
 8002a08:	604b      	str	r3, [r1, #4]
 8002a0a:	bd10      	pop	{r4, pc}

08002a0c <UART_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
{
 8002a0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002a10:	9d06      	ldr	r5, [sp, #24]
 8002a12:	4604      	mov	r4, r0
 8002a14:	460f      	mov	r7, r1
 8002a16:	4616      	mov	r6, r2
 8002a18:	4698      	mov	r8, r3
  /* Wait until flag is set */
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8002a1a:	6821      	ldr	r1, [r4, #0]
 8002a1c:	69ca      	ldr	r2, [r1, #28]
 8002a1e:	ea37 0302 	bics.w	r3, r7, r2
 8002a22:	bf0c      	ite	eq
 8002a24:	2201      	moveq	r2, #1
 8002a26:	2200      	movne	r2, #0
 8002a28:	42b2      	cmp	r2, r6
 8002a2a:	d11d      	bne.n	8002a68 <UART_WaitOnFlagUntilTimeout+0x5c>
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 8002a2c:	1c6b      	adds	r3, r5, #1
 8002a2e:	d0f5      	beq.n	8002a1c <UART_WaitOnFlagUntilTimeout+0x10>
    {
      if((Timeout == 0) || ((HAL_GetTick()-Tickstart) > Timeout))
 8002a30:	b99d      	cbnz	r5, 8002a5a <UART_WaitOnFlagUntilTimeout+0x4e>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8002a32:	6823      	ldr	r3, [r4, #0]
 8002a34:	681a      	ldr	r2, [r3, #0]
 8002a36:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 8002a3a:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8002a3c:	689a      	ldr	r2, [r3, #8]
 8002a3e:	f022 0201 	bic.w	r2, r2, #1
 8002a42:	609a      	str	r2, [r3, #8]

        huart->gState  = HAL_UART_STATE_READY;
 8002a44:	2320      	movs	r3, #32
 8002a46:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
        huart->RxState = HAL_UART_STATE_READY;
 8002a4a:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a

        /* Process Unlocked */
        __HAL_UNLOCK(huart);
 8002a4e:	2300      	movs	r3, #0
 8002a50:	f884 3068 	strb.w	r3, [r4, #104]	; 0x68
 8002a54:	2003      	movs	r0, #3
 8002a56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0) || ((HAL_GetTick()-Tickstart) > Timeout))
 8002a5a:	f7fe fa3f 	bl	8000edc <HAL_GetTick>
 8002a5e:	ebc8 0000 	rsb	r0, r8, r0
 8002a62:	4285      	cmp	r5, r0
 8002a64:	d2d9      	bcs.n	8002a1a <UART_WaitOnFlagUntilTimeout+0xe>
 8002a66:	e7e4      	b.n	8002a32 <UART_WaitOnFlagUntilTimeout+0x26>
        __HAL_UNLOCK(huart);
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 8002a68:	2000      	movs	r0, #0
}
 8002a6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08002a6e <HAL_UART_Transmit>:
  * @param Size: Amount of data to be sent.
  * @param Timeout: Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8002a6e:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8002a72:	461f      	mov	r7, r3
  uint16_t* tmp;
  uint32_t tickstart = 0;

  /* Check that a Tx process is not already ongoing */
  if(huart->gState == HAL_UART_STATE_READY)
 8002a74:	f890 3069 	ldrb.w	r3, [r0, #105]	; 0x69
 8002a78:	2b20      	cmp	r3, #32
  * @param Size: Amount of data to be sent.
  * @param Timeout: Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8002a7a:	4604      	mov	r4, r0
 8002a7c:	460d      	mov	r5, r1
 8002a7e:	4690      	mov	r8, r2
  uint16_t* tmp;
  uint32_t tickstart = 0;

  /* Check that a Tx process is not already ongoing */
  if(huart->gState == HAL_UART_STATE_READY)
 8002a80:	d14b      	bne.n	8002b1a <HAL_UART_Transmit+0xac>
  {
    if((pData == NULL ) || (Size == 0))
 8002a82:	2900      	cmp	r1, #0
 8002a84:	d047      	beq.n	8002b16 <HAL_UART_Transmit+0xa8>
 8002a86:	2a00      	cmp	r2, #0
 8002a88:	d045      	beq.n	8002b16 <HAL_UART_Transmit+0xa8>
    {
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 8002a8a:	f890 3068 	ldrb.w	r3, [r0, #104]	; 0x68
 8002a8e:	2b01      	cmp	r3, #1
 8002a90:	d043      	beq.n	8002b1a <HAL_UART_Transmit+0xac>
 8002a92:	2301      	movs	r3, #1
 8002a94:	f880 3068 	strb.w	r3, [r0, #104]	; 0x68

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002a98:	2300      	movs	r3, #0
 8002a9a:	66c3      	str	r3, [r0, #108]	; 0x6c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8002a9c:	2321      	movs	r3, #33	; 0x21
 8002a9e:	f880 3069 	strb.w	r3, [r0, #105]	; 0x69

    /* Init tickstart for timeout managment*/
    tickstart = HAL_GetTick();
 8002aa2:	f7fe fa1b 	bl	8000edc <HAL_GetTick>

    huart->TxXferSize = Size;
 8002aa6:	f8a4 8050 	strh.w	r8, [r4, #80]	; 0x50

    huart->ErrorCode = HAL_UART_ERROR_NONE;
    huart->gState = HAL_UART_STATE_BUSY_TX;

    /* Init tickstart for timeout managment*/
    tickstart = HAL_GetTick();
 8002aaa:	4606      	mov	r6, r0

    huart->TxXferSize = Size;
    huart->TxXferCount = Size;
 8002aac:	f8a4 8052 	strh.w	r8, [r4, #82]	; 0x52
    while(huart->TxXferCount > 0)
 8002ab0:	f8b4 2052 	ldrh.w	r2, [r4, #82]	; 0x52
 8002ab4:	b292      	uxth	r2, r2
 8002ab6:	b302      	cbz	r2, 8002afa <HAL_UART_Transmit+0x8c>
    {
      huart->TxXferCount--;
 8002ab8:	f8b4 3052 	ldrh.w	r3, [r4, #82]	; 0x52
      if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8002abc:	9700      	str	r7, [sp, #0]

    huart->TxXferSize = Size;
    huart->TxXferCount = Size;
    while(huart->TxXferCount > 0)
    {
      huart->TxXferCount--;
 8002abe:	3b01      	subs	r3, #1
 8002ac0:	b29b      	uxth	r3, r3
 8002ac2:	f8a4 3052 	strh.w	r3, [r4, #82]	; 0x52
      if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8002ac6:	2200      	movs	r2, #0
 8002ac8:	4633      	mov	r3, r6
 8002aca:	2180      	movs	r1, #128	; 0x80
 8002acc:	4620      	mov	r0, r4
 8002ace:	f7ff ff9d 	bl	8002a0c <UART_WaitOnFlagUntilTimeout>
 8002ad2:	b108      	cbz	r0, 8002ad8 <HAL_UART_Transmit+0x6a>
      {
        return HAL_TIMEOUT;
 8002ad4:	2003      	movs	r0, #3
 8002ad6:	e021      	b.n	8002b1c <HAL_UART_Transmit+0xae>
      }
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002ad8:	68a3      	ldr	r3, [r4, #8]
 8002ada:	6822      	ldr	r2, [r4, #0]
 8002adc:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8002ae0:	d107      	bne.n	8002af2 <HAL_UART_Transmit+0x84>
 8002ae2:	6923      	ldr	r3, [r4, #16]
 8002ae4:	b92b      	cbnz	r3, 8002af2 <HAL_UART_Transmit+0x84>
      {
        tmp = (uint16_t*) pData;
        huart->Instance->TDR = (*tmp & (uint16_t)0x01FF);
 8002ae6:	f835 3b02 	ldrh.w	r3, [r5], #2
 8002aea:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8002aee:	8513      	strh	r3, [r2, #40]	; 0x28
        pData += 2;
 8002af0:	e7de      	b.n	8002ab0 <HAL_UART_Transmit+0x42>
      }
      else
      {
        huart->Instance->TDR = (*pData++ & (uint8_t)0xFF);
 8002af2:	782b      	ldrb	r3, [r5, #0]
 8002af4:	8513      	strh	r3, [r2, #40]	; 0x28
 8002af6:	3501      	adds	r5, #1
 8002af8:	e7da      	b.n	8002ab0 <HAL_UART_Transmit+0x42>
      }
    }
    if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8002afa:	9700      	str	r7, [sp, #0]
 8002afc:	4633      	mov	r3, r6
 8002afe:	2140      	movs	r1, #64	; 0x40
 8002b00:	4620      	mov	r0, r4
 8002b02:	f7ff ff83 	bl	8002a0c <UART_WaitOnFlagUntilTimeout>
 8002b06:	2800      	cmp	r0, #0
 8002b08:	d1e4      	bne.n	8002ad4 <HAL_UART_Transmit+0x66>
    {
      return HAL_TIMEOUT;
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 8002b0a:	2320      	movs	r3, #32
 8002b0c:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 8002b10:	f884 0068 	strb.w	r0, [r4, #104]	; 0x68

    return HAL_OK;
 8002b14:	e002      	b.n	8002b1c <HAL_UART_Transmit+0xae>
  /* Check that a Tx process is not already ongoing */
  if(huart->gState == HAL_UART_STATE_READY)
  {
    if((pData == NULL ) || (Size == 0))
    {
      return  HAL_ERROR;
 8002b16:	2001      	movs	r0, #1
 8002b18:	e000      	b.n	8002b1c <HAL_UART_Transmit+0xae>

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8002b1a:	2002      	movs	r0, #2
  }
}
 8002b1c:	b002      	add	sp, #8
 8002b1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08002b22 <HAL_UART_Receive>:
  * @param Size: amount of data to be received.
  * @param Timeout: Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8002b22:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8002b26:	4698      	mov	r8, r3
  uint16_t* tmp;
  uint16_t uhMask;
  uint32_t tickstart = 0;

  /* Check that a Rx process is not already ongoing */
  if(huart->RxState == HAL_UART_STATE_READY)
 8002b28:	f890 306a 	ldrb.w	r3, [r0, #106]	; 0x6a
 8002b2c:	2b20      	cmp	r3, #32
  * @param Size: amount of data to be received.
  * @param Timeout: Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8002b2e:	4604      	mov	r4, r0
 8002b30:	460d      	mov	r5, r1
 8002b32:	4616      	mov	r6, r2
  uint16_t* tmp;
  uint16_t uhMask;
  uint32_t tickstart = 0;

  /* Check that a Rx process is not already ongoing */
  if(huart->RxState == HAL_UART_STATE_READY)
 8002b34:	d15d      	bne.n	8002bf2 <HAL_UART_Receive+0xd0>
  {
    if((pData == NULL ) || (Size == 0))
 8002b36:	2900      	cmp	r1, #0
 8002b38:	d059      	beq.n	8002bee <HAL_UART_Receive+0xcc>
 8002b3a:	2a00      	cmp	r2, #0
 8002b3c:	d057      	beq.n	8002bee <HAL_UART_Receive+0xcc>
    {
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 8002b3e:	f890 3068 	ldrb.w	r3, [r0, #104]	; 0x68
 8002b42:	2b01      	cmp	r3, #1
 8002b44:	d055      	beq.n	8002bf2 <HAL_UART_Receive+0xd0>
 8002b46:	2301      	movs	r3, #1
 8002b48:	f880 3068 	strb.w	r3, [r0, #104]	; 0x68

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002b4c:	2300      	movs	r3, #0
 8002b4e:	66c3      	str	r3, [r0, #108]	; 0x6c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8002b50:	2322      	movs	r3, #34	; 0x22
 8002b52:	f880 306a 	strb.w	r3, [r0, #106]	; 0x6a

    /* Init tickstart for timeout managment*/
    tickstart = HAL_GetTick();
 8002b56:	f7fe f9c1 	bl	8000edc <HAL_GetTick>

    huart->RxXferSize = Size;
    huart->RxXferCount = Size;

    /* Computation of UART mask to apply to RDR register */
    UART_MASK_COMPUTATION(huart);
 8002b5a:	68a3      	ldr	r3, [r4, #8]
    huart->RxState = HAL_UART_STATE_BUSY_RX;

    /* Init tickstart for timeout managment*/
    tickstart = HAL_GetTick();

    huart->RxXferSize = Size;
 8002b5c:	f8a4 6058 	strh.w	r6, [r4, #88]	; 0x58
    huart->RxXferCount = Size;

    /* Computation of UART mask to apply to RDR register */
    UART_MASK_COMPUTATION(huart);
 8002b60:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000

    huart->ErrorCode = HAL_UART_ERROR_NONE;
    huart->RxState = HAL_UART_STATE_BUSY_RX;

    /* Init tickstart for timeout managment*/
    tickstart = HAL_GetTick();
 8002b64:	4607      	mov	r7, r0

    huart->RxXferSize = Size;
    huart->RxXferCount = Size;
 8002b66:	f8a4 605a 	strh.w	r6, [r4, #90]	; 0x5a

    /* Computation of UART mask to apply to RDR register */
    UART_MASK_COMPUTATION(huart);
 8002b6a:	d104      	bne.n	8002b76 <HAL_UART_Receive+0x54>
 8002b6c:	6923      	ldr	r3, [r4, #16]
 8002b6e:	b92b      	cbnz	r3, 8002b7c <HAL_UART_Receive+0x5a>
 8002b70:	f240 13ff 	movw	r3, #511	; 0x1ff
 8002b74:	e00d      	b.n	8002b92 <HAL_UART_Receive+0x70>
 8002b76:	b92b      	cbnz	r3, 8002b84 <HAL_UART_Receive+0x62>
 8002b78:	6923      	ldr	r3, [r4, #16]
 8002b7a:	b90b      	cbnz	r3, 8002b80 <HAL_UART_Receive+0x5e>
 8002b7c:	23ff      	movs	r3, #255	; 0xff
 8002b7e:	e008      	b.n	8002b92 <HAL_UART_Receive+0x70>
 8002b80:	237f      	movs	r3, #127	; 0x7f
 8002b82:	e006      	b.n	8002b92 <HAL_UART_Receive+0x70>
 8002b84:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8002b88:	d105      	bne.n	8002b96 <HAL_UART_Receive+0x74>
 8002b8a:	6923      	ldr	r3, [r4, #16]
 8002b8c:	2b00      	cmp	r3, #0
 8002b8e:	d0f7      	beq.n	8002b80 <HAL_UART_Receive+0x5e>
 8002b90:	233f      	movs	r3, #63	; 0x3f
 8002b92:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
    uhMask = huart->Mask;
 8002b96:	f8b4 605c 	ldrh.w	r6, [r4, #92]	; 0x5c

    /* as long as data have to be received */
    while(huart->RxXferCount > 0)
 8002b9a:	f8b4 005a 	ldrh.w	r0, [r4, #90]	; 0x5a
 8002b9e:	b280      	uxth	r0, r0
 8002ba0:	b1f8      	cbz	r0, 8002be2 <HAL_UART_Receive+0xc0>
    {
      huart->RxXferCount--;
 8002ba2:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
      if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 8002ba6:	f8cd 8000 	str.w	r8, [sp]
    uhMask = huart->Mask;

    /* as long as data have to be received */
    while(huart->RxXferCount > 0)
    {
      huart->RxXferCount--;
 8002baa:	3b01      	subs	r3, #1
 8002bac:	b29b      	uxth	r3, r3
 8002bae:	f8a4 305a 	strh.w	r3, [r4, #90]	; 0x5a
      if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 8002bb2:	2200      	movs	r2, #0
 8002bb4:	463b      	mov	r3, r7
 8002bb6:	2120      	movs	r1, #32
 8002bb8:	4620      	mov	r0, r4
 8002bba:	f7ff ff27 	bl	8002a0c <UART_WaitOnFlagUntilTimeout>
 8002bbe:	b9d0      	cbnz	r0, 8002bf6 <HAL_UART_Receive+0xd4>
      {
        return HAL_TIMEOUT;
      }
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002bc0:	68a3      	ldr	r3, [r4, #8]
 8002bc2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8002bc6:	6823      	ldr	r3, [r4, #0]
 8002bc8:	d106      	bne.n	8002bd8 <HAL_UART_Receive+0xb6>
 8002bca:	6922      	ldr	r2, [r4, #16]
 8002bcc:	b922      	cbnz	r2, 8002bd8 <HAL_UART_Receive+0xb6>
      {
        tmp = (uint16_t*) pData ;
        *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
 8002bce:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8002bd0:	4033      	ands	r3, r6
 8002bd2:	f825 3b02 	strh.w	r3, [r5], #2
        pData +=2;
 8002bd6:	e7e0      	b.n	8002b9a <HAL_UART_Receive+0x78>
      }
      else
      {
        *pData++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
 8002bd8:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8002bda:	4033      	ands	r3, r6
 8002bdc:	702b      	strb	r3, [r5, #0]
 8002bde:	3501      	adds	r5, #1
 8002be0:	e7db      	b.n	8002b9a <HAL_UART_Receive+0x78>
      }
    }

    /* At end of Rx process, restore huart->RxState to Ready */
    huart->RxState = HAL_UART_STATE_READY;
 8002be2:	2320      	movs	r3, #32
 8002be4:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 8002be8:	f884 0068 	strb.w	r0, [r4, #104]	; 0x68

    return HAL_OK;
 8002bec:	e004      	b.n	8002bf8 <HAL_UART_Receive+0xd6>
  /* Check that a Rx process is not already ongoing */
  if(huart->RxState == HAL_UART_STATE_READY)
  {
    if((pData == NULL ) || (Size == 0))
    {
      return  HAL_ERROR;
 8002bee:	2001      	movs	r0, #1
 8002bf0:	e002      	b.n	8002bf8 <HAL_UART_Receive+0xd6>

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8002bf2:	2002      	movs	r0, #2
 8002bf4:	e000      	b.n	8002bf8 <HAL_UART_Receive+0xd6>
    while(huart->RxXferCount > 0)
    {
      huart->RxXferCount--;
      if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
      {
        return HAL_TIMEOUT;
 8002bf6:	2003      	movs	r0, #3
  }
  else
  {
    return HAL_BUSY;
  }
}
 8002bf8:	b002      	add	sp, #8
 8002bfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08002bfe <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 8002bfe:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8002c00:	4604      	mov	r4, r0
  uint32_t tickstart = 0;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002c02:	2600      	movs	r6, #0
 8002c04:	66c6      	str	r6, [r0, #108]	; 0x6c

  /* Init tickstart for timeout managment*/
  tickstart = HAL_GetTick();
 8002c06:	f7fe f969 	bl	8000edc <HAL_GetTick>

  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8002c0a:	6823      	ldr	r3, [r4, #0]
 8002c0c:	681b      	ldr	r3, [r3, #0]
 8002c0e:	071a      	lsls	r2, r3, #28

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;

  /* Init tickstart for timeout managment*/
  tickstart = HAL_GetTick();
 8002c10:	4605      	mov	r5, r0

  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8002c12:	d404      	bmi.n	8002c1e <UART_CheckIdleState+0x20>
      /* Timeout occurred */
      return HAL_TIMEOUT;
    }
  }
  /* Check if the Receiver is enabled */
  if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8002c14:	6823      	ldr	r3, [r4, #0]
 8002c16:	681b      	ldr	r3, [r3, #0]
 8002c18:	075b      	lsls	r3, r3, #29
 8002c1a:	d51a      	bpl.n	8002c52 <UART_CheckIdleState+0x54>
 8002c1c:	e00d      	b.n	8002c3a <UART_CheckIdleState+0x3c>

  /* Check if the Transmitter is enabled */
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
  {
    /* Wait until TEACK flag is set */
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8002c1e:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8002c22:	9300      	str	r3, [sp, #0]
 8002c24:	4632      	mov	r2, r6
 8002c26:	4603      	mov	r3, r0
 8002c28:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8002c2c:	4620      	mov	r0, r4
 8002c2e:	f7ff feed 	bl	8002a0c <UART_WaitOnFlagUntilTimeout>
 8002c32:	2800      	cmp	r0, #0
 8002c34:	d0ee      	beq.n	8002c14 <UART_CheckIdleState+0x16>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 8002c36:	2003      	movs	r0, #3
 8002c38:	e013      	b.n	8002c62 <UART_CheckIdleState+0x64>
  }
  /* Check if the Receiver is enabled */
  if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
  {
    /* Wait until REACK flag is set */
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8002c3a:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8002c3e:	9300      	str	r3, [sp, #0]
 8002c40:	2200      	movs	r2, #0
 8002c42:	462b      	mov	r3, r5
 8002c44:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8002c48:	4620      	mov	r0, r4
 8002c4a:	f7ff fedf 	bl	8002a0c <UART_WaitOnFlagUntilTimeout>
 8002c4e:	2800      	cmp	r0, #0
 8002c50:	d1f1      	bne.n	8002c36 <UART_CheckIdleState+0x38>
      return HAL_TIMEOUT;
    }
  }

  /* Initialize the UART State */
  huart->gState  = HAL_UART_STATE_READY;
 8002c52:	2320      	movs	r3, #32
  huart->RxState = HAL_UART_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8002c54:	2000      	movs	r0, #0
      return HAL_TIMEOUT;
    }
  }

  /* Initialize the UART State */
  huart->gState  = HAL_UART_STATE_READY;
 8002c56:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
  huart->RxState = HAL_UART_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8002c5a:	f884 0068 	strb.w	r0, [r4, #104]	; 0x68
    }
  }

  /* Initialize the UART State */
  huart->gState  = HAL_UART_STATE_READY;
  huart->RxState = HAL_UART_STATE_READY;
 8002c5e:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a

  /* Process Unlocked */
  __HAL_UNLOCK(huart);

  return HAL_OK;
}
 8002c62:	b002      	add	sp, #8
 8002c64:	bd70      	pop	{r4, r5, r6, pc}

08002c66 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart: UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 8002c66:	b510      	push	{r4, lr}
  /* Check the UART handle allocation */
  if(huart == NULL)
 8002c68:	4604      	mov	r4, r0
 8002c6a:	b360      	cbz	r0, 8002cc6 <HAL_UART_Init+0x60>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if(huart->gState == HAL_UART_STATE_RESET)
 8002c6c:	f890 3069 	ldrb.w	r3, [r0, #105]	; 0x69
 8002c70:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002c74:	b91b      	cbnz	r3, 8002c7e <HAL_UART_Init+0x18>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8002c76:	f880 2068 	strb.w	r2, [r0, #104]	; 0x68

    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 8002c7a:	f000 ff7b 	bl	8003b74 <HAL_UART_MspInit>
  }

  huart->gState = HAL_UART_STATE_BUSY;

  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 8002c7e:	6822      	ldr	r2, [r4, #0]

    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
  }

  huart->gState = HAL_UART_STATE_BUSY;
 8002c80:	2324      	movs	r3, #36	; 0x24
 8002c82:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69

  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 8002c86:	6813      	ldr	r3, [r2, #0]
 8002c88:	f023 0301 	bic.w	r3, r3, #1
 8002c8c:	6013      	str	r3, [r2, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 8002c8e:	4620      	mov	r0, r4
 8002c90:	f7ff fd4e 	bl	8002730 <UART_SetConfig>
 8002c94:	2801      	cmp	r0, #1
 8002c96:	d016      	beq.n	8002cc6 <HAL_UART_Init+0x60>
  {
    return HAL_ERROR;
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8002c98:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002c9a:	b113      	cbz	r3, 8002ca2 <HAL_UART_Init+0x3c>
  {
    UART_AdvFeatureConfig(huart);
 8002c9c:	4620      	mov	r0, r4
 8002c9e:	f7ff fe61 	bl	8002964 <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8002ca2:	6823      	ldr	r3, [r4, #0]
 8002ca4:	685a      	ldr	r2, [r3, #4]
 8002ca6:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8002caa:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8002cac:	689a      	ldr	r2, [r3, #8]
 8002cae:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8002cb2:	609a      	str	r2, [r3, #8]

  /* Enable the Peripheral */
  __HAL_UART_ENABLE(huart);
 8002cb4:	681a      	ldr	r2, [r3, #0]
 8002cb6:	f042 0201 	orr.w	r2, r2, #1

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 8002cba:	4620      	mov	r0, r4
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));

  /* Enable the Peripheral */
  __HAL_UART_ENABLE(huart);
 8002cbc:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
}
 8002cbe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  /* Enable the Peripheral */
  __HAL_UART_ENABLE(huart);

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 8002cc2:	f7ff bf9c 	b.w	8002bfe <UART_CheckIdleState>
}
 8002cc6:	2001      	movs	r0, #1
 8002cc8:	bd10      	pop	{r4, pc}

08002cca <commandList>:
static uint16_t _fg = ST7735_GREEN;
static uint16_t _bg = ST7735_BLACK;

// Companion code to the above tables.  Reads and issues
// a series of LCD commands stored in PROGMEM byte array.
static void commandList(const uint8_t *addr) {
 8002cca:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t  numCommands, numArgs;
	uint16_t ms;

	numCommands = *addr++;   // Number of commands to follow
 8002cce:	7806      	ldrb	r6, [r0, #0]
 8002cd0:	1c44      	adds	r4, r0, #1
	while(numCommands--) {                 // For each command...
 8002cd2:	b32e      	cbz	r6, 8002d20 <commandList+0x56>
		lcd7735_sendCmd(*addr++); //   Read, issue command
 8002cd4:	4627      	mov	r7, r4
 8002cd6:	f817 0b02 	ldrb.w	r0, [r7], #2
 8002cda:	f000 faf9 	bl	80032d0 <lcd7735_sendCmd>
		numArgs  = *addr++;    //   Number of args to follow
 8002cde:	7865      	ldrb	r5, [r4, #1]
 8002ce0:	f025 087f 	bic.w	r8, r5, #127	; 0x7f
		ms       = numArgs & DELAY;          //   If hibit set, delay follows args
		numArgs &= ~DELAY;                   //   Mask out delay bit
 8002ce4:	f005 057f 	and.w	r5, r5, #127	; 0x7f
 8002ce8:	fa5f f888 	uxtb.w	r8, r8
 8002cec:	462c      	mov	r4, r5
	uint16_t ms;

	numCommands = *addr++;   // Number of commands to follow
	while(numCommands--) {                 // For each command...
		lcd7735_sendCmd(*addr++); //   Read, issue command
		numArgs  = *addr++;    //   Number of args to follow
 8002cee:	46b9      	mov	r9, r7
		ms       = numArgs & DELAY;          //   If hibit set, delay follows args
		numArgs &= ~DELAY;                   //   Mask out delay bit
		while(numArgs--) {                   //   For each argument...
 8002cf0:	3c01      	subs	r4, #1
 8002cf2:	b2e4      	uxtb	r4, r4
 8002cf4:	2cff      	cmp	r4, #255	; 0xff
 8002cf6:	d004      	beq.n	8002d02 <commandList+0x38>
			lcd7735_sendData(*addr++);  //     Read, issue argument
 8002cf8:	f819 0b01 	ldrb.w	r0, [r9], #1
 8002cfc:	f000 faf0 	bl	80032e0 <lcd7735_sendData>
 8002d00:	e7f6      	b.n	8002cf0 <commandList+0x26>
 8002d02:	197c      	adds	r4, r7, r5
		}

		if(ms) {
 8002d04:	f1b8 0f00 	cmp.w	r8, #0
 8002d08:	d007      	beq.n	8002d1a <commandList+0x50>
			ms = *addr++; // Read post-command delay time (ms)
 8002d0a:	5d78      	ldrb	r0, [r7, r5]
			if(ms == 255) ms = 500;     // If 255, delay for 500 ms
 8002d0c:	28ff      	cmp	r0, #255	; 0xff
			HAL_Delay(ms);
 8002d0e:	bf08      	it	eq
 8002d10:	f44f 70fa 	moveq.w	r0, #500	; 0x1f4
		while(numArgs--) {                   //   For each argument...
			lcd7735_sendData(*addr++);  //     Read, issue argument
		}

		if(ms) {
			ms = *addr++; // Read post-command delay time (ms)
 8002d14:	3401      	adds	r4, #1
			if(ms == 255) ms = 500;     // If 255, delay for 500 ms
			HAL_Delay(ms);
 8002d16:	f7fe f8e7 	bl	8000ee8 <HAL_Delay>
 8002d1a:	3e01      	subs	r6, #1
 8002d1c:	b2f6      	uxtb	r6, r6
 8002d1e:	e7d8      	b.n	8002cd2 <commandList+0x8>
		}
	}
}
 8002d20:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08002d24 <commonInit>:

// Initialization code common to both 'B' and 'R' type displays
static void commonInit(const uint8_t *cmdList) {
 8002d24:	b570      	push	{r4, r5, r6, lr}
	// toggle RST low to reset; CS low so it'll listen to us
	LCD_CS0;
 8002d26:	4c0c      	ldr	r4, [pc, #48]	; (8002d58 <commonInit+0x34>)
 8002d28:	2302      	movs	r3, #2
#ifdef LCD_SOFT_RESET
	lcd7735_sendCmd(ST7735_SWRESET);
	delay_ms(500);
#else
	LCD_RST1;
 8002d2a:	2510      	movs	r5, #16
}

// Initialization code common to both 'B' and 'R' type displays
static void commonInit(const uint8_t *cmdList) {
	// toggle RST low to reset; CS low so it'll listen to us
	LCD_CS0;
 8002d2c:	62a3      	str	r3, [r4, #40]	; 0x28
		}
	}
}

// Initialization code common to both 'B' and 'R' type displays
static void commonInit(const uint8_t *cmdList) {
 8002d2e:	4606      	mov	r6, r0
	LCD_CS0;
#ifdef LCD_SOFT_RESET
	lcd7735_sendCmd(ST7735_SWRESET);
	delay_ms(500);
#else
	LCD_RST1;
 8002d30:	61a5      	str	r5, [r4, #24]
	HAL_Delay(100);
 8002d32:	2064      	movs	r0, #100	; 0x64
 8002d34:	f7fe f8d8 	bl	8000ee8 <HAL_Delay>
	LCD_RST0;
	HAL_Delay(100);
 8002d38:	2064      	movs	r0, #100	; 0x64
	lcd7735_sendCmd(ST7735_SWRESET);
	delay_ms(500);
#else
	LCD_RST1;
	HAL_Delay(100);
	LCD_RST0;
 8002d3a:	62a5      	str	r5, [r4, #40]	; 0x28
	HAL_Delay(100);
 8002d3c:	f7fe f8d4 	bl	8000ee8 <HAL_Delay>
	LCD_RST1;
 8002d40:	61a5      	str	r5, [r4, #24]
	HAL_Delay(100);
 8002d42:	2064      	movs	r0, #100	; 0x64
 8002d44:	f7fe f8d0 	bl	8000ee8 <HAL_Delay>
#endif    
	if(cmdList) commandList(cmdList);
 8002d48:	b126      	cbz	r6, 8002d54 <commonInit+0x30>
 8002d4a:	4630      	mov	r0, r6
}
 8002d4c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	LCD_RST0;
	HAL_Delay(100);
	LCD_RST1;
	HAL_Delay(100);
#endif    
	if(cmdList) commandList(cmdList);
 8002d50:	f7ff bfbb 	b.w	8002cca <commandList>
 8002d54:	bd70      	pop	{r4, r5, r6, pc}
 8002d56:	bf00      	nop
 8002d58:	48000400 	.word	0x48000400

08002d5c <lcd7735_initR>:
	commonInit(Bcmd);
}


// Initialization for ST7735R screens (green or red tabs)
void lcd7735_initR(uint8_t options) {
 8002d5c:	b510      	push	{r4, lr}
 8002d5e:	4604      	mov	r4, r0
	HAL_Delay(50);
 8002d60:	2032      	movs	r0, #50	; 0x32
 8002d62:	f7fe f8c1 	bl	8000ee8 <HAL_Delay>
	commonInit(Rcmd1);
 8002d66:	480f      	ldr	r0, [pc, #60]	; (8002da4 <lcd7735_initR+0x48>)
 8002d68:	f7ff ffdc 	bl	8002d24 <commonInit>
	if(options == INITR_GREENTAB) {
 8002d6c:	b94c      	cbnz	r4, 8002d82 <lcd7735_initR+0x26>
		commandList(Rcmd2green);
 8002d6e:	480e      	ldr	r0, [pc, #56]	; (8002da8 <lcd7735_initR+0x4c>)
 8002d70:	f7ff ffab 	bl	8002cca <commandList>
		colstart = 2;
 8002d74:	4b0d      	ldr	r3, [pc, #52]	; (8002dac <lcd7735_initR+0x50>)
 8002d76:	2202      	movs	r2, #2
 8002d78:	601a      	str	r2, [r3, #0]
		rowstart = 1;
 8002d7a:	4b0d      	ldr	r3, [pc, #52]	; (8002db0 <lcd7735_initR+0x54>)
 8002d7c:	2201      	movs	r2, #1
 8002d7e:	601a      	str	r2, [r3, #0]
 8002d80:	e002      	b.n	8002d88 <lcd7735_initR+0x2c>
	} else {
		// colstart, rowstart left at default '0' values
		commandList(Rcmd2red);
 8002d82:	480c      	ldr	r0, [pc, #48]	; (8002db4 <lcd7735_initR+0x58>)
 8002d84:	f7ff ffa1 	bl	8002cca <commandList>
	}
	commandList(Rcmd3);
 8002d88:	480b      	ldr	r0, [pc, #44]	; (8002db8 <lcd7735_initR+0x5c>)
 8002d8a:	f7ff ff9e 	bl	8002cca <commandList>

	// if black, change MADCTL color filter
	if (options == INITR_BLACKTAB) {
 8002d8e:	2c02      	cmp	r4, #2
 8002d90:	d107      	bne.n	8002da2 <lcd7735_initR+0x46>
		lcd7735_sendCmd(ST7735_MADCTL);
 8002d92:	2036      	movs	r0, #54	; 0x36
 8002d94:	f000 fa9c 	bl	80032d0 <lcd7735_sendCmd>
		lcd7735_sendData(0xC0);
 8002d98:	20c0      	movs	r0, #192	; 0xc0
	}

	//  tabcolor = options;
}
 8002d9a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	commandList(Rcmd3);

	// if black, change MADCTL color filter
	if (options == INITR_BLACKTAB) {
		lcd7735_sendCmd(ST7735_MADCTL);
		lcd7735_sendData(0xC0);
 8002d9e:	f000 ba9f 	b.w	80032e0 <lcd7735_sendData>
 8002da2:	bd10      	pop	{r4, pc}
 8002da4:	080067a5 	.word	0x080067a5
 8002da8:	0800680c 	.word	0x0800680c
 8002dac:	20000148 	.word	0x20000148
 8002db0:	20000140 	.word	0x20000140
 8002db4:	08006819 	.word	0x08006819
 8002db8:	080067e1 	.word	0x080067e1

08002dbc <lcd7735_setAddrWindow>:

	//  tabcolor = options;
}


void lcd7735_setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
 8002dbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002dc0:	4680      	mov	r8, r0
	lcd7735_sendCmd(ST7735_CASET);		// Column addr set
	lcd7735_sendData(0x00);
	lcd7735_sendData(x0+colstart);     // XSTART 
 8002dc2:	4c18      	ldr	r4, [pc, #96]	; (8002e24 <lcd7735_setAddrWindow+0x68>)
	//  tabcolor = options;
}


void lcd7735_setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	lcd7735_sendCmd(ST7735_CASET);		// Column addr set
 8002dc4:	202a      	movs	r0, #42	; 0x2a

	//  tabcolor = options;
}


void lcd7735_setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
 8002dc6:	460e      	mov	r6, r1
 8002dc8:	4617      	mov	r7, r2
 8002dca:	461d      	mov	r5, r3
	lcd7735_sendCmd(ST7735_CASET);		// Column addr set
 8002dcc:	f000 fa80 	bl	80032d0 <lcd7735_sendCmd>
	lcd7735_sendData(0x00);
 8002dd0:	2000      	movs	r0, #0
 8002dd2:	f000 fa85 	bl	80032e0 <lcd7735_sendData>
	lcd7735_sendData(x0+colstart);     // XSTART 
 8002dd6:	6820      	ldr	r0, [r4, #0]
 8002dd8:	4440      	add	r0, r8
 8002dda:	b2c0      	uxtb	r0, r0
 8002ddc:	f000 fa80 	bl	80032e0 <lcd7735_sendData>
	lcd7735_sendData(0x00);
 8002de0:	2000      	movs	r0, #0
 8002de2:	f000 fa7d 	bl	80032e0 <lcd7735_sendData>
	lcd7735_sendData(x1+colstart);     // XEND
 8002de6:	6820      	ldr	r0, [r4, #0]

	lcd7735_sendCmd(ST7735_RASET); // Row addr set
	lcd7735_sendData(0x00);
	lcd7735_sendData(y0+rowstart);     // YSTART
 8002de8:	4c0f      	ldr	r4, [pc, #60]	; (8002e28 <lcd7735_setAddrWindow+0x6c>)
void lcd7735_setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	lcd7735_sendCmd(ST7735_CASET);		// Column addr set
	lcd7735_sendData(0x00);
	lcd7735_sendData(x0+colstart);     // XSTART 
	lcd7735_sendData(0x00);
	lcd7735_sendData(x1+colstart);     // XEND
 8002dea:	4438      	add	r0, r7
 8002dec:	b2c0      	uxtb	r0, r0
 8002dee:	f000 fa77 	bl	80032e0 <lcd7735_sendData>

	lcd7735_sendCmd(ST7735_RASET); // Row addr set
 8002df2:	202b      	movs	r0, #43	; 0x2b
 8002df4:	f000 fa6c 	bl	80032d0 <lcd7735_sendCmd>
	lcd7735_sendData(0x00);
 8002df8:	2000      	movs	r0, #0
 8002dfa:	f000 fa71 	bl	80032e0 <lcd7735_sendData>
	lcd7735_sendData(y0+rowstart);     // YSTART
 8002dfe:	6820      	ldr	r0, [r4, #0]
 8002e00:	4430      	add	r0, r6
 8002e02:	b2c0      	uxtb	r0, r0
 8002e04:	f000 fa6c 	bl	80032e0 <lcd7735_sendData>
	lcd7735_sendData(0x00);
 8002e08:	2000      	movs	r0, #0
 8002e0a:	f000 fa69 	bl	80032e0 <lcd7735_sendData>
	lcd7735_sendData(y1+rowstart);     // YEND
 8002e0e:	6820      	ldr	r0, [r4, #0]
 8002e10:	4428      	add	r0, r5
 8002e12:	b2c0      	uxtb	r0, r0
 8002e14:	f000 fa64 	bl	80032e0 <lcd7735_sendData>

	lcd7735_sendCmd(ST7735_RAMWR); // write to RAM
 8002e18:	202c      	movs	r0, #44	; 0x2c
}
 8002e1a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	lcd7735_sendData(0x00);
	lcd7735_sendData(y0+rowstart);     // YSTART
	lcd7735_sendData(0x00);
	lcd7735_sendData(y1+rowstart);     // YEND

	lcd7735_sendCmd(ST7735_RAMWR); // write to RAM
 8002e1e:	f000 ba57 	b.w	80032d0 <lcd7735_sendCmd>
 8002e22:	bf00      	nop
 8002e24:	20000148 	.word	0x20000148
 8002e28:	20000140 	.word	0x20000140

08002e2c <lcd7735_pushColor>:
}
void lcd7735_pushColor(uint16_t color) {
 8002e2c:	b510      	push	{r4, lr}
	LCD_DC1;  
 8002e2e:	4b06      	ldr	r3, [pc, #24]	; (8002e48 <lcd7735_pushColor+0x1c>)
 8002e30:	2201      	movs	r2, #1
	lcd7735_sendData(0x00);
	lcd7735_sendData(y1+rowstart);     // YEND

	lcd7735_sendCmd(ST7735_RAMWR); // write to RAM
}
void lcd7735_pushColor(uint16_t color) {
 8002e32:	4604      	mov	r4, r0
	LCD_DC1;  
 8002e34:	619a      	str	r2, [r3, #24]
	putpix(color);
 8002e36:	0a00      	lsrs	r0, r0, #8
 8002e38:	f000 fa3c 	bl	80032b4 <lcd7735_senddata>
 8002e3c:	b2e0      	uxtb	r0, r4
}
 8002e3e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

	lcd7735_sendCmd(ST7735_RAMWR); // write to RAM
}
void lcd7735_pushColor(uint16_t color) {
	LCD_DC1;  
	putpix(color);
 8002e42:	f000 ba37 	b.w	80032b4 <lcd7735_senddata>
 8002e46:	bf00      	nop
 8002e48:	48000400 	.word	0x48000400

08002e4c <lcd7735_fillRect>:
	lcd7735_setAddrWindow(x,y,x+1,y+1);
	lcd7735_pushColor(color);
}

// fill a rectangle
void lcd7735_fillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {	
 8002e4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002e50:	461c      	mov	r4, r3
	// rudimentary clipping (drawChar w/big text requires this)
	if((x >= _width) || (y >= _height)) return;
 8002e52:	4b1d      	ldr	r3, [pc, #116]	; (8002ec8 <lcd7735_fillRect+0x7c>)
	lcd7735_setAddrWindow(x,y,x+1,y+1);
	lcd7735_pushColor(color);
}

// fill a rectangle
void lcd7735_fillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {	
 8002e54:	f8bd 6018 	ldrh.w	r6, [sp, #24]
 8002e58:	4615      	mov	r5, r2
	// rudimentary clipping (drawChar w/big text requires this)
	if((x >= _width) || (y >= _height)) return;
 8002e5a:	881a      	ldrh	r2, [r3, #0]
 8002e5c:	4290      	cmp	r0, r2
 8002e5e:	da31      	bge.n	8002ec4 <lcd7735_fillRect+0x78>
 8002e60:	4b1a      	ldr	r3, [pc, #104]	; (8002ecc <lcd7735_fillRect+0x80>)
 8002e62:	881b      	ldrh	r3, [r3, #0]
 8002e64:	4299      	cmp	r1, r3
 8002e66:	da2d      	bge.n	8002ec4 <lcd7735_fillRect+0x78>
	if((x + w - 1) >= _width)  w = _width  - x;
 8002e68:	182f      	adds	r7, r5, r0
 8002e6a:	42ba      	cmp	r2, r7
 8002e6c:	bfb8      	it	lt
 8002e6e:	1a15      	sublt	r5, r2, r0
	if((y + h - 1) >= _height) h = _height - y;
 8002e70:	eb04 0201 	add.w	r2, r4, r1

// fill a rectangle
void lcd7735_fillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {	
	// rudimentary clipping (drawChar w/big text requires this)
	if((x >= _width) || (y >= _height)) return;
	if((x + w - 1) >= _width)  w = _width  - x;
 8002e74:	bfb8      	it	lt
 8002e76:	b22d      	sxthlt	r5, r5
	if((y + h - 1) >= _height) h = _height - y;
 8002e78:	4293      	cmp	r3, r2
 8002e7a:	bfb8      	it	lt
 8002e7c:	1a5c      	sublt	r4, r3, r1

	lcd7735_setAddrWindow(x, y, x+w-1, y+h-1);
 8002e7e:	b2c0      	uxtb	r0, r0
 8002e80:	b2c9      	uxtb	r1, r1
// fill a rectangle
void lcd7735_fillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color) {	
	// rudimentary clipping (drawChar w/big text requires this)
	if((x >= _width) || (y >= _height)) return;
	if((x + w - 1) >= _width)  w = _width  - x;
	if((y + h - 1) >= _height) h = _height - y;
 8002e82:	bfb8      	it	lt
 8002e84:	b224      	sxthlt	r4, r4

	lcd7735_setAddrWindow(x, y, x+w-1, y+h-1);
 8002e86:	1e4b      	subs	r3, r1, #1
 8002e88:	1e42      	subs	r2, r0, #1
 8002e8a:	4423      	add	r3, r4
 8002e8c:	442a      	add	r2, r5
 8002e8e:	b2db      	uxtb	r3, r3
 8002e90:	b2d2      	uxtb	r2, r2
 8002e92:	f7ff ff93 	bl	8002dbc <lcd7735_setAddrWindow>

	LCD_DC1;
 8002e96:	4b0e      	ldr	r3, [pc, #56]	; (8002ed0 <lcd7735_fillRect+0x84>)
 8002e98:	2201      	movs	r2, #1
 8002e9a:	619a      	str	r2, [r3, #24]
	for(y=h; y>0; y--) {
		for(x=w; x>0; x--) {
			putpix(color);
 8002e9c:	ea4f 2816 	mov.w	r8, r6, lsr #8
 8002ea0:	b2f7      	uxtb	r7, r6
	if((y + h - 1) >= _height) h = _height - y;

	lcd7735_setAddrWindow(x, y, x+w-1, y+h-1);

	LCD_DC1;
	for(y=h; y>0; y--) {
 8002ea2:	2c00      	cmp	r4, #0
 8002ea4:	dd0e      	ble.n	8002ec4 <lcd7735_fillRect+0x78>
 8002ea6:	462e      	mov	r6, r5
		for(x=w; x>0; x--) {
 8002ea8:	2e00      	cmp	r6, #0
 8002eaa:	dd08      	ble.n	8002ebe <lcd7735_fillRect+0x72>
			putpix(color);
 8002eac:	4640      	mov	r0, r8
 8002eae:	f000 fa01 	bl	80032b4 <lcd7735_senddata>
 8002eb2:	3e01      	subs	r6, #1
 8002eb4:	4638      	mov	r0, r7
 8002eb6:	f000 f9fd 	bl	80032b4 <lcd7735_senddata>
 8002eba:	b236      	sxth	r6, r6
 8002ebc:	e7f4      	b.n	8002ea8 <lcd7735_fillRect+0x5c>
 8002ebe:	3c01      	subs	r4, #1
 8002ec0:	b224      	sxth	r4, r4
 8002ec2:	e7ee      	b.n	8002ea2 <lcd7735_fillRect+0x56>
 8002ec4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002ec8:	20000002 	.word	0x20000002
 8002ecc:	20000000 	.word	0x20000000
 8002ed0:	48000400 	.word	0x48000400

08002ed4 <lcd7735_setFont>:
			}
	}
}

void lcd7735_setFont(uint8_t* font) {
	cfont.font=font;
 8002ed4:	4b05      	ldr	r3, [pc, #20]	; (8002eec <lcd7735_setFont+0x18>)
	cfont.x_size=font[0];
 8002ed6:	7802      	ldrb	r2, [r0, #0]
 8002ed8:	711a      	strb	r2, [r3, #4]
	cfont.y_size=font[1];
 8002eda:	7842      	ldrb	r2, [r0, #1]
 8002edc:	715a      	strb	r2, [r3, #5]
	cfont.offset=font[2];
 8002ede:	7882      	ldrb	r2, [r0, #2]
 8002ee0:	719a      	strb	r2, [r3, #6]
	cfont.numchars=font[3];
 8002ee2:	78c2      	ldrb	r2, [r0, #3]
			}
	}
}

void lcd7735_setFont(uint8_t* font) {
	cfont.font=font;
 8002ee4:	6018      	str	r0, [r3, #0]
	cfont.x_size=font[0];
	cfont.y_size=font[1];
	cfont.offset=font[2];
	cfont.numchars=font[3];
 8002ee6:	811a      	strh	r2, [r3, #8]
 8002ee8:	4770      	bx	lr
 8002eea:	bf00      	nop
 8002eec:	20000130 	.word	0x20000130

08002ef0 <printChar>:
}

void printChar(uint8_t c, int x, int y) {
 8002ef0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t i,ch,fz;
	uint16_t j;
	uint16_t temp; 
	int zz;

	if( cfont.x_size < 8 ) 
 8002ef4:	4d4f      	ldr	r5, [pc, #316]	; (8003034 <printChar+0x144>)
		fz = cfont.x_size;
	else
		fz = cfont.x_size/8;
	if (!_transparent) {
 8002ef6:	4b50      	ldr	r3, [pc, #320]	; (8003038 <printChar+0x148>)
	uint8_t i,ch,fz;
	uint16_t j;
	uint16_t temp; 
	int zz;

	if( cfont.x_size < 8 ) 
 8002ef8:	f895 e004 	ldrb.w	lr, [r5, #4]
		fz = cfont.x_size;
	else
		fz = cfont.x_size/8;
	if (!_transparent) {
 8002efc:	f893 8000 	ldrb.w	r8, [r3]
	uint8_t i,ch,fz;
	uint16_t j;
	uint16_t temp; 
	int zz;

	if( cfont.x_size < 8 ) 
 8002f00:	f1be 0f07 	cmp.w	lr, #7
	cfont.y_size=font[1];
	cfont.offset=font[2];
	cfont.numchars=font[3];
}

void printChar(uint8_t c, int x, int y) {
 8002f04:	b087      	sub	sp, #28
 8002f06:	4604      	mov	r4, r0
 8002f08:	460f      	mov	r7, r1
	int zz;

	if( cfont.x_size < 8 ) 
		fz = cfont.x_size;
	else
		fz = cfont.x_size/8;
 8002f0a:	bf8c      	ite	hi
 8002f0c:	ea4f 06de 	movhi.w	r6, lr, lsr #3
 8002f10:	4676      	movls	r6, lr
	if (!_transparent) {
 8002f12:	f1b8 0f00 	cmp.w	r8, #0
 8002f16:	d137      	bne.n	8002f88 <printChar+0x98>
		lcd7735_setAddrWindow(x,y,x+cfont.x_size-1,y+cfont.y_size-1);
 8002f18:	796b      	ldrb	r3, [r5, #5]

		temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
		for(j=0;j<((fz)*cfont.y_size);j++) {
 8002f1a:	4f46      	ldr	r7, [pc, #280]	; (8003034 <printChar+0x144>)
	if( cfont.x_size < 8 ) 
		fz = cfont.x_size;
	else
		fz = cfont.x_size/8;
	if (!_transparent) {
		lcd7735_setAddrWindow(x,y,x+cfont.x_size-1,y+cfont.y_size-1);
 8002f1c:	b2c8      	uxtb	r0, r1
 8002f1e:	f10e 3eff 	add.w	lr, lr, #4294967295
 8002f22:	b2d1      	uxtb	r1, r2
 8002f24:	3b01      	subs	r3, #1
 8002f26:	eb00 020e 	add.w	r2, r0, lr
 8002f2a:	440b      	add	r3, r1
 8002f2c:	b2db      	uxtb	r3, r3
 8002f2e:	b2d2      	uxtb	r2, r2
 8002f30:	f7ff ff44 	bl	8002dbc <lcd7735_setAddrWindow>

		temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
 8002f34:	79a8      	ldrb	r0, [r5, #6]
 8002f36:	1a20      	subs	r0, r4, r0
 8002f38:	796c      	ldrb	r4, [r5, #5]
 8002f3a:	fb14 f400 	smulbb	r4, r4, r0
 8002f3e:	fb14 f406 	smulbb	r4, r4, r6
 8002f42:	3404      	adds	r4, #4
 8002f44:	b2a4      	uxth	r4, r4
		for(j=0;j<((fz)*cfont.y_size);j++) {
 8002f46:	796b      	ldrb	r3, [r5, #5]
 8002f48:	fa1f f288 	uxth.w	r2, r8
 8002f4c:	fb16 f303 	smulbb	r3, r6, r3
 8002f50:	eb04 0108 	add.w	r1, r4, r8
 8002f54:	429a      	cmp	r2, r3
 8002f56:	b289      	uxth	r1, r1
 8002f58:	da68      	bge.n	800302c <printChar+0x13c>
			ch = cfont.font[temp];
 8002f5a:	683b      	ldr	r3, [r7, #0]
			for(i=0;i<8;i++) {   
				if((ch&(1<<(7-i)))!=0)   
				{
					lcd7735_pushColor(_fg);
 8002f5c:	f8df b0e0 	ldr.w	fp, [pc, #224]	; 8003040 <printChar+0x150>
	if (!_transparent) {
		lcd7735_setAddrWindow(x,y,x+cfont.x_size-1,y+cfont.y_size-1);

		temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
		for(j=0;j<((fz)*cfont.y_size);j++) {
			ch = cfont.font[temp];
 8002f60:	f813 a001 	ldrb.w	sl, [r3, r1]
 8002f64:	f04f 0907 	mov.w	r9, #7
			for(i=0;i<8;i++) {   
				if((ch&(1<<(7-i)))!=0)   
 8002f68:	fa4a f209 	asr.w	r2, sl, r9
 8002f6c:	07d2      	lsls	r2, r2, #31
				{
					lcd7735_pushColor(_fg);
				} 
				else
				{
					lcd7735_pushColor(_bg);
 8002f6e:	bf56      	itet	pl
 8002f70:	4b32      	ldrpl	r3, [pc, #200]	; (800303c <printChar+0x14c>)
		for(j=0;j<((fz)*cfont.y_size);j++) {
			ch = cfont.font[temp];
			for(i=0;i<8;i++) {   
				if((ch&(1<<(7-i)))!=0)   
				{
					lcd7735_pushColor(_fg);
 8002f72:	f8bb 0000 	ldrhmi.w	r0, [fp]
				} 
				else
				{
					lcd7735_pushColor(_bg);
 8002f76:	8818      	ldrhpl	r0, [r3, #0]
 8002f78:	f7ff ff58 	bl	8002e2c <lcd7735_pushColor>
		lcd7735_setAddrWindow(x,y,x+cfont.x_size-1,y+cfont.y_size-1);

		temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
		for(j=0;j<((fz)*cfont.y_size);j++) {
			ch = cfont.font[temp];
			for(i=0;i<8;i++) {   
 8002f7c:	f119 39ff 	adds.w	r9, r9, #4294967295
 8002f80:	d2f2      	bcs.n	8002f68 <printChar+0x78>
 8002f82:	f108 0801 	add.w	r8, r8, #1
 8002f86:	e7de      	b.n	8002f46 <printChar+0x56>
				}   
			}
			temp++;
		}
	} else {
		temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
 8002f88:	79a8      	ldrb	r0, [r5, #6]
 8002f8a:	b2b3      	uxth	r3, r6
 8002f8c:	1a20      	subs	r0, r4, r0
 8002f8e:	9301      	str	r3, [sp, #4]
 8002f90:	796c      	ldrb	r4, [r5, #5]
 8002f92:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 8002f96:	fb14 f400 	smulbb	r4, r4, r0
 8002f9a:	fb14 f403 	smulbb	r4, r4, r3
			for (zz=0; zz<(fz); zz++)
			{
				ch = cfont.font[temp+zz]; 
				for(i=0;i<8;i++)
				{   
					lcd7735_setAddrWindow(x+i+(zz*8),y+j,x+i+(zz*8)+1,y+j+1);
 8002f9e:	b2d3      	uxtb	r3, r2
				}   
			}
			temp++;
		}
	} else {
		temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
 8002fa0:	3404      	adds	r4, #4
			for (zz=0; zz<(fz); zz++)
			{
				ch = cfont.font[temp+zz]; 
				for(i=0;i<8;i++)
				{   
					lcd7735_setAddrWindow(x+i+(zz*8),y+j,x+i+(zz*8)+1,y+j+1);
 8002fa2:	9302      	str	r3, [sp, #8]
 8002fa4:	3301      	adds	r3, #1
				}   
			}
			temp++;
		}
	} else {
		temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
 8002fa6:	b2a4      	uxth	r4, r4
		for(j=0;j<cfont.y_size;j++) 
 8002fa8:	f04f 0900 	mov.w	r9, #0
			for (zz=0; zz<(fz); zz++)
			{
				ch = cfont.font[temp+zz]; 
				for(i=0;i<8;i++)
				{   
					lcd7735_setAddrWindow(x+i+(zz*8),y+j,x+i+(zz*8)+1,y+j+1);
 8002fac:	9305      	str	r3, [sp, #20]
			}
			temp++;
		}
	} else {
		temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
		for(j=0;j<cfont.y_size;j++) 
 8002fae:	4b21      	ldr	r3, [pc, #132]	; (8003034 <printChar+0x144>)
 8002fb0:	795a      	ldrb	r2, [r3, #5]
 8002fb2:	fa1f f389 	uxth.w	r3, r9
 8002fb6:	429a      	cmp	r2, r3
 8002fb8:	d938      	bls.n	800302c <printChar+0x13c>
 8002fba:	2500      	movs	r5, #0
		{
			for (zz=0; zz<(fz); zz++)
 8002fbc:	42b5      	cmp	r5, r6
 8002fbe:	da2f      	bge.n	8003020 <printChar+0x130>
			{
				ch = cfont.font[temp+zz]; 
 8002fc0:	4b1c      	ldr	r3, [pc, #112]	; (8003034 <printChar+0x144>)
 8002fc2:	681b      	ldr	r3, [r3, #0]
 8002fc4:	4423      	add	r3, r4
 8002fc6:	fa5f fb89 	uxtb.w	fp, r9
 8002fca:	5d5b      	ldrb	r3, [r3, r5]
 8002fcc:	9303      	str	r3, [sp, #12]
				for(i=0;i<8;i++)
				{   
					lcd7735_setAddrWindow(x+i+(zz*8),y+j,x+i+(zz*8)+1,y+j+1);
 8002fce:	9b05      	ldr	r3, [sp, #20]
 8002fd0:	445b      	add	r3, fp
 8002fd2:	eb07 0ac5 	add.w	sl, r7, r5, lsl #3
 8002fd6:	b2db      	uxtb	r3, r3
 8002fd8:	fa5f fa8a 	uxtb.w	sl, sl
 8002fdc:	f04f 0807 	mov.w	r8, #7
 8002fe0:	9304      	str	r3, [sp, #16]
 8002fe2:	9b02      	ldr	r3, [sp, #8]
 8002fe4:	fa5f f088 	uxtb.w	r0, r8
 8002fe8:	eb03 010b 	add.w	r1, r3, fp
 8002fec:	f10a 0208 	add.w	r2, sl, #8
 8002ff0:	f10a 0307 	add.w	r3, sl, #7
 8002ff4:	1a12      	subs	r2, r2, r0
 8002ff6:	1a18      	subs	r0, r3, r0
 8002ff8:	b2d2      	uxtb	r2, r2
 8002ffa:	9b04      	ldr	r3, [sp, #16]
 8002ffc:	b2c9      	uxtb	r1, r1
 8002ffe:	b2c0      	uxtb	r0, r0
 8003000:	f7ff fedc 	bl	8002dbc <lcd7735_setAddrWindow>

					if((ch&(1<<(7-i)))!=0)   
 8003004:	9b03      	ldr	r3, [sp, #12]
 8003006:	fa43 f308 	asr.w	r3, r3, r8
 800300a:	07db      	lsls	r3, r3, #31
 800300c:	d503      	bpl.n	8003016 <printChar+0x126>
					{
						lcd7735_pushColor(_fg);
 800300e:	4b0c      	ldr	r3, [pc, #48]	; (8003040 <printChar+0x150>)
 8003010:	8818      	ldrh	r0, [r3, #0]
 8003012:	f7ff ff0b 	bl	8002e2c <lcd7735_pushColor>
		for(j=0;j<cfont.y_size;j++) 
		{
			for (zz=0; zz<(fz); zz++)
			{
				ch = cfont.font[temp+zz]; 
				for(i=0;i<8;i++)
 8003016:	f118 38ff 	adds.w	r8, r8, #4294967295
 800301a:	d2e2      	bcs.n	8002fe2 <printChar+0xf2>
		}
	} else {
		temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
		for(j=0;j<cfont.y_size;j++) 
		{
			for (zz=0; zz<(fz); zz++)
 800301c:	3501      	adds	r5, #1
 800301e:	e7cd      	b.n	8002fbc <printChar+0xcc>
					{
						lcd7735_pushColor(_fg);
					} 
				}
			}
			temp+=(fz);
 8003020:	9b01      	ldr	r3, [sp, #4]
 8003022:	441c      	add	r4, r3
 8003024:	b2a4      	uxth	r4, r4
 8003026:	f109 0901 	add.w	r9, r9, #1
 800302a:	e7c0      	b.n	8002fae <printChar+0xbe>
		}
	}
}
 800302c:	b007      	add	sp, #28
 800302e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003032:	bf00      	nop
 8003034:	20000130 	.word	0x20000130
 8003038:	20000144 	.word	0x20000144
 800303c:	2000013c 	.word	0x2000013c
 8003040:	20000004 	.word	0x20000004
 8003044:	00000000 	.word	0x00000000

08003048 <rotateChar>:

void rotateChar(uint8_t c, int x, int y, int pos, int deg) {
 8003048:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800304c:	ed2d 8b02 	vpush	{d8}
 8003050:	b091      	sub	sp, #68	; 0x44
 8003052:	4604      	mov	r4, r0
	uint8_t i,j,ch,fz;
	uint16_t temp; 
	int newx,newy;
	double radian = deg*0.0175;
 8003054:	981c      	ldr	r0, [sp, #112]	; 0x70
			temp+=(fz);
		}
	}
}

void rotateChar(uint8_t c, int x, int y, int pos, int deg) {
 8003056:	920e      	str	r2, [sp, #56]	; 0x38
 8003058:	930f      	str	r3, [sp, #60]	; 0x3c
 800305a:	910d      	str	r1, [sp, #52]	; 0x34
	uint8_t i,j,ch,fz;
	uint16_t temp; 
	int newx,newy;
	double radian = deg*0.0175;
 800305c:	f7fd fa62 	bl	8000524 <__aeabi_i2d>
 8003060:	a35f      	add	r3, pc, #380	; (adr r3, 80031e0 <rotateChar+0x198>)
 8003062:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003066:	f7fd fac3 	bl	80005f0 <__aeabi_dmul>
	int zz;

	if( cfont.x_size < 8 ) 
 800306a:	4b59      	ldr	r3, [pc, #356]	; (80031d0 <rotateChar+0x188>)
		fz = cfont.x_size;
	else
		fz = cfont.x_size/8;	
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
	for(j=0;j<cfont.y_size;j++) {
 800306c:	4f58      	ldr	r7, [pc, #352]	; (80031d0 <rotateChar+0x188>)
	uint16_t temp; 
	int newx,newy;
	double radian = deg*0.0175;
	int zz;

	if( cfont.x_size < 8 ) 
 800306e:	791d      	ldrb	r5, [r3, #4]
 8003070:	2d07      	cmp	r5, #7
		fz = cfont.x_size;
	else
		fz = cfont.x_size/8;	
 8003072:	bf88      	it	hi
 8003074:	08ed      	lsrhi	r5, r5, #3
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
 8003076:	b2aa      	uxth	r2, r5
 8003078:	9204      	str	r2, [sp, #16]
 800307a:	799a      	ldrb	r2, [r3, #6]
 800307c:	795b      	ldrb	r3, [r3, #5]
 800307e:	1aa4      	subs	r4, r4, r2
 8003080:	fb13 f404 	smulbb	r4, r3, r4
 8003084:	f8bd 3010 	ldrh.w	r3, [sp, #16]
 8003088:	fb14 f403 	smulbb	r4, r4, r3
 800308c:	3404      	adds	r4, #4

void rotateChar(uint8_t c, int x, int y, int pos, int deg) {
	uint8_t i,j,ch,fz;
	uint16_t temp; 
	int newx,newy;
	double radian = deg*0.0175;
 800308e:	ec41 0b18 	vmov	d8, r0, r1

	if( cfont.x_size < 8 ) 
		fz = cfont.x_size;
	else
		fz = cfont.x_size/8;	
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
 8003092:	fa1f fb84 	uxth.w	fp, r4
	for(j=0;j<cfont.y_size;j++) {
 8003096:	f04f 0a00 	mov.w	sl, #0
 800309a:	797a      	ldrb	r2, [r7, #5]
 800309c:	fa5f f38a 	uxtb.w	r3, sl
 80030a0:	429a      	cmp	r2, r3
 80030a2:	f240 808e 	bls.w	80031c2 <rotateChar+0x17a>
 80030a6:	2400      	movs	r4, #0
		for (zz=0; zz<(fz); zz++) {
 80030a8:	42ac      	cmp	r4, r5
 80030aa:	f280 8083 	bge.w	80031b4 <rotateChar+0x16c>
			ch = cfont.font[temp+zz]; 
			for(i=0;i<8;i++) {   
				newx=x+(((i+(zz*8)+(pos*cfont.x_size))*cos(radian))-((j)*sin(radian)));
 80030ae:	eeb0 0a48 	vmov.f32	s0, s16
 80030b2:	eef0 0a68 	vmov.f32	s1, s17
	else
		fz = cfont.x_size/8;	
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
	for(j=0;j<cfont.y_size;j++) {
		for (zz=0; zz<(fz); zz++) {
			ch = cfont.font[temp+zz]; 
 80030b6:	683b      	ldr	r3, [r7, #0]
 80030b8:	445b      	add	r3, fp
			for(i=0;i<8;i++) {   
				newx=x+(((i+(zz*8)+(pos*cfont.x_size))*cos(radian))-((j)*sin(radian)));
				newy=y+(((j)*cos(radian))+((i+(zz*8)+(pos*cfont.x_size))*sin(radian)));
 80030ba:	2600      	movs	r6, #0
	else
		fz = cfont.x_size/8;	
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
	for(j=0;j<cfont.y_size;j++) {
		for (zz=0; zz<(fz); zz++) {
			ch = cfont.font[temp+zz]; 
 80030bc:	5d1b      	ldrb	r3, [r3, r4]
 80030be:	9305      	str	r3, [sp, #20]
			for(i=0;i<8;i++) {   
				newx=x+(((i+(zz*8)+(pos*cfont.x_size))*cos(radian))-((j)*sin(radian)));
 80030c0:	f002 f886 	bl	80051d0 <cos>
 80030c4:	fa5f f08a 	uxtb.w	r0, sl
 80030c8:	ed8d 0b00 	vstr	d0, [sp]
 80030cc:	f7fd fa2a 	bl	8000524 <__aeabi_i2d>
 80030d0:	eeb0 0a48 	vmov.f32	s0, s16
 80030d4:	eef0 0a68 	vmov.f32	s1, s17
 80030d8:	4680      	mov	r8, r0
 80030da:	4689      	mov	r9, r1
 80030dc:	f002 f8bc 	bl	8005258 <sin>
 80030e0:	4640      	mov	r0, r8
 80030e2:	ec53 2b10 	vmov	r2, r3, d0
 80030e6:	4649      	mov	r1, r9
 80030e8:	ed8d 0b02 	vstr	d0, [sp, #8]
 80030ec:	f7fd fa80 	bl	80005f0 <__aeabi_dmul>
				newy=y+(((j)*cos(radian))+((i+(zz*8)+(pos*cfont.x_size))*sin(radian)));
 80030f0:	464b      	mov	r3, r9
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
	for(j=0;j<cfont.y_size;j++) {
		for (zz=0; zz<(fz); zz++) {
			ch = cfont.font[temp+zz]; 
			for(i=0;i<8;i++) {   
				newx=x+(((i+(zz*8)+(pos*cfont.x_size))*cos(radian))-((j)*sin(radian)));
 80030f2:	e9cd 0108 	strd	r0, r1, [sp, #32]
				newy=y+(((j)*cos(radian))+((i+(zz*8)+(pos*cfont.x_size))*sin(radian)));
 80030f6:	4642      	mov	r2, r8
 80030f8:	e9dd 0100 	ldrd	r0, r1, [sp]
 80030fc:	f7fd fa78 	bl	80005f0 <__aeabi_dmul>
 8003100:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
 8003104:	00e3      	lsls	r3, r4, #3
 8003106:	930c      	str	r3, [sp, #48]	; 0x30
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
	for(j=0;j<cfont.y_size;j++) {
		for (zz=0; zz<(fz); zz++) {
			ch = cfont.font[temp+zz]; 
			for(i=0;i<8;i++) {   
				newx=x+(((i+(zz*8)+(pos*cfont.x_size))*cos(radian))-((j)*sin(radian)));
 8003108:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800310a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800310c:	7938      	ldrb	r0, [r7, #4]
 800310e:	18f3      	adds	r3, r6, r3
 8003110:	fb02 3000 	mla	r0, r2, r0, r3
 8003114:	f7fd fa06 	bl	8000524 <__aeabi_i2d>
				newy=y+(((j)*cos(radian))+((i+(zz*8)+(pos*cfont.x_size))*sin(radian)));

				lcd7735_setAddrWindow(newx,newy,newx+1,newy+1);
 8003118:	e9dd 2300 	ldrd	r2, r3, [sp]
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
	for(j=0;j<cfont.y_size;j++) {
		for (zz=0; zz<(fz); zz++) {
			ch = cfont.font[temp+zz]; 
			for(i=0;i<8;i++) {   
				newx=x+(((i+(zz*8)+(pos*cfont.x_size))*cos(radian))-((j)*sin(radian)));
 800311c:	e9cd 0106 	strd	r0, r1, [sp, #24]
				newy=y+(((j)*cos(radian))+((i+(zz*8)+(pos*cfont.x_size))*sin(radian)));

				lcd7735_setAddrWindow(newx,newy,newx+1,newy+1);
 8003120:	f7fd fa66 	bl	80005f0 <__aeabi_dmul>
 8003124:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8003128:	f7fd f8ae 	bl	8000288 <__aeabi_dsub>
 800312c:	4680      	mov	r8, r0
 800312e:	980d      	ldr	r0, [sp, #52]	; 0x34
 8003130:	4689      	mov	r9, r1
 8003132:	f7fd f9f7 	bl	8000524 <__aeabi_i2d>
 8003136:	4602      	mov	r2, r0
 8003138:	460b      	mov	r3, r1
 800313a:	4640      	mov	r0, r8
 800313c:	4649      	mov	r1, r9
 800313e:	f7fd f8a5 	bl	800028c <__adddf3>
 8003142:	f7fd fcef 	bl	8000b24 <__aeabi_d2iz>
 8003146:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800314a:	fa5f f880 	uxtb.w	r8, r0
 800314e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8003152:	f7fd fa4d 	bl	80005f0 <__aeabi_dmul>
 8003156:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 800315a:	f7fd f897 	bl	800028c <__adddf3>
 800315e:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8003162:	980e      	ldr	r0, [sp, #56]	; 0x38
 8003164:	f7fd f9de 	bl	8000524 <__aeabi_i2d>
 8003168:	4602      	mov	r2, r0
 800316a:	460b      	mov	r3, r1
 800316c:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8003170:	f7fd f88c 	bl	800028c <__adddf3>
 8003174:	f7fd fcd6 	bl	8000b24 <__aeabi_d2iz>
 8003178:	b2c1      	uxtb	r1, r0
 800317a:	1c4b      	adds	r3, r1, #1
 800317c:	f108 0201 	add.w	r2, r8, #1
 8003180:	b2db      	uxtb	r3, r3
 8003182:	b2d2      	uxtb	r2, r2
 8003184:	4640      	mov	r0, r8
 8003186:	f7ff fe19 	bl	8002dbc <lcd7735_setAddrWindow>

				if((ch&(1<<(7-i)))!=0) {
 800318a:	9a05      	ldr	r2, [sp, #20]
 800318c:	f1c6 0307 	rsb	r3, r6, #7
 8003190:	fa42 f303 	asr.w	r3, r2, r3
 8003194:	07db      	lsls	r3, r3, #31
 8003196:	d501      	bpl.n	800319c <rotateChar+0x154>
					lcd7735_pushColor(_fg);
 8003198:	4b0e      	ldr	r3, [pc, #56]	; (80031d4 <rotateChar+0x18c>)
 800319a:	e003      	b.n	80031a4 <rotateChar+0x15c>
				} else  {
					if (!_transparent)
 800319c:	4b0e      	ldr	r3, [pc, #56]	; (80031d8 <rotateChar+0x190>)
 800319e:	781b      	ldrb	r3, [r3, #0]
 80031a0:	b91b      	cbnz	r3, 80031aa <rotateChar+0x162>
						lcd7735_pushColor(_bg);
 80031a2:	4b0e      	ldr	r3, [pc, #56]	; (80031dc <rotateChar+0x194>)
 80031a4:	8818      	ldrh	r0, [r3, #0]
 80031a6:	f7ff fe41 	bl	8002e2c <lcd7735_pushColor>
 80031aa:	3601      	adds	r6, #1
		fz = cfont.x_size/8;	
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
	for(j=0;j<cfont.y_size;j++) {
		for (zz=0; zz<(fz); zz++) {
			ch = cfont.font[temp+zz]; 
			for(i=0;i<8;i++) {   
 80031ac:	2e08      	cmp	r6, #8
 80031ae:	d1ab      	bne.n	8003108 <rotateChar+0xc0>
		fz = cfont.x_size;
	else
		fz = cfont.x_size/8;	
	temp=((c-cfont.offset)*((fz)*cfont.y_size))+4;
	for(j=0;j<cfont.y_size;j++) {
		for (zz=0; zz<(fz); zz++) {
 80031b0:	3401      	adds	r4, #1
 80031b2:	e779      	b.n	80030a8 <rotateChar+0x60>
					if (!_transparent)
						lcd7735_pushColor(_bg);
				}   
			}
		}
		temp+=(fz);
 80031b4:	9b04      	ldr	r3, [sp, #16]
 80031b6:	445b      	add	r3, fp
 80031b8:	fa1f fb83 	uxth.w	fp, r3
 80031bc:	f10a 0a01 	add.w	sl, sl, #1
 80031c0:	e76b      	b.n	800309a <rotateChar+0x52>
	}
}
 80031c2:	b011      	add	sp, #68	; 0x44
 80031c4:	ecbd 8b02 	vpop	{d8}
 80031c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80031cc:	f3af 8000 	nop.w
 80031d0:	20000130 	.word	0x20000130
 80031d4:	20000004 	.word	0x20000004
 80031d8:	20000144 	.word	0x20000144
 80031dc:	2000013c 	.word	0x2000013c
 80031e0:	1eb851ec 	.word	0x1eb851ec
 80031e4:	3f91eb85 	.word	0x3f91eb85

080031e8 <lcd7735_print>:

void lcd7735_print(char *st, int x, int y, int deg) {
 80031e8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 80031ec:	460c      	mov	r4, r1
 80031ee:	4690      	mov	r8, r2
 80031f0:	4606      	mov	r6, r0
 80031f2:	4699      	mov	r9, r3
	int stl, i;

	stl = strlen(st);
 80031f4:	f7fc ffec 	bl	80001d0 <strlen>

	if (x==RIGHT)
 80031f8:	1ca2      	adds	r2, r4, #2
}

void lcd7735_print(char *st, int x, int y, int deg) {
	int stl, i;

	stl = strlen(st);
 80031fa:	4607      	mov	r7, r0

	if (x==RIGHT)
 80031fc:	d106      	bne.n	800320c <lcd7735_print+0x24>
		x=(_width+1)-(stl*cfont.x_size);
 80031fe:	4b1a      	ldr	r3, [pc, #104]	; (8003268 <lcd7735_print+0x80>)
 8003200:	4a1a      	ldr	r2, [pc, #104]	; (800326c <lcd7735_print+0x84>)
 8003202:	881c      	ldrh	r4, [r3, #0]
 8003204:	1c63      	adds	r3, r4, #1
 8003206:	7914      	ldrb	r4, [r2, #4]
 8003208:	fb00 3414 	mls	r4, r0, r4, r3
	if (x==CENTER)
 800320c:	1c63      	adds	r3, r4, #1
 800320e:	d109      	bne.n	8003224 <lcd7735_print+0x3c>
		x=((_height+1)-(stl*cfont.x_size))/2;
 8003210:	4b17      	ldr	r3, [pc, #92]	; (8003270 <lcd7735_print+0x88>)
 8003212:	881c      	ldrh	r4, [r3, #0]
 8003214:	4b15      	ldr	r3, [pc, #84]	; (800326c <lcd7735_print+0x84>)
 8003216:	791b      	ldrb	r3, [r3, #4]
 8003218:	3401      	adds	r4, #1
 800321a:	fb07 4313 	mls	r3, r7, r3, r4
 800321e:	2402      	movs	r4, #2
 8003220:	fb93 f4f4 	sdiv	r4, r3, r4

	for (i=0; i<stl; i++)
		if (deg==0)
			printChar(*st++, x + (i*(cfont.x_size)), y);
 8003224:	f8df a044 	ldr.w	sl, [pc, #68]	; 800326c <lcd7735_print+0x84>
 8003228:	3601      	adds	r6, #1
	if (x==RIGHT)
		x=(_width+1)-(stl*cfont.x_size);
	if (x==CENTER)
		x=((_height+1)-(stl*cfont.x_size))/2;

	for (i=0; i<stl; i++)
 800322a:	2500      	movs	r5, #0
 800322c:	42bd      	cmp	r5, r7
 800322e:	da18      	bge.n	8003262 <lcd7735_print+0x7a>
		if (deg==0)
 8003230:	f1b9 0f00 	cmp.w	r9, #0
 8003234:	d109      	bne.n	800324a <lcd7735_print+0x62>
			printChar(*st++, x + (i*(cfont.x_size)), y);
 8003236:	f89a 1004 	ldrb.w	r1, [sl, #4]
 800323a:	f816 0c01 	ldrb.w	r0, [r6, #-1]
 800323e:	4642      	mov	r2, r8
 8003240:	fb05 4101 	mla	r1, r5, r1, r4
 8003244:	f7ff fe54 	bl	8002ef0 <printChar>
 8003248:	e008      	b.n	800325c <lcd7735_print+0x74>
		else
			rotateChar(*st++, x, y, i, deg);
 800324a:	f816 0c01 	ldrb.w	r0, [r6, #-1]
 800324e:	f8cd 9000 	str.w	r9, [sp]
 8003252:	462b      	mov	r3, r5
 8003254:	4642      	mov	r2, r8
 8003256:	4621      	mov	r1, r4
 8003258:	f7ff fef6 	bl	8003048 <rotateChar>
	if (x==RIGHT)
		x=(_width+1)-(stl*cfont.x_size);
	if (x==CENTER)
		x=((_height+1)-(stl*cfont.x_size))/2;

	for (i=0; i<stl; i++)
 800325c:	3501      	adds	r5, #1
 800325e:	3601      	adds	r6, #1
 8003260:	e7e4      	b.n	800322c <lcd7735_print+0x44>
		if (deg==0)
			printChar(*st++, x + (i*(cfont.x_size)), y);
		else
			rotateChar(*st++, x, y, i, deg);
}
 8003262:	b002      	add	sp, #8
 8003264:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8003268:	20000002 	.word	0x20000002
 800326c:	20000130 	.word	0x20000130
 8003270:	20000000 	.word	0x20000000

08003274 <lcd7735_fillScreen>:
*********************************************************************
*********************** Service functions ***************************
*********************************************************************
*********************************************************************/

void lcd7735_fillScreen(uint16_t color) {
 8003274:	b507      	push	{r0, r1, r2, lr}
	lcd7735_fillRect(0, 0,  _width, _height, color);
 8003276:	4b07      	ldr	r3, [pc, #28]	; (8003294 <lcd7735_fillScreen+0x20>)
 8003278:	4a07      	ldr	r2, [pc, #28]	; (8003298 <lcd7735_fillScreen+0x24>)
 800327a:	f9b3 3000 	ldrsh.w	r3, [r3]
 800327e:	f9b2 2000 	ldrsh.w	r2, [r2]
 8003282:	9000      	str	r0, [sp, #0]
 8003284:	2100      	movs	r1, #0
 8003286:	4608      	mov	r0, r1
 8003288:	f7ff fde0 	bl	8002e4c <lcd7735_fillRect>
}
 800328c:	b003      	add	sp, #12
 800328e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003292:	bf00      	nop
 8003294:	20000000 	.word	0x20000000
 8003298:	20000002 	.word	0x20000002

0800329c <lcd7735_setForeground>:
uint8_t lcd7735_getHeight() {
	return(_height);
}

void lcd7735_setForeground(uint16_t s) {
	_fg = s;
 800329c:	4b01      	ldr	r3, [pc, #4]	; (80032a4 <lcd7735_setForeground+0x8>)
 800329e:	8018      	strh	r0, [r3, #0]
 80032a0:	4770      	bx	lr
 80032a2:	bf00      	nop
 80032a4:	20000004 	.word	0x20000004

080032a8 <lcd7735_setTransparent>:
void lcd7735_setBackground(uint16_t s) {
	_bg = s;
}

void lcd7735_setTransparent(uint8_t s) {
	_transparent = s;
 80032a8:	4b01      	ldr	r3, [pc, #4]	; (80032b0 <lcd7735_setTransparent+0x8>)
 80032aa:	7018      	strb	r0, [r3, #0]
 80032ac:	4770      	bx	lr
 80032ae:	bf00      	nop
 80032b0:	20000144 	.word	0x20000144

080032b4 <lcd7735_senddata>:
}

#endif

// Send byte via SPI to controller
void lcd7735_senddata(const uint8_t data) {
 80032b4:	b507      	push	{r0, r1, r2, lr}
	uint8_t tcmd[1];
	tcmd[0] = data;
 80032b6:	a902      	add	r1, sp, #8
	HAL_SPI_Transmit(&hspi1,tcmd,1,1);
 80032b8:	2301      	movs	r3, #1
#endif

// Send byte via SPI to controller
void lcd7735_senddata(const uint8_t data) {
	uint8_t tcmd[1];
	tcmd[0] = data;
 80032ba:	f801 0d04 	strb.w	r0, [r1, #-4]!
	HAL_SPI_Transmit(&hspi1,tcmd,1,1);
 80032be:	461a      	mov	r2, r3
 80032c0:	4802      	ldr	r0, [pc, #8]	; (80032cc <lcd7735_senddata+0x18>)
 80032c2:	f7fe fe9a 	bl	8001ffa <HAL_SPI_Transmit>
//    while(SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET);
//    SPI_SendData(SPI2, data);
}
 80032c6:	b003      	add	sp, #12
 80032c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80032cc:	2000019c 	.word	0x2000019c

080032d0 <lcd7735_sendCmd>:
//    SPI_I2S_SendData(SPI2, data);
}

// Send control command to controller
void lcd7735_sendCmd(const uint8_t cmd) {
    LCD_DC0;
 80032d0:	4b02      	ldr	r3, [pc, #8]	; (80032dc <lcd7735_sendCmd+0xc>)
 80032d2:	2201      	movs	r2, #1
 80032d4:	629a      	str	r2, [r3, #40]	; 0x28
    lcd7735_senddata(cmd);
 80032d6:	f7ff bfed 	b.w	80032b4 <lcd7735_senddata>
 80032da:	bf00      	nop
 80032dc:	48000400 	.word	0x48000400

080032e0 <lcd7735_sendData>:
//    while(SPI2->SR & SPI_SR_BSY);
}

// Send parameters o command to controller
void lcd7735_sendData(const uint8_t data) {
    LCD_DC1;
 80032e0:	4b02      	ldr	r3, [pc, #8]	; (80032ec <lcd7735_sendData+0xc>)
 80032e2:	2201      	movs	r2, #1
 80032e4:	619a      	str	r2, [r3, #24]
    lcd7735_senddata(data);
 80032e6:	f7ff bfe5 	b.w	80032b4 <lcd7735_senddata>
 80032ea:	bf00      	nop
 80032ec:	48000400 	.word	0x48000400

080032f0 <setSoundFrequency>:
//   (and timer 1 prescaler set to divide by 4)
// PARAMETERS    :
//   int16_t frequency - the desired frequency
// RETURNS       :
//   none
void setSoundFrequency(int16_t frequency){
 80032f0:	b538      	push	{r3, r4, r5, lr}
	uint16_t pwmPeriod;
	pwmPeriod = 20000000 / frequency;	// 80MHz / 4 = 20000000
	HAL_TIMEx_PWMN_Stop(&htim1,TIM_CHANNEL_1);
 80032f2:	4d0a      	ldr	r5, [pc, #40]	; (800331c <setSoundFrequency+0x2c>)
//   int16_t frequency - the desired frequency
// RETURNS       :
//   none
void setSoundFrequency(int16_t frequency){
	uint16_t pwmPeriod;
	pwmPeriod = 20000000 / frequency;	// 80MHz / 4 = 20000000
 80032f4:	4c0a      	ldr	r4, [pc, #40]	; (8003320 <setSoundFrequency+0x30>)
 80032f6:	fb94 f4f0 	sdiv	r4, r4, r0
	HAL_TIMEx_PWMN_Stop(&htim1,TIM_CHANNEL_1);
 80032fa:	2100      	movs	r1, #0
 80032fc:	4628      	mov	r0, r5
 80032fe:	f7ff f9b4 	bl	800266a <HAL_TIMEx_PWMN_Stop>
	// duty cycle = 50%
	__HAL_TIM_SET_COMPARE(&htim1,TIM_CHANNEL_1,pwmPeriod/2);
 8003302:	b2a0      	uxth	r0, r4
 8003304:	682b      	ldr	r3, [r5, #0]
	__HAL_TIM_SET_AUTORELOAD(&htim1,pwmPeriod);
 8003306:	60e8      	str	r0, [r5, #12]
void setSoundFrequency(int16_t frequency){
	uint16_t pwmPeriod;
	pwmPeriod = 20000000 / frequency;	// 80MHz / 4 = 20000000
	HAL_TIMEx_PWMN_Stop(&htim1,TIM_CHANNEL_1);
	// duty cycle = 50%
	__HAL_TIM_SET_COMPARE(&htim1,TIM_CHANNEL_1,pwmPeriod/2);
 8003308:	0842      	lsrs	r2, r0, #1
 800330a:	635a      	str	r2, [r3, #52]	; 0x34
	__HAL_TIM_SET_AUTORELOAD(&htim1,pwmPeriod);
	HAL_TIMEx_PWMN_Start(&htim1,TIM_CHANNEL_1);
 800330c:	2100      	movs	r1, #0
	uint16_t pwmPeriod;
	pwmPeriod = 20000000 / frequency;	// 80MHz / 4 = 20000000
	HAL_TIMEx_PWMN_Stop(&htim1,TIM_CHANNEL_1);
	// duty cycle = 50%
	__HAL_TIM_SET_COMPARE(&htim1,TIM_CHANNEL_1,pwmPeriod/2);
	__HAL_TIM_SET_AUTORELOAD(&htim1,pwmPeriod);
 800330e:	62d8      	str	r0, [r3, #44]	; 0x2c
	HAL_TIMEx_PWMN_Start(&htim1,TIM_CHANNEL_1);
 8003310:	4628      	mov	r0, r5
}
 8003312:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	pwmPeriod = 20000000 / frequency;	// 80MHz / 4 = 20000000
	HAL_TIMEx_PWMN_Stop(&htim1,TIM_CHANNEL_1);
	// duty cycle = 50%
	__HAL_TIM_SET_COMPARE(&htim1,TIM_CHANNEL_1,pwmPeriod/2);
	__HAL_TIM_SET_AUTORELOAD(&htim1,pwmPeriod);
	HAL_TIMEx_PWMN_Start(&htim1,TIM_CHANNEL_1);
 8003316:	f7ff b972 	b.w	80025fe <HAL_TIMEx_PWMN_Start>
 800331a:	bf00      	nop
 800331c:	20000160 	.word	0x20000160
 8003320:	01312d00 	.word	0x01312d00

08003324 <startLEDPWMs>:
//   (TIM2 channels 1, 2 and 4)
// PARAMETERS    :
//   none
// RETURNS       :
//   none
void startLEDPWMs() {
 8003324:	b510      	push	{r4, lr}
	HAL_TIM_PWM_Start(&htim2,TIM_CHANNEL_1);
 8003326:	4c07      	ldr	r4, [pc, #28]	; (8003344 <startLEDPWMs+0x20>)
 8003328:	2100      	movs	r1, #0
 800332a:	4620      	mov	r0, r4
 800332c:	f7ff f93c 	bl	80025a8 <HAL_TIM_PWM_Start>
	HAL_TIM_PWM_Start(&htim2,TIM_CHANNEL_2);
 8003330:	2104      	movs	r1, #4
 8003332:	4620      	mov	r0, r4
 8003334:	f7ff f938 	bl	80025a8 <HAL_TIM_PWM_Start>
	HAL_TIM_PWM_Start(&htim2,TIM_CHANNEL_4);
 8003338:	4620      	mov	r0, r4
 800333a:	210c      	movs	r1, #12
}
 800333c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
// RETURNS       :
//   none
void startLEDPWMs() {
	HAL_TIM_PWM_Start(&htim2,TIM_CHANNEL_1);
	HAL_TIM_PWM_Start(&htim2,TIM_CHANNEL_2);
	HAL_TIM_PWM_Start(&htim2,TIM_CHANNEL_4);
 8003340:	f7ff b932 	b.w	80025a8 <HAL_TIM_PWM_Start>
 8003344:	20000200 	.word	0x20000200

08003348 <isPasswordOk>:
//   Verifies if the input password is within the allowed passwords
// PARAMETERS    :
//   char *password - a pointer to a character string
// RETURNS       :
//   uint8_t - 1 if password is ok, 0 if password is invalid
uint8_t isPasswordOk(char *password) {
 8003348:	b530      	push	{r4, r5, lr}
	uint8_t passwordIndex = 0;
	uint8_t charIndex = 0;
 800334a:	2300      	movs	r3, #0
	while (1){
		// if the first character is null, we have searched the whole array
		if (passwordArray[passwordIndex][charIndex] == 0) {
 800334c:	4c0a      	ldr	r4, [pc, #40]	; (8003378 <isPasswordOk+0x30>)
// PARAMETERS    :
//   char *password - a pointer to a character string
// RETURNS       :
//   uint8_t - 1 if password is ok, 0 if password is invalid
uint8_t isPasswordOk(char *password) {
	uint8_t passwordIndex = 0;
 800334e:	4619      	mov	r1, r3
	uint8_t charIndex = 0;
	while (1){
		// if the first character is null, we have searched the whole array
		if (passwordArray[passwordIndex][charIndex] == 0) {
 8003350:	f854 2021 	ldr.w	r2, [r4, r1, lsl #2]
 8003354:	5cd2      	ldrb	r2, [r2, r3]
 8003356:	b15a      	cbz	r2, 8003370 <isPasswordOk+0x28>
			break;
		}
		// check each password character against the array
		if (password[charIndex] == passwordArray[passwordIndex][charIndex]){
 8003358:	5cc5      	ldrb	r5, [r0, r3]
 800335a:	4295      	cmp	r5, r2
 800335c:	d104      	bne.n	8003368 <isPasswordOk+0x20>
			// characters are the same
			if (charIndex == 3) {	// it is the last (4th) character
 800335e:	2b03      	cmp	r3, #3
 8003360:	d008      	beq.n	8003374 <isPasswordOk+0x2c>
				return 1;	// we reached the last character, password was found!
			}
			charIndex++;	// go to next character in the string
 8003362:	3301      	adds	r3, #1
 8003364:	b2db      	uxtb	r3, r3
 8003366:	e7f3      	b.n	8003350 <isPasswordOk+0x8>
		} else {
			// characters do not match
			charIndex = 0;
			passwordIndex++;
 8003368:	3101      	adds	r1, #1
 800336a:	b2c9      	uxtb	r1, r1
				return 1;	// we reached the last character, password was found!
			}
			charIndex++;	// go to next character in the string
		} else {
			// characters do not match
			charIndex = 0;
 800336c:	2300      	movs	r3, #0
 800336e:	e7ef      	b.n	8003350 <isPasswordOk+0x8>
			passwordIndex++;
		}
	}
	return 0;
 8003370:	4610      	mov	r0, r2
 8003372:	bd30      	pop	{r4, r5, pc}
		}
		// check each password character against the array
		if (password[charIndex] == passwordArray[passwordIndex][charIndex]){
			// characters are the same
			if (charIndex == 3) {	// it is the last (4th) character
				return 1;	// we reached the last character, password was found!
 8003374:	2001      	movs	r0, #1
			charIndex = 0;
			passwordIndex++;
		}
	}
	return 0;
}
 8003376:	bd30      	pop	{r4, r5, pc}
 8003378:	2000007c 	.word	0x2000007c

0800337c <SystemClock_Config>:
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 800337c:	b510      	push	{r4, lr}
 800337e:	b0ac      	sub	sp, #176	; 0xb0
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8003380:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003384:	9309      	str	r3, [sp, #36]	; 0x24
  RCC_OscInitStruct.HSICalibrationValue = 16;
 8003386:	2310      	movs	r3, #16
 8003388:	930a      	str	r3, [sp, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 2;
  RCC_OscInitStruct.PLL.PLLN = 20;
 800338a:	2314      	movs	r3, #20
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 800338c:	2402      	movs	r4, #2
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 2;
  RCC_OscInitStruct.PLL.PLLN = 20;
 800338e:	9313      	str	r3, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8003390:	a806      	add	r0, sp, #24
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 2;
  RCC_OscInitStruct.PLL.PLLN = 20;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
 8003392:	2307      	movs	r3, #7
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8003394:	9406      	str	r4, [sp, #24]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8003396:	9410      	str	r4, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 8003398:	9411      	str	r4, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLM = 2;
 800339a:	9412      	str	r4, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLN = 20;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
 800339c:	9314      	str	r3, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
 800339e:	9415      	str	r4, [sp, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 80033a0:	9416      	str	r4, [sp, #88]	; 0x58
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80033a2:	f7fd fffd 	bl	80013a0 <HAL_RCC_OscConfig>
 80033a6:	b100      	cbz	r0, 80033aa <SystemClock_Config+0x2e>
 80033a8:	e7fe      	b.n	80033a8 <SystemClock_Config+0x2c>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80033aa:	230f      	movs	r3, #15
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80033ac:	2104      	movs	r1, #4
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80033ae:	9301      	str	r3, [sp, #4]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80033b0:	9003      	str	r0, [sp, #12]

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80033b2:	2303      	movs	r3, #3
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 80033b4:	9004      	str	r0, [sp, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80033b6:	9005      	str	r0, [sp, #20]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80033b8:	eb0d 0001 	add.w	r0, sp, r1

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80033bc:	9302      	str	r3, [sp, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80033be:	f7fe fa61 	bl	8001884 <HAL_RCC_ClockConfig>
 80033c2:	b100      	cbz	r0, 80033c6 <SystemClock_Config+0x4a>
 80033c4:	e7fe      	b.n	80033c4 <SystemClock_Config+0x48>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
  PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
 80033c6:	9020      	str	r0, [sp, #128]	; 0x80
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 80033c8:	a817      	add	r0, sp, #92	; 0x5c
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 80033ca:	9417      	str	r4, [sp, #92]	; 0x5c
  PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 80033cc:	f7fe fc00 	bl	8001bd0 <HAL_RCCEx_PeriphCLKConfig>
 80033d0:	b100      	cbz	r0, 80033d4 <SystemClock_Config+0x58>
 80033d2:	e7fe      	b.n	80033d2 <SystemClock_Config+0x56>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Configure the main internal regulator output voltage 
    */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
 80033d4:	f44f 7000 	mov.w	r0, #512	; 0x200
 80033d8:	f7fd fecc 	bl	8001174 <HAL_PWREx_ControlVoltageScaling>
 80033dc:	4604      	mov	r4, r0
 80033de:	b100      	cbz	r0, 80033e2 <SystemClock_Config+0x66>
 80033e0:	e7fe      	b.n	80033e0 <SystemClock_Config+0x64>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Configure the Systick interrupt time 
    */
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 80033e2:	f7fe fb07 	bl	80019f4 <HAL_RCC_GetHCLKFreq>
 80033e6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80033ea:	fbb0 f0f3 	udiv	r0, r0, r3
 80033ee:	f7fd fdcf 	bl	8000f90 <HAL_SYSTICK_Config>

    /**Configure the Systick 
    */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 80033f2:	2004      	movs	r0, #4
 80033f4:	f7fd fde2 	bl	8000fbc <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 80033f8:	4622      	mov	r2, r4
 80033fa:	4621      	mov	r1, r4
 80033fc:	f04f 30ff 	mov.w	r0, #4294967295
 8003400:	f7fd fd92 	bl	8000f28 <HAL_NVIC_SetPriority>
}
 8003404:	b02c      	add	sp, #176	; 0xb0
 8003406:	bd10      	pop	{r4, pc}

08003408 <main>:
	return 0;
}
/* USER CODE END 0 */

int main(void)
{
 8003408:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800340c:	b09d      	sub	sp, #116	; 0x74
  /* USER CODE END 1 */

  /* MCU Configuration----------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 800340e:	f7fd fd51 	bl	8000eb4 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 8003412:	f7ff ffb3 	bl	800337c <SystemClock_Config>
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8003416:	4b9e      	ldr	r3, [pc, #632]	; (8003690 <main+0x288>)
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4, GPIO_PIN_RESET);
 8003418:	489e      	ldr	r0, [pc, #632]	; (8003694 <main+0x28c>)
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800341a:	6cda      	ldr	r2, [r3, #76]	; 0x4c

/* USART2 init function */
static void MX_USART2_UART_Init(void)
{

  huart2.Instance = USART2;
 800341c:	4c9e      	ldr	r4, [pc, #632]	; (8003698 <main+0x290>)
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800341e:	f042 0204 	orr.w	r2, r2, #4
 8003422:	64da      	str	r2, [r3, #76]	; 0x4c
 8003424:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8003426:	f002 0204 	and.w	r2, r2, #4
 800342a:	9204      	str	r2, [sp, #16]
 800342c:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800342e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8003430:	f042 0201 	orr.w	r2, r2, #1
 8003434:	64da      	str	r2, [r3, #76]	; 0x4c
 8003436:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8003438:	f002 0201 	and.w	r2, r2, #1
 800343c:	9205      	str	r2, [sp, #20]
 800343e:	9a05      	ldr	r2, [sp, #20]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8003440:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8003442:	f042 0202 	orr.w	r2, r2, #2
 8003446:	64da      	str	r2, [r3, #76]	; 0x4c
 8003448:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800344a:	f003 0302 	and.w	r3, r3, #2

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4, GPIO_PIN_RESET);
 800344e:	2200      	movs	r2, #0
  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8003450:	9306      	str	r3, [sp, #24]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4, GPIO_PIN_RESET);
 8003452:	2113      	movs	r1, #19
  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8003454:	9b06      	ldr	r3, [sp, #24]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4, GPIO_PIN_RESET);
 8003456:	f7fd fe7f 	bl	8001158 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PB0 PB1 PB4 */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4;
 800345a:	2313      	movs	r3, #19
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800345c:	2500      	movs	r5, #0

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4, GPIO_PIN_RESET);

  /*Configure GPIO pins : PB0 PB1 PB4 */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4;
 800345e:	9311      	str	r3, [sp, #68]	; 0x44
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8003460:	a911      	add	r1, sp, #68	; 0x44
  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4, GPIO_PIN_RESET);

  /*Configure GPIO pins : PB0 PB1 PB4 */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8003462:	2301      	movs	r3, #1
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8003464:	488b      	ldr	r0, [pc, #556]	; (8003694 <main+0x28c>)
  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4, GPIO_PIN_RESET);

  /*Configure GPIO pins : PB0 PB1 PB4 */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8003466:	9312      	str	r3, [sp, #72]	; 0x48
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8003468:	f04f 0803 	mov.w	r8, #3
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4, GPIO_PIN_RESET);

  /*Configure GPIO pins : PB0 PB1 PB4 */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800346c:	9513      	str	r5, [sp, #76]	; 0x4c
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800346e:	f8cd 8050 	str.w	r8, [sp, #80]	; 0x50
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8003472:	f7fd fdb5 	bl	8000fe0 <HAL_GPIO_Init>
/* USART2 init function */
static void MX_USART2_UART_Init(void)
{

  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
 8003476:	4b89      	ldr	r3, [pc, #548]	; (800369c <main+0x294>)
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8003478:	60a5      	str	r5, [r4, #8]
/* USART2 init function */
static void MX_USART2_UART_Init(void)
{

  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
 800347a:	f44f 37e1 	mov.w	r7, #115200	; 0x1c200
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
 800347e:	260c      	movs	r6, #12
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8003480:	4620      	mov	r0, r4
{

  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
 8003482:	60e5      	str	r5, [r4, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 8003484:	6125      	str	r5, [r4, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8003486:	61a5      	str	r5, [r4, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8003488:	61e5      	str	r5, [r4, #28]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800348a:	6225      	str	r5, [r4, #32]
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800348c:	6265      	str	r5, [r4, #36]	; 0x24
/* USART2 init function */
static void MX_USART2_UART_Init(void)
{

  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
 800348e:	e884 0088 	stmia.w	r4, {r3, r7}
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
 8003492:	6166      	str	r6, [r4, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8003494:	f7ff fbe7 	bl	8002c66 <HAL_UART_Init>
 8003498:	4625      	mov	r5, r4
 800349a:	b100      	cbz	r0, 800349e <main+0x96>
 800349c:	e7fe      	b.n	800349c <main+0x94>
{

  TIM_MasterConfigTypeDef sMasterConfig;
  TIM_OC_InitTypeDef sConfigOC;

  htim2.Instance = TIM2;
 800349e:	4c80      	ldr	r4, [pc, #512]	; (80036a0 <main+0x298>)
 80034a0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80034a4:	6023      	str	r3, [r4, #0]
  htim2.Init.Prescaler = 0;
 80034a6:	6060      	str	r0, [r4, #4]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 80034a8:	60a0      	str	r0, [r4, #8]
  htim2.Init.Period = 255;
 80034aa:	23ff      	movs	r3, #255	; 0xff
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80034ac:	6120      	str	r0, [r4, #16]
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
 80034ae:	4620      	mov	r0, r4
  TIM_OC_InitTypeDef sConfigOC;

  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 0;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 255;
 80034b0:	60e3      	str	r3, [r4, #12]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
 80034b2:	f7fe ff91 	bl	80023d8 <HAL_TIM_PWM_Init>
 80034b6:	4627      	mov	r7, r4
 80034b8:	b100      	cbz	r0, 80034bc <main+0xb4>
 80034ba:	e7fe      	b.n	80034ba <main+0xb2>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80034bc:	900a      	str	r0, [sp, #40]	; 0x28
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80034be:	900c      	str	r0, [sp, #48]	; 0x30
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 80034c0:	a90a      	add	r1, sp, #40	; 0x28
 80034c2:	4620      	mov	r0, r4
 80034c4:	f7ff f8d4 	bl	8002670 <HAL_TIMEx_MasterConfigSynchronization>
 80034c8:	4602      	mov	r2, r0
 80034ca:	b100      	cbz	r0, 80034ce <main+0xc6>
 80034cc:	e7fe      	b.n	80034cc <main+0xc4>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80034ce:	f04f 0960 	mov.w	r9, #96	; 0x60
  sConfigOC.Pulse = 0;
 80034d2:	9012      	str	r0, [sp, #72]	; 0x48
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 80034d4:	9013      	str	r0, [sp, #76]	; 0x4c
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 80034d6:	9015      	str	r0, [sp, #84]	; 0x54
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 80034d8:	a911      	add	r1, sp, #68	; 0x44
 80034da:	4620      	mov	r0, r4
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80034dc:	f8cd 9044 	str.w	r9, [sp, #68]	; 0x44
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 80034e0:	f7fe ffce 	bl	8002480 <HAL_TIM_PWM_ConfigChannel>
 80034e4:	b100      	cbz	r0, 80034e8 <main+0xe0>
 80034e6:	e7fe      	b.n	80034e6 <main+0xde>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 80034e8:	2204      	movs	r2, #4
 80034ea:	a911      	add	r1, sp, #68	; 0x44
 80034ec:	4620      	mov	r0, r4
 80034ee:	f7fe ffc7 	bl	8002480 <HAL_TIM_PWM_ConfigChannel>
 80034f2:	b100      	cbz	r0, 80034f6 <main+0xee>
 80034f4:	e7fe      	b.n	80034f4 <main+0xec>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 80034f6:	4632      	mov	r2, r6
 80034f8:	a911      	add	r1, sp, #68	; 0x44
 80034fa:	4620      	mov	r0, r4
 80034fc:	f7fe ffc0 	bl	8002480 <HAL_TIM_PWM_ConfigChannel>
 8003500:	4606      	mov	r6, r0
 8003502:	b100      	cbz	r0, 8003506 <main+0xfe>
 8003504:	e7fe      	b.n	8003504 <main+0xfc>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  HAL_TIM_MspPostInit(&htim2);
 8003506:	4620      	mov	r0, r4

  TIM_MasterConfigTypeDef sMasterConfig;
  TIM_OC_InitTypeDef sConfigOC;
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig;

  htim1.Instance = TIM1;
 8003508:	4c66      	ldr	r4, [pc, #408]	; (80036a4 <main+0x29c>)
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  HAL_TIM_MspPostInit(&htim2);
 800350a:	f000 fb15 	bl	8003b38 <HAL_TIM_MspPostInit>

  TIM_MasterConfigTypeDef sMasterConfig;
  TIM_OC_InitTypeDef sConfigOC;
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig;

  htim1.Instance = TIM1;
 800350e:	4b66      	ldr	r3, [pc, #408]	; (80036a8 <main+0x2a0>)
  htim1.Init.Prescaler = 3;
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8003510:	60a6      	str	r6, [r4, #8]
  htim1.Init.Period = 0;
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim1.Init.RepetitionCounter = 0;
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 8003512:	4620      	mov	r0, r4
  TIM_MasterConfigTypeDef sMasterConfig;
  TIM_OC_InitTypeDef sConfigOC;
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig;

  htim1.Instance = TIM1;
  htim1.Init.Prescaler = 3;
 8003514:	e884 0108 	stmia.w	r4, {r3, r8}
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim1.Init.Period = 0;
 8003518:	60e6      	str	r6, [r4, #12]
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800351a:	6126      	str	r6, [r4, #16]
  htim1.Init.RepetitionCounter = 0;
 800351c:	6166      	str	r6, [r4, #20]
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 800351e:	f7fe ff5b 	bl	80023d8 <HAL_TIM_PWM_Init>
 8003522:	b100      	cbz	r0, 8003526 <main+0x11e>
 8003524:	e7fe      	b.n	8003524 <main+0x11c>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8003526:	9007      	str	r0, [sp, #28]
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
 8003528:	9008      	str	r0, [sp, #32]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800352a:	9009      	str	r0, [sp, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 800352c:	a907      	add	r1, sp, #28
 800352e:	4620      	mov	r0, r4
 8003530:	f7ff f89e 	bl	8002670 <HAL_TIMEx_MasterConfigSynchronization>
 8003534:	4602      	mov	r2, r0
 8003536:	b100      	cbz	r0, 800353a <main+0x132>
 8003538:	e7fe      	b.n	8003538 <main+0x130>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
 800353a:	900b      	str	r0, [sp, #44]	; 0x2c
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 800353c:	900c      	str	r0, [sp, #48]	; 0x30
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 800353e:	900d      	str	r0, [sp, #52]	; 0x34
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8003540:	900e      	str	r0, [sp, #56]	; 0x38
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 8003542:	900f      	str	r0, [sp, #60]	; 0x3c
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 8003544:	9010      	str	r0, [sp, #64]	; 0x40
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8003546:	a90a      	add	r1, sp, #40	; 0x28
 8003548:	4620      	mov	r0, r4
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 800354a:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 800354e:	f7fe ff97 	bl	8002480 <HAL_TIM_PWM_ConfigChannel>
 8003552:	b100      	cbz	r0, 8003556 <main+0x14e>
 8003554:	e7fe      	b.n	8003554 <main+0x14c>
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
  sBreakDeadTimeConfig.DeadTime = 0;
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 8003556:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 800355a:	9011      	str	r0, [sp, #68]	; 0x44
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 800355c:	9012      	str	r0, [sp, #72]	; 0x48
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 800355e:	9013      	str	r0, [sp, #76]	; 0x4c
  sBreakDeadTimeConfig.DeadTime = 0;
 8003560:	9014      	str	r0, [sp, #80]	; 0x50
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 8003562:	9015      	str	r0, [sp, #84]	; 0x54
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 8003564:	9316      	str	r3, [sp, #88]	; 0x58
  sBreakDeadTimeConfig.BreakFilter = 0;
 8003566:	9017      	str	r0, [sp, #92]	; 0x5c
  sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
 8003568:	9018      	str	r0, [sp, #96]	; 0x60
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
 800356a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
  sBreakDeadTimeConfig.Break2Filter = 0;
 800356e:	901a      	str	r0, [sp, #104]	; 0x68
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 8003570:	901b      	str	r0, [sp, #108]	; 0x6c
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8003572:	a911      	add	r1, sp, #68	; 0x44
 8003574:	4620      	mov	r0, r4
  sBreakDeadTimeConfig.DeadTime = 0;
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
  sBreakDeadTimeConfig.BreakFilter = 0;
  sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
 8003576:	9319      	str	r3, [sp, #100]	; 0x64
  sBreakDeadTimeConfig.Break2Filter = 0;
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8003578:	f7ff f89c 	bl	80026b4 <HAL_TIMEx_ConfigBreakDeadTime>
 800357c:	b100      	cbz	r0, 8003580 <main+0x178>
 800357e:	e7fe      	b.n	800357e <main+0x176>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  HAL_TIM_MspPostInit(&htim1);
 8003580:	4848      	ldr	r0, [pc, #288]	; (80036a4 <main+0x29c>)
 8003582:	f000 fad9 	bl	8003b38 <HAL_TIM_MspPostInit>

/* SPI1 init function */
static void MX_SPI1_Init(void)
{

  hspi1.Instance = SPI1;
 8003586:	4849      	ldr	r0, [pc, #292]	; (80036ac <main+0x2a4>)
  hspi1.Init.Mode = SPI_MODE_MASTER;
  hspi1.Init.Direction = SPI_DIRECTION_1LINE;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 8003588:	4949      	ldr	r1, [pc, #292]	; (80036b0 <main+0x2a8>)
 800358a:	f44f 7382 	mov.w	r3, #260	; 0x104
 800358e:	f44f 4400 	mov.w	r4, #32768	; 0x8000
 8003592:	f44f 66e0 	mov.w	r6, #1792	; 0x700
 8003596:	e880 005a 	stmia.w	r0, {r1, r3, r4, r6}
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
 800359a:	f44f 7200 	mov.w	r2, #512	; 0x200

  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;
  hspi1.Init.Direction = SPI_DIRECTION_1LINE;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 800359e:	2300      	movs	r3, #0
 80035a0:	6103      	str	r3, [r0, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 80035a2:	6143      	str	r3, [r0, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 80035a4:	6182      	str	r2, [r0, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 80035a6:	61c3      	str	r3, [r0, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 80035a8:	6203      	str	r3, [r0, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 80035aa:	6243      	str	r3, [r0, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80035ac:	6283      	str	r3, [r0, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 7;
 80035ae:	2207      	movs	r2, #7
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 80035b0:	6303      	str	r3, [r0, #48]	; 0x30
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 80035b2:	2308      	movs	r3, #8
  hspi1.Init.NSS = SPI_NSS_SOFT;
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi1.Init.CRCPolynomial = 7;
 80035b4:	62c2      	str	r2, [r0, #44]	; 0x2c
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 80035b6:	6343      	str	r3, [r0, #52]	; 0x34
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 80035b8:	f7fe fccd 	bl	8001f56 <HAL_SPI_Init>
 80035bc:	4604      	mov	r4, r0
 80035be:	b100      	cbz	r0, 80035c2 <main+0x1ba>
 80035c0:	e7fe      	b.n	80035c0 <main+0x1b8>
//	 uint8_t green - green channel duty-cycle (0 to 255)
//   uint8_t blue - blue channel duty-cycle (0 to 255)
// RETURNS       :
//   none
void setLEDPWM(uint8_t red, uint8_t green, uint8_t blue) {
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_1,red);
 80035c2:	683b      	ldr	r3, [r7, #0]
 80035c4:	6358      	str	r0, [r3, #52]	; 0x34
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_2,green);
 80035c6:	6398      	str	r0, [r3, #56]	; 0x38
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_4,blue);
 80035c8:	6418      	str	r0, [r3, #64]	; 0x40
  MX_TIM1_Init();
  MX_SPI1_Init();

  /* USER CODE BEGIN 2 */
  setLEDPWM(red, green, blue);	// turn off all LED colors
  startLEDPWMs();				// start LED PWMs
 80035ca:	f7ff feab 	bl	8003324 <startLEDPWMs>
  lcd7735_initR(INITR_REDTAB);
 80035ce:	2001      	movs	r0, #1
 80035d0:	f7ff fbc4 	bl	8002d5c <lcd7735_initR>
  lcd7735_setFont((uint8_t *)&SmallFont[0]);
 80035d4:	4837      	ldr	r0, [pc, #220]	; (80036b4 <main+0x2ac>)
 80035d6:	f7ff fc7d 	bl	8002ed4 <lcd7735_setFont>
  lcd7735_fillScreen(ST7735_BLACK);
 80035da:	4620      	mov	r0, r4
 80035dc:	f7ff fe4a 	bl	8003274 <lcd7735_fillScreen>
  lcd7735_setForeground(ST7735_YELLOW);
 80035e0:	f64f 70e0 	movw	r0, #65504	; 0xffe0
 80035e4:	f7ff fe5a 	bl	800329c <lcd7735_setForeground>
  lcd7735_print("Security System!",0,0,0);
 80035e8:	4623      	mov	r3, r4
 80035ea:	4622      	mov	r2, r4
 80035ec:	4621      	mov	r1, r4
 80035ee:	4832      	ldr	r0, [pc, #200]	; (80036b8 <main+0x2b0>)
 80035f0:	f7ff fdfa 	bl	80031e8 <lcd7735_print>
  lcd7735_print("Enter passcode:",0,20,0);
 80035f4:	4623      	mov	r3, r4
 80035f6:	2214      	movs	r2, #20
 80035f8:	4621      	mov	r1, r4
 80035fa:	4830      	ldr	r0, [pc, #192]	; (80036bc <main+0x2b4>)
 80035fc:	f7ff fdf4 	bl	80031e8 <lcd7735_print>

  /* USER CODE BEGIN 1 */
  uint8_t state = 0;
  uint16_t idleTimer = 0;
  uint8_t red = 0;
  uint8_t green = 0;
 8003600:	46a3      	mov	fp, r4
{

  /* USER CODE BEGIN 1 */
  uint8_t state = 0;
  uint16_t idleTimer = 0;
  uint8_t red = 0;
 8003602:	4626      	mov	r6, r4
int main(void)
{

  /* USER CODE BEGIN 1 */
  uint8_t state = 0;
  uint16_t idleTimer = 0;
 8003604:	46a0      	mov	r8, r4

int main(void)
{

  /* USER CODE BEGIN 1 */
  uint8_t state = 0;
 8003606:	4623      	mov	r3, r4
			  blue = 0;
			  setLEDPWM(red, green, blue);
			  lcd7735_fillRect(3,58,120,18,ST7735_RED);
			  lcd7735_setForeground(ST7735_WHITE);
			  lcd7735_setTransparent(1);
			  lcd7735_print("Intruder Alert!",5,60,0);
 8003608:	46a1      	mov	r9, r4
			  printf("\r\nPassword is correct, access granted!!!\r\n");
			  playRTTTLSong(rtttlLibrary[1]);
		  } else {
			  // password is wrong
			  red = MAXPWMCYCLE;
			  green = 0;
 800360a:	46a2      	mov	sl, r4
  /* USER CODE END WHILE */

  /* USER CODE BEGIN 3 */
	  char userInput[5];
	  // we monitor UART2 RX buffer not empty (RXNE) flag
	  if (!__HAL_UART_GET_FLAG(&huart2,UART_FLAG_RXNE)) {
 800360c:	682a      	ldr	r2, [r5, #0]
 800360e:	69d2      	ldr	r2, [r2, #28]
 8003610:	0692      	lsls	r2, r2, #26
 8003612:	d457      	bmi.n	80036c4 <main+0x2bc>
		  // if RXNE = 0, there is nothing in UART2 RX buffer
		  if (!state){
 8003614:	9303      	str	r3, [sp, #12]
 8003616:	b92b      	cbnz	r3, 8003624 <main+0x21c>
			  printf("Please enter your 4-character/number password:\r\n");
 8003618:	4829      	ldr	r0, [pc, #164]	; (80036c0 <main+0x2b8>)
 800361a:	f000 fcab 	bl	8003f74 <puts>
			  // change state to 1 so we don't print messages again
			  state = 1;
			  idleTimer = 0;
 800361e:	9b03      	ldr	r3, [sp, #12]
 8003620:	4698      	mov	r8, r3
 8003622:	e032      	b.n	800368a <main+0x282>
		  } else {
			  HAL_Delay(10);
 8003624:	200a      	movs	r0, #10
 8003626:	f7fd fc5f 	bl	8000ee8 <HAL_Delay>
			  if (idleTimer > 200) {
 800362a:	f1b8 0fc8 	cmp.w	r8, #200	; 0xc8
 800362e:	d928      	bls.n	8003682 <main+0x27a>
				  if (red) {
 8003630:	b10e      	cbz	r6, 8003636 <main+0x22e>
					  red--;
 8003632:	3e01      	subs	r6, #1
 8003634:	b2f6      	uxtb	r6, r6
				  }
				  if (green) {
 8003636:	f1bb 0f00 	cmp.w	fp, #0
 800363a:	d003      	beq.n	8003644 <main+0x23c>
					  green--;
 800363c:	f10b 3bff 	add.w	fp, fp, #4294967295
 8003640:	fa5f fb8b 	uxtb.w	fp, fp
				  }
				  if (blue) {
 8003644:	b10c      	cbz	r4, 800364a <main+0x242>
					  blue--;
 8003646:	3c01      	subs	r4, #1
 8003648:	b2e4      	uxtb	r4, r4
//	 uint8_t green - green channel duty-cycle (0 to 255)
//   uint8_t blue - blue channel duty-cycle (0 to 255)
// RETURNS       :
//   none
void setLEDPWM(uint8_t red, uint8_t green, uint8_t blue) {
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_1,red);
 800364a:	683b      	ldr	r3, [r7, #0]
				  if (blue) {
					  blue--;
				  }
				  setLEDPWM(red, green, blue);
			  }
			  if (idleTimer >= 500){
 800364c:	f5b8 7ffa 	cmp.w	r8, #500	; 0x1f4
//	 uint8_t green - green channel duty-cycle (0 to 255)
//   uint8_t blue - blue channel duty-cycle (0 to 255)
// RETURNS       :
//   none
void setLEDPWM(uint8_t red, uint8_t green, uint8_t blue) {
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_1,red);
 8003650:	635e      	str	r6, [r3, #52]	; 0x34
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_2,green);
 8003652:	f8c3 b038 	str.w	fp, [r3, #56]	; 0x38
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_4,blue);
 8003656:	641c      	str	r4, [r3, #64]	; 0x40
				  if (blue) {
					  blue--;
				  }
				  setLEDPWM(red, green, blue);
			  }
			  if (idleTimer >= 500){
 8003658:	d313      	bcc.n	8003682 <main+0x27a>
				  // after 500*10 = 5000ms the remove the message from display
				  lcd7735_fillRect(3,58,120,18,ST7735_BLACK);
 800365a:	2312      	movs	r3, #18
 800365c:	f8cd a000 	str.w	sl, [sp]
 8003660:	2278      	movs	r2, #120	; 0x78
 8003662:	213a      	movs	r1, #58	; 0x3a
 8003664:	2003      	movs	r0, #3
 8003666:	f7ff fbf1 	bl	8002e4c <lcd7735_fillRect>
//	 uint8_t green - green channel duty-cycle (0 to 255)
//   uint8_t blue - blue channel duty-cycle (0 to 255)
// RETURNS       :
//   none
void setLEDPWM(uint8_t red, uint8_t green, uint8_t blue) {
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_1,red);
 800366a:	4b0d      	ldr	r3, [pc, #52]	; (80036a0 <main+0x298>)
 800366c:	681b      	ldr	r3, [r3, #0]
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_2,green);
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_4,blue);
 800366e:	24ff      	movs	r4, #255	; 0xff
			  }
			  if (idleTimer >= 500){
				  // after 500*10 = 5000ms the remove the message from display
				  lcd7735_fillRect(3,58,120,18,ST7735_BLACK);
				  red = 0;
				  green = 0;
 8003670:	f04f 0b00 	mov.w	fp, #0
//	 uint8_t green - green channel duty-cycle (0 to 255)
//   uint8_t blue - blue channel duty-cycle (0 to 255)
// RETURNS       :
//   none
void setLEDPWM(uint8_t red, uint8_t green, uint8_t blue) {
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_1,red);
 8003674:	f8c3 9034 	str.w	r9, [r3, #52]	; 0x34
				  setLEDPWM(red, green, blue);
			  }
			  if (idleTimer >= 500){
				  // after 500*10 = 5000ms the remove the message from display
				  lcd7735_fillRect(3,58,120,18,ST7735_BLACK);
				  red = 0;
 8003678:	465e      	mov	r6, fp
//   uint8_t blue - blue channel duty-cycle (0 to 255)
// RETURNS       :
//   none
void setLEDPWM(uint8_t red, uint8_t green, uint8_t blue) {
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_1,red);
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_2,green);
 800367a:	f8c3 9038 	str.w	r9, [r3, #56]	; 0x38
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_4,blue);
 800367e:	641c      	str	r4, [r3, #64]	; 0x40
 8003680:	e003      	b.n	800368a <main+0x282>
				  red = 0;
				  green = 0;
				  blue = MAXPWMCYCLE;
				  setLEDPWM(red, green, blue);
			  } else {
				  idleTimer++;
 8003682:	f108 0801 	add.w	r8, r8, #1
 8003686:	fa1f f888 	uxth.w	r8, r8
 800368a:	2301      	movs	r3, #1
 800368c:	e7be      	b.n	800360c <main+0x204>
 800368e:	bf00      	nop
 8003690:	40021000 	.word	0x40021000
 8003694:	48000400 	.word	0x48000400
 8003698:	2000023c 	.word	0x2000023c
 800369c:	40004400 	.word	0x40004400
 80036a0:	20000200 	.word	0x20000200
 80036a4:	20000160 	.word	0x20000160
 80036a8:	40012c00 	.word	0x40012c00
 80036ac:	2000019c 	.word	0x2000019c
 80036b0:	40013000 	.word	0x40013000
 80036b4:	0800632d 	.word	0x0800632d
 80036b8:	08006826 	.word	0x08006826
 80036bc:	08006837 	.word	0x08006837
 80036c0:	08006847 	.word	0x08006847
			  }
		  }
	  } else {
		  // there is something in UART2 RX buffer
		  scanf("%4s",userInput);
 80036c4:	a911      	add	r1, sp, #68	; 0x44
 80036c6:	482e      	ldr	r0, [pc, #184]	; (8003780 <main+0x378>)
 80036c8:	f8df b0c8 	ldr.w	fp, [pc, #200]	; 8003794 <main+0x38c>
 80036cc:	f000 fc6a 	bl	8003fa4 <iscanf>
		  state = 0;
		  if (isPasswordOk(userInput)) {
 80036d0:	a811      	add	r0, sp, #68	; 0x44
 80036d2:	f7ff fe39 	bl	8003348 <isPasswordOk>
//	 uint8_t green - green channel duty-cycle (0 to 255)
//   uint8_t blue - blue channel duty-cycle (0 to 255)
// RETURNS       :
//   none
void setLEDPWM(uint8_t red, uint8_t green, uint8_t blue) {
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_1,red);
 80036d6:	683b      	ldr	r3, [r7, #0]
		  }
	  } else {
		  // there is something in UART2 RX buffer
		  scanf("%4s",userInput);
		  state = 0;
		  if (isPasswordOk(userInput)) {
 80036d8:	4604      	mov	r4, r0
 80036da:	b348      	cbz	r0, 8003730 <main+0x328>
//   uint8_t blue - blue channel duty-cycle (0 to 255)
// RETURNS       :
//   none
void setLEDPWM(uint8_t red, uint8_t green, uint8_t blue) {
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_1,red);
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_2,green);
 80036dc:	26ff      	movs	r6, #255	; 0xff
//	 uint8_t green - green channel duty-cycle (0 to 255)
//   uint8_t blue - blue channel duty-cycle (0 to 255)
// RETURNS       :
//   none
void setLEDPWM(uint8_t red, uint8_t green, uint8_t blue) {
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_1,red);
 80036de:	f8c3 9034 	str.w	r9, [r3, #52]	; 0x34
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_2,green);
 80036e2:	639e      	str	r6, [r3, #56]	; 0x38
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_4,blue);
 80036e4:	f8c3 9040 	str.w	r9, [r3, #64]	; 0x40
			  // password is OK
			  red = 0;
			  green = MAXPWMCYCLE;
			  blue = 0;
			  setLEDPWM(red, green, blue);
			  lcd7735_fillRect(3,58,120,18,ST7735_GREEN);
 80036e8:	f44f 63fc 	mov.w	r3, #2016	; 0x7e0
 80036ec:	2278      	movs	r2, #120	; 0x78
 80036ee:	213a      	movs	r1, #58	; 0x3a
 80036f0:	9300      	str	r3, [sp, #0]
 80036f2:	2003      	movs	r0, #3
 80036f4:	2312      	movs	r3, #18
 80036f6:	f7ff fba9 	bl	8002e4c <lcd7735_fillRect>
			  lcd7735_setForeground(ST7735_WHITE);
 80036fa:	f64f 70ff 	movw	r0, #65535	; 0xffff
 80036fe:	f7ff fdcd 	bl	800329c <lcd7735_setForeground>
			  lcd7735_setTransparent(1);
 8003702:	2001      	movs	r0, #1
 8003704:	f7ff fdd0 	bl	80032a8 <lcd7735_setTransparent>
			  lcd7735_print("Access granted!",5,60,0);
 8003708:	2300      	movs	r3, #0
 800370a:	223c      	movs	r2, #60	; 0x3c
 800370c:	2105      	movs	r1, #5
 800370e:	481d      	ldr	r0, [pc, #116]	; (8003784 <main+0x37c>)
 8003710:	f7ff fd6a 	bl	80031e8 <lcd7735_print>
			  lcd7735_setTransparent(0);
 8003714:	2000      	movs	r0, #0
 8003716:	f7ff fdc7 	bl	80032a8 <lcd7735_setTransparent>
			  printf("\r\nPassword is correct, access granted!!!\r\n");
 800371a:	481b      	ldr	r0, [pc, #108]	; (8003788 <main+0x380>)
 800371c:	f000 fc2a 	bl	8003f74 <puts>
		  state = 0;
		  if (isPasswordOk(userInput)) {
			  // password is OK
			  red = 0;
			  green = MAXPWMCYCLE;
			  blue = 0;
 8003720:	2400      	movs	r4, #0
			  lcd7735_setForeground(ST7735_WHITE);
			  lcd7735_setTransparent(1);
			  lcd7735_print("Access granted!",5,60,0);
			  lcd7735_setTransparent(0);
			  printf("\r\nPassword is correct, access granted!!!\r\n");
			  playRTTTLSong(rtttlLibrary[1]);
 8003722:	f8db 0004 	ldr.w	r0, [fp, #4]
 8003726:	f000 f845 	bl	80037b4 <playRTTTLSong>
		  scanf("%4s",userInput);
		  state = 0;
		  if (isPasswordOk(userInput)) {
			  // password is OK
			  red = 0;
			  green = MAXPWMCYCLE;
 800372a:	46b3      	mov	fp, r6
		  // there is something in UART2 RX buffer
		  scanf("%4s",userInput);
		  state = 0;
		  if (isPasswordOk(userInput)) {
			  // password is OK
			  red = 0;
 800372c:	4626      	mov	r6, r4
 800372e:	e024      	b.n	800377a <main+0x372>
//	 uint8_t green - green channel duty-cycle (0 to 255)
//   uint8_t blue - blue channel duty-cycle (0 to 255)
// RETURNS       :
//   none
void setLEDPWM(uint8_t red, uint8_t green, uint8_t blue) {
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_1,red);
 8003730:	26ff      	movs	r6, #255	; 0xff
 8003732:	635e      	str	r6, [r3, #52]	; 0x34
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_2,green);
 8003734:	6398      	str	r0, [r3, #56]	; 0x38
	__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_4,blue);
 8003736:	6418      	str	r0, [r3, #64]	; 0x40
			  // password is wrong
			  red = MAXPWMCYCLE;
			  green = 0;
			  blue = 0;
			  setLEDPWM(red, green, blue);
			  lcd7735_fillRect(3,58,120,18,ST7735_RED);
 8003738:	f44f 4378 	mov.w	r3, #63488	; 0xf800
 800373c:	2278      	movs	r2, #120	; 0x78
 800373e:	213a      	movs	r1, #58	; 0x3a
 8003740:	9300      	str	r3, [sp, #0]
 8003742:	2003      	movs	r0, #3
 8003744:	2312      	movs	r3, #18
 8003746:	f7ff fb81 	bl	8002e4c <lcd7735_fillRect>
			  lcd7735_setForeground(ST7735_WHITE);
 800374a:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800374e:	f7ff fda5 	bl	800329c <lcd7735_setForeground>
			  lcd7735_setTransparent(1);
 8003752:	2001      	movs	r0, #1
 8003754:	f7ff fda8 	bl	80032a8 <lcd7735_setTransparent>
			  lcd7735_print("Intruder Alert!",5,60,0);
 8003758:	4623      	mov	r3, r4
 800375a:	223c      	movs	r2, #60	; 0x3c
 800375c:	2105      	movs	r1, #5
 800375e:	480b      	ldr	r0, [pc, #44]	; (800378c <main+0x384>)
 8003760:	f7ff fd42 	bl	80031e8 <lcd7735_print>
			  lcd7735_setTransparent(0);
 8003764:	4620      	mov	r0, r4
 8003766:	f7ff fd9f 	bl	80032a8 <lcd7735_setTransparent>
			  printf("\r\nPASSWORD IS WRONG! INTRUDER ALERT!!!\r\n");
 800376a:	4809      	ldr	r0, [pc, #36]	; (8003790 <main+0x388>)
 800376c:	f000 fc02 	bl	8003f74 <puts>
			  playRTTTLSong(rtttlLibrary[0]);
 8003770:	f8db 0000 	ldr.w	r0, [fp]
 8003774:	f000 f81e 	bl	80037b4 <playRTTTLSong>
			  printf("\r\nPassword is correct, access granted!!!\r\n");
			  playRTTTLSong(rtttlLibrary[1]);
		  } else {
			  // password is wrong
			  red = MAXPWMCYCLE;
			  green = 0;
 8003778:	46a3      	mov	fp, r4
			  }
		  }
	  } else {
		  // there is something in UART2 RX buffer
		  scanf("%4s",userInput);
		  state = 0;
 800377a:	4623      	mov	r3, r4
			  printf("\r\nPASSWORD IS WRONG! INTRUDER ALERT!!!\r\n");
			  playRTTTLSong(rtttlLibrary[0]);
		  }
	  }

  }
 800377c:	e746      	b.n	800360c <main+0x204>
 800377e:	bf00      	nop
 8003780:	08006877 	.word	0x08006877
 8003784:	0800687b 	.word	0x0800687b
 8003788:	0800688b 	.word	0x0800688b
 800378c:	080068b5 	.word	0x080068b5
 8003790:	080068c5 	.word	0x080068c5
 8003794:	20000008 	.word	0x20000008

08003798 <playSound>:
// PARAMETERS    :
//   uint16_t freq - sound frequency (Hz)
//   uint16_t duration - duration (ms)
// RETURNS       :
//   none
void playSound(uint16_t freq, uint16_t duration) {
 8003798:	b510      	push	{r4, lr}
	setSoundFrequency(freq);
 800379a:	b200      	sxth	r0, r0
// PARAMETERS    :
//   uint16_t freq - sound frequency (Hz)
//   uint16_t duration - duration (ms)
// RETURNS       :
//   none
void playSound(uint16_t freq, uint16_t duration) {
 800379c:	460c      	mov	r4, r1
	setSoundFrequency(freq);
 800379e:	f7ff fda7 	bl	80032f0 <setSoundFrequency>
	HAL_Delay(duration);
 80037a2:	4620      	mov	r0, r4
 80037a4:	f7fd fba0 	bl	8000ee8 <HAL_Delay>
	setSoundFrequency(0);
 80037a8:	2000      	movs	r0, #0
}
 80037aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
// RETURNS       :
//   none
void playSound(uint16_t freq, uint16_t duration) {
	setSoundFrequency(freq);
	HAL_Delay(duration);
	setSoundFrequency(0);
 80037ae:	f7ff bd9f 	b.w	80032f0 <setSoundFrequency>
	...

080037b4 <playRTTTLSong>:
//   Decodes and plays an RTTTL song string
// PARAMETERS    :
//   const char *currSong - RTTTL song string
// RETURNS       :
//   none
void playRTTTLSong(const char *currSong) {
 80037b4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint8_t tempDuration = 0;
  uint8_t tempOctave = 0;
  uint8_t currentNote = 0;
  uint8_t dotFlag = 0;
  uint16_t calcDuration = 0;
  duration = 4;                 // default duration = 4/4 = 1 beat
 80037b8:	4d92      	ldr	r5, [pc, #584]	; (8003a04 <playRTTTLSong+0x250>)
  tempo = 63;                   // default tempo = 63 bpm
 80037ba:	4e93      	ldr	r6, [pc, #588]	; (8003a08 <playRTTTLSong+0x254>)
  octave = 6;                   // default octave = 6th
 80037bc:	4f93      	ldr	r7, [pc, #588]	; (8003a0c <playRTTTLSong+0x258>)
  uint8_t tempDuration = 0;
  uint8_t tempOctave = 0;
  uint8_t currentNote = 0;
  uint8_t dotFlag = 0;
  uint16_t calcDuration = 0;
  duration = 4;                 // default duration = 4/4 = 1 beat
 80037be:	2304      	movs	r3, #4
 80037c0:	702b      	strb	r3, [r5, #0]
  tempo = 63;                   // default tempo = 63 bpm
 80037c2:	233f      	movs	r3, #63	; 0x3f
 80037c4:	8033      	strh	r3, [r6, #0]
  octave = 6;                   // default octave = 6th
 80037c6:	2306      	movs	r3, #6
 80037c8:	703b      	strb	r3, [r7, #0]
 80037ca:	4603      	mov	r3, r0
 80037cc:	3001      	adds	r0, #1
  while (*currSong != ':') currSong++;  // find the first ':'
 80037ce:	781a      	ldrb	r2, [r3, #0]
 80037d0:	2a3a      	cmp	r2, #58	; 0x3a
 80037d2:	d1fa      	bne.n	80037ca <playRTTTLSong+0x16>
  currSong++;                   // skip the ':'
  while (*currSong!=':')        // repeat until find a ':'
 80037d4:	f04f 0800 	mov.w	r8, #0
  uint16_t calcDuration = 0;
  duration = 4;                 // default duration = 4/4 = 1 beat
  tempo = 63;                   // default tempo = 63 bpm
  octave = 6;                   // default octave = 6th
  while (*currSong != ':') currSong++;  // find the first ':'
  currSong++;                   // skip the ':'
 80037d8:	4603      	mov	r3, r0
  while (*currSong!=':')        // repeat until find a ':'
 80037da:	2104      	movs	r1, #4
 80037dc:	46c4      	mov	ip, r8
 80037de:	2406      	movs	r4, #6
 80037e0:	46c1      	mov	r9, r8
 80037e2:	223f      	movs	r2, #63	; 0x3f
 80037e4:	7818      	ldrb	r0, [r3, #0]
 80037e6:	283a      	cmp	r0, #58	; 0x3a
 80037e8:	f000 8093 	beq.w	8003912 <playRTTTLSong+0x15e>
  {
    if (*currSong == 'd')       // if it is the duration setting
 80037ec:	2864      	cmp	r0, #100	; 0x64
 80037ee:	d127      	bne.n	8003840 <playRTTTLSong+0x8c>
 80037f0:	3301      	adds	r3, #1
    {
      duration = 0;             // set duration to zero (temporarily)
      currSong++;                   // advance to the next character
      while (*currSong == '=') currSong++;  // skip the '='
 80037f2:	7819      	ldrb	r1, [r3, #0]
 80037f4:	293d      	cmp	r1, #61	; 0x3d
 80037f6:	f103 0001 	add.w	r0, r3, #1
 80037fa:	d101      	bne.n	8003800 <playRTTTLSong+0x4c>
 80037fc:	4603      	mov	r3, r0
 80037fe:	e7f8      	b.n	80037f2 <playRTTTLSong+0x3e>
 8003800:	4618      	mov	r0, r3
      while (*currSong == ' ') currSong++;  // skip the spaces
 8003802:	f813 1b01 	ldrb.w	r1, [r3], #1
 8003806:	2920      	cmp	r1, #32
 8003808:	d0fa      	beq.n	8003800 <playRTTTLSong+0x4c>
      // if the character is a number, set the duration
      if (*currSong>='0' && *currSong<='9') duration = *currSong - '0';
      currSong++;                   // advance to the next character
      // if the character is also a number (duration can be 2 digits long)
      if (*currSong>='0' && *currSong<='9')
 800380a:	7843      	ldrb	r3, [r0, #1]
      duration = 0;             // set duration to zero (temporarily)
      currSong++;                   // advance to the next character
      while (*currSong == '=') currSong++;  // skip the '='
      while (*currSong == ' ') currSong++;  // skip the spaces
      // if the character is a number, set the duration
      if (*currSong>='0' && *currSong<='9') duration = *currSong - '0';
 800380c:	3930      	subs	r1, #48	; 0x30
 800380e:	b2c9      	uxtb	r1, r1
      currSong++;                   // advance to the next character
      // if the character is also a number (duration can be 2 digits long)
      if (*currSong>='0' && *currSong<='9')
 8003810:	3b30      	subs	r3, #48	; 0x30
  currSong++;                   // skip the ':'
  while (*currSong!=':')        // repeat until find a ':'
  {
    if (*currSong == 'd')       // if it is the duration setting
    {
      duration = 0;             // set duration to zero (temporarily)
 8003812:	290a      	cmp	r1, #10
      while (*currSong == ' ') currSong++;  // skip the spaces
      // if the character is a number, set the duration
      if (*currSong>='0' && *currSong<='9') duration = *currSong - '0';
      currSong++;                   // advance to the next character
      // if the character is also a number (duration can be 2 digits long)
      if (*currSong>='0' && *currSong<='9')
 8003814:	b2db      	uxtb	r3, r3
  currSong++;                   // skip the ':'
  while (*currSong!=':')        // repeat until find a ':'
  {
    if (*currSong == 'd')       // if it is the duration setting
    {
      duration = 0;             // set duration to zero (temporarily)
 8003816:	bf28      	it	cs
 8003818:	2100      	movcs	r1, #0
      while (*currSong == ' ') currSong++;  // skip the spaces
      // if the character is a number, set the duration
      if (*currSong>='0' && *currSong<='9') duration = *currSong - '0';
      currSong++;                   // advance to the next character
      // if the character is also a number (duration can be 2 digits long)
      if (*currSong>='0' && *currSong<='9')
 800381a:	2b09      	cmp	r3, #9
      { // multiply duration by 10 and add the value of the character
        duration = duration*10 + (*currSong - '0');
 800381c:	bf9b      	ittet	ls
 800381e:	eb01 0181 	addls.w	r1, r1, r1, lsl #2
 8003822:	eb03 0141 	addls.w	r1, r3, r1, lsl #1
      currSong++;                   // advance to the next character
      while (*currSong == '=') currSong++;  // skip the '='
      while (*currSong == ' ') currSong++;  // skip the spaces
      // if the character is a number, set the duration
      if (*currSong>='0' && *currSong<='9') duration = *currSong - '0';
      currSong++;                   // advance to the next character
 8003826:	3001      	addhi	r0, #1
      // if the character is also a number (duration can be 2 digits long)
      if (*currSong>='0' && *currSong<='9')
      { // multiply duration by 10 and add the value of the character
        duration = duration*10 + (*currSong - '0');
 8003828:	b2c9      	uxtbls	r1, r1
        currSong++;                 // advance to the next character
 800382a:	bf98      	it	ls
 800382c:	3002      	addls	r0, #2
 800382e:	4603      	mov	r3, r0
 8003830:	3001      	adds	r0, #1
      }
      while (*currSong == ',') currSong++;  // skip the ','
 8003832:	f893 e000 	ldrb.w	lr, [r3]
 8003836:	f1be 0f2c 	cmp.w	lr, #44	; 0x2c
 800383a:	d0f8      	beq.n	800382e <playRTTTLSong+0x7a>
 800383c:	f04f 0801 	mov.w	r8, #1
    }
    if (*currSong == 'o')           // if it is the octave setting
 8003840:	7818      	ldrb	r0, [r3, #0]
 8003842:	286f      	cmp	r0, #111	; 0x6f
 8003844:	d11a      	bne.n	800387c <playRTTTLSong+0xc8>
 8003846:	3301      	adds	r3, #1
    {
      octave = 0;               // set octave to zero (temporarily)
      currSong++;                   // advance to the next character
      while (*currSong == '=') currSong++;  // skip the '='
 8003848:	7818      	ldrb	r0, [r3, #0]
 800384a:	283d      	cmp	r0, #61	; 0x3d
 800384c:	f103 0401 	add.w	r4, r3, #1
 8003850:	d101      	bne.n	8003856 <playRTTTLSong+0xa2>
 8003852:	4623      	mov	r3, r4
 8003854:	e7f8      	b.n	8003848 <playRTTTLSong+0x94>
      while (*currSong == ' ') currSong++;  // skip the spaces
 8003856:	f813 4b01 	ldrb.w	r4, [r3], #1
 800385a:	2c20      	cmp	r4, #32
 800385c:	d0fb      	beq.n	8003856 <playRTTTLSong+0xa2>
      // if the character is a number, then set the octave
      if (*currSong>='0' && *currSong<='9') octave = *currSong - '0';
 800385e:	3c30      	subs	r4, #48	; 0x30
 8003860:	b2e4      	uxtb	r4, r4
      }
      while (*currSong == ',') currSong++;  // skip the ','
    }
    if (*currSong == 'o')           // if it is the octave setting
    {
      octave = 0;               // set octave to zero (temporarily)
 8003862:	2c0a      	cmp	r4, #10
 8003864:	bf28      	it	cs
 8003866:	2400      	movcs	r4, #0
 8003868:	4618      	mov	r0, r3
 800386a:	4603      	mov	r3, r0
 800386c:	3001      	adds	r0, #1
      while (*currSong == '=') currSong++;  // skip the '='
      while (*currSong == ' ') currSong++;  // skip the spaces
      // if the character is a number, then set the octave
      if (*currSong>='0' && *currSong<='9') octave = *currSong - '0';
      currSong++;                   // advance to the next character
      while (*currSong == ',') currSong++;  // skips the ','
 800386e:	f893 e000 	ldrb.w	lr, [r3]
 8003872:	f1be 0f2c 	cmp.w	lr, #44	; 0x2c
 8003876:	d0f8      	beq.n	800386a <playRTTTLSong+0xb6>
 8003878:	f04f 0c01 	mov.w	ip, #1
    }
    if (*currSong == 'b')           // if it is the tempo setting (beats per minute)
 800387c:	7818      	ldrb	r0, [r3, #0]
 800387e:	2862      	cmp	r0, #98	; 0x62
 8003880:	d13a      	bne.n	80038f8 <playRTTTLSong+0x144>
 8003882:	3301      	adds	r3, #1
    {
      tempo = 0;                // set tempo to zero (temporarily)
      currSong++;                   // advance to the next character
      while (*currSong == '=') currSong++;  // skips '='
 8003884:	781a      	ldrb	r2, [r3, #0]
 8003886:	2a3d      	cmp	r2, #61	; 0x3d
 8003888:	f103 0001 	add.w	r0, r3, #1
 800388c:	d101      	bne.n	8003892 <playRTTTLSong+0xde>
 800388e:	4603      	mov	r3, r0
 8003890:	e7f8      	b.n	8003884 <playRTTTLSong+0xd0>
      while (*currSong == ' ') currSong++;  // skips spaces
 8003892:	781a      	ldrb	r2, [r3, #0]
 8003894:	2a20      	cmp	r2, #32
 8003896:	4618      	mov	r0, r3
 8003898:	f103 0301 	add.w	r3, r3, #1
 800389c:	d0f9      	beq.n	8003892 <playRTTTLSong+0xde>
      // now read the tempo setting (can be 3 digits long)
      if (*currSong>='0' && *currSong<='9') tempo = *currSong - '0';
 800389e:	3a30      	subs	r2, #48	; 0x30
 80038a0:	b2d3      	uxtb	r3, r2
 80038a2:	2b09      	cmp	r3, #9
      currSong++;                   // advance to the next character
      if (*currSong>='0' && *currSong<='9')
 80038a4:	7843      	ldrb	r3, [r0, #1]
 80038a6:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 80038aa:	fa5f fe83 	uxtb.w	lr, r3
      tempo = 0;                // set tempo to zero (temporarily)
      currSong++;                   // advance to the next character
      while (*currSong == '=') currSong++;  // skips '='
      while (*currSong == ' ') currSong++;  // skips spaces
      // now read the tempo setting (can be 3 digits long)
      if (*currSong>='0' && *currSong<='9') tempo = *currSong - '0';
 80038ae:	bf94      	ite	ls
 80038b0:	b292      	uxthls	r2, r2
      currSong++;                   // advance to the next character
      while (*currSong == ',') currSong++;  // skips the ','
    }
    if (*currSong == 'b')           // if it is the tempo setting (beats per minute)
    {
      tempo = 0;                // set tempo to zero (temporarily)
 80038b2:	2200      	movhi	r2, #0
      while (*currSong == '=') currSong++;  // skips '='
      while (*currSong == ' ') currSong++;  // skips spaces
      // now read the tempo setting (can be 3 digits long)
      if (*currSong>='0' && *currSong<='9') tempo = *currSong - '0';
      currSong++;                   // advance to the next character
      if (*currSong>='0' && *currSong<='9')
 80038b4:	f1be 0f09 	cmp.w	lr, #9
 80038b8:	d901      	bls.n	80038be <playRTTTLSong+0x10a>
      currSong++;                   // advance to the next character
      while (*currSong == '=') currSong++;  // skips '='
      while (*currSong == ' ') currSong++;  // skips spaces
      // now read the tempo setting (can be 3 digits long)
      if (*currSong>='0' && *currSong<='9') tempo = *currSong - '0';
      currSong++;                   // advance to the next character
 80038ba:	3001      	adds	r0, #1
 80038bc:	e013      	b.n	80038e6 <playRTTTLSong+0x132>
      if (*currSong>='0' && *currSong<='9')
      {
        tempo = tempo*10 + (*currSong - '0'); // tempo is two digits
 80038be:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80038c2:	eb03 0242 	add.w	r2, r3, r2, lsl #1
        currSong++;                 // advance to the next character
        if (*currSong>='0' && *currSong<='9')
 80038c6:	7883      	ldrb	r3, [r0, #2]
 80038c8:	3b30      	subs	r3, #48	; 0x30
 80038ca:	fa5f fe83 	uxtb.w	lr, r3
 80038ce:	f1be 0f09 	cmp.w	lr, #9
      // now read the tempo setting (can be 3 digits long)
      if (*currSong>='0' && *currSong<='9') tempo = *currSong - '0';
      currSong++;                   // advance to the next character
      if (*currSong>='0' && *currSong<='9')
      {
        tempo = tempo*10 + (*currSong - '0'); // tempo is two digits
 80038d2:	b292      	uxth	r2, r2
        currSong++;                 // advance to the next character
        if (*currSong>='0' && *currSong<='9')
        {
          tempo = tempo*10 + (*currSong - '0'); // tempo is three digits
 80038d4:	bf9b      	ittet	ls
 80038d6:	eb02 0282 	addls.w	r2, r2, r2, lsl #2
 80038da:	eb03 0242 	addls.w	r2, r3, r2, lsl #1
      if (*currSong>='0' && *currSong<='9') tempo = *currSong - '0';
      currSong++;                   // advance to the next character
      if (*currSong>='0' && *currSong<='9')
      {
        tempo = tempo*10 + (*currSong - '0'); // tempo is two digits
        currSong++;                 // advance to the next character
 80038de:	3002      	addhi	r0, #2
        if (*currSong>='0' && *currSong<='9')
        {
          tempo = tempo*10 + (*currSong - '0'); // tempo is three digits
 80038e0:	b292      	uxthls	r2, r2
          currSong++;               // advance to the next character
 80038e2:	bf98      	it	ls
 80038e4:	3003      	addls	r0, #3
 80038e6:	4686      	mov	lr, r0
 80038e8:	3001      	adds	r0, #1
        }
      }
      while (*currSong == ',') currSong++;  // skip the ','
 80038ea:	f89e 3000 	ldrb.w	r3, [lr]
 80038ee:	2b2c      	cmp	r3, #44	; 0x2c
 80038f0:	d0f9      	beq.n	80038e6 <playRTTTLSong+0x132>
 80038f2:	f04f 0901 	mov.w	r9, #1
 80038f6:	e005      	b.n	8003904 <playRTTTLSong+0x150>
 80038f8:	469e      	mov	lr, r3
 80038fa:	3301      	adds	r3, #1
    }
    while (*currSong == ',') currSong++;    // skip the ','
 80038fc:	f89e 0000 	ldrb.w	r0, [lr]
 8003900:	282c      	cmp	r0, #44	; 0x2c
 8003902:	d0f9      	beq.n	80038f8 <playRTTTLSong+0x144>
 8003904:	4673      	mov	r3, lr
 8003906:	f10e 0e01 	add.w	lr, lr, #1
    while (*currSong == ' ') currSong++;    // skip the ','
 800390a:	7818      	ldrb	r0, [r3, #0]
 800390c:	2820      	cmp	r0, #32
 800390e:	d0f9      	beq.n	8003904 <playRTTTLSong+0x150>
 8003910:	e768      	b.n	80037e4 <playRTTTLSong+0x30>
 8003912:	f1b9 0f00 	cmp.w	r9, #0
 8003916:	d000      	beq.n	800391a <playRTTTLSong+0x166>
 8003918:	8032      	strh	r2, [r6, #0]
 800391a:	f1bc 0f00 	cmp.w	ip, #0
 800391e:	d000      	beq.n	8003922 <playRTTTLSong+0x16e>
 8003920:	703c      	strb	r4, [r7, #0]
 8003922:	f1b8 0f00 	cmp.w	r8, #0
 8003926:	d000      	beq.n	800392a <playRTTTLSong+0x176>
 8003928:	7029      	strb	r1, [r5, #0]
 800392a:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 8003a10 <playRTTTLSong+0x25c>
    calcDuration = (60000/tempo)/(tempDuration);
    calcDuration *= 4;         // a whole note has four beats
    // check if the dot flag is set, if it is set, extend the duration in 50%
    if (dotFlag) calcDuration = (calcDuration*3)/2;
    // if the current note is not a pause, play the note using the sound function
    if (currentNote<255) playSound(note[tempOctave-4][currentNote],calcDuration);
 800392e:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 8003a14 <playRTTTLSong+0x260>
      while (*currSong == ',') currSong++;  // skip the ','
    }
    while (*currSong == ',') currSong++;    // skip the ','
    while (*currSong == ' ') currSong++;    // skip the ','
  }
  currSong++;                       // advance to the next character
 8003932:	1c5c      	adds	r4, r3, #1
  // read the musical notes
  while (*currSong)                 // repeat until the character is null
 8003934:	7823      	ldrb	r3, [r4, #0]
 8003936:	2b00      	cmp	r3, #0
 8003938:	d061      	beq.n	80039fe <playRTTTLSong+0x24a>
    currentNote = 255;         // default note = pause
    tempOctave = octave;       // set the octave to the music default
    tempDuration = duration;   // set the duration to the music default
    dotFlag = 0;               // clear the dot detection flag
    // look for a duration prefix
    if (*currSong>='0' && *currSong<='9')
 800393a:	3b30      	subs	r3, #48	; 0x30
 800393c:	b2db      	uxtb	r3, r3
 800393e:	2b09      	cmp	r3, #9
  currSong++;                       // advance to the next character
  // read the musical notes
  while (*currSong)                 // repeat until the character is null
  {
    currentNote = 255;         // default note = pause
    tempOctave = octave;       // set the octave to the music default
 8003940:	7838      	ldrb	r0, [r7, #0]
    tempDuration = duration;   // set the duration to the music default
 8003942:	f895 c000 	ldrb.w	ip, [r5]
    dotFlag = 0;               // clear the dot detection flag
    // look for a duration prefix
    if (*currSong>='0' && *currSong<='9')
 8003946:	d80e      	bhi.n	8003966 <playRTTTLSong+0x1b2>
    {
      tempDuration = *currSong - '0';
      currSong++;
      if (*currSong>='0' && *currSong<='9')
 8003948:	7861      	ldrb	r1, [r4, #1]
 800394a:	3930      	subs	r1, #48	; 0x30
 800394c:	b2c9      	uxtb	r1, r1
 800394e:	2909      	cmp	r1, #9
      {
        tempDuration = tempDuration*10 + (*currSong - '0');
 8003950:	bf99      	ittee	ls
 8003952:	eb03 0383 	addls.w	r3, r3, r3, lsl #2
 8003956:	eb01 0143 	addls.w	r1, r1, r3, lsl #1
    dotFlag = 0;               // clear the dot detection flag
    // look for a duration prefix
    if (*currSong>='0' && *currSong<='9')
    {
      tempDuration = *currSong - '0';
      currSong++;
 800395a:	3401      	addhi	r4, #1
 800395c:	469c      	movhi	ip, r3
      if (*currSong>='0' && *currSong<='9')
      {
        tempDuration = tempDuration*10 + (*currSong - '0');
 800395e:	bf9c      	itt	ls
 8003960:	f001 0cff 	andls.w	ip, r1, #255	; 0xff
        currSong++;
 8003964:	3402      	addls	r4, #2
 8003966:	7823      	ldrb	r3, [r4, #0]
 8003968:	3b61      	subs	r3, #97	; 0x61
 800396a:	b2db      	uxtb	r3, r3
 800396c:	2b06      	cmp	r3, #6
 800396e:	bf98      	it	ls
 8003970:	f818 2003 	ldrbls.w	r2, [r8, r3]
      case 'b': currentNote = 11; break;   // B (si)
      case 'p': currentNote = 255; break;  // pause
    }
    currSong++;                     // advance to the next character
    // look for a # following the note
    if (*currSong=='#')
 8003974:	7863      	ldrb	r3, [r4, #1]
        tempDuration = tempDuration*10 + (*currSong - '0');
        currSong++;
      }
    }
    // look for a note
    switch (*currSong)
 8003976:	bf88      	it	hi
 8003978:	22ff      	movhi	r2, #255	; 0xff
      case 'b': currentNote = 11; break;   // B (si)
      case 'p': currentNote = 255; break;  // pause
    }
    currSong++;                     // advance to the next character
    // look for a # following the note
    if (*currSong=='#')
 800397a:	2b23      	cmp	r3, #35	; 0x23
    {
      currentNote++;   // increment the note (A->A#, C->C#, D->D#, F->F#, G->G#)
      currSong++;                   // advance to the next character
 800397c:	bf0a      	itet	eq
 800397e:	1ca3      	addeq	r3, r4, #2
      case 'g': currentNote = 7; break;    // G (sol)
      case 'a': currentNote = 9; break;    // A (la)
      case 'b': currentNote = 11; break;   // B (si)
      case 'p': currentNote = 255; break;  // pause
    }
    currSong++;                     // advance to the next character
 8003980:	1c63      	addne	r3, r4, #1
    // look for a # following the note
    if (*currSong=='#')
    {
      currentNote++;   // increment the note (A->A#, C->C#, D->D#, F->F#, G->G#)
 8003982:	3201      	addeq	r2, #1
      currSong++;                   // advance to the next character
    }
    // look for a '.' (extend the note duration in 50%)
    if (*currSong=='.')
 8003984:	7819      	ldrb	r1, [r3, #0]
    }
    currSong++;                     // advance to the next character
    // look for a # following the note
    if (*currSong=='#')
    {
      currentNote++;   // increment the note (A->A#, C->C#, D->D#, F->F#, G->G#)
 8003986:	bf08      	it	eq
 8003988:	b2d2      	uxtbeq	r2, r2
      currSong++;                   // advance to the next character
    }
    // look for a '.' (extend the note duration in 50%)
    if (*currSong=='.')
 800398a:	292e      	cmp	r1, #46	; 0x2e
    {
      dotFlag = 1;             // if a '.' is found, set the flag
      currSong++;                   // advance to the next character
 800398c:	bf04      	itt	eq
 800398e:	3301      	addeq	r3, #1
      currSong++;                   // advance to the next character
    }
    // look for a '.' (extend the note duration in 50%)
    if (*currSong=='.')
    {
      dotFlag = 1;             // if a '.' is found, set the flag
 8003990:	f04f 0e01 	moveq.w	lr, #1
      currSong++;                   // advance to the next character
    }

    // look for an octave postfix
    if (*currSong>='0' && *currSong<='9')
 8003994:	7819      	ldrb	r1, [r3, #0]
 8003996:	f1a1 0130 	sub.w	r1, r1, #48	; 0x30
 800399a:	b2c9      	uxtb	r1, r1
  while (*currSong)                 // repeat until the character is null
  {
    currentNote = 255;         // default note = pause
    tempOctave = octave;       // set the octave to the music default
    tempDuration = duration;   // set the duration to the music default
    dotFlag = 0;               // clear the dot detection flag
 800399c:	bf18      	it	ne
 800399e:	f04f 0e00 	movne.w	lr, #0
      dotFlag = 1;             // if a '.' is found, set the flag
      currSong++;                   // advance to the next character
    }

    // look for an octave postfix
    if (*currSong>='0' && *currSong<='9')
 80039a2:	2909      	cmp	r1, #9
    {
      tempOctave = *currSong - '0';// the temporary octave is set accordingly
      currSong++;                   // advance to the next character
 80039a4:	bf9c      	itt	ls
 80039a6:	3301      	addls	r3, #1
 80039a8:	4608      	movls	r0, r1
    }
    if (*currSong=='.')             // a dot can also be found after the octave (???)
 80039aa:	7819      	ldrb	r1, [r3, #0]
 80039ac:	292e      	cmp	r1, #46	; 0x2e
    {
      dotFlag = 1;             // if a '.' is found, set the flag
      currSong++;                   // advance to the next character
 80039ae:	bf04      	itt	eq
 80039b0:	3301      	addeq	r3, #1
      tempOctave = *currSong - '0';// the temporary octave is set accordingly
      currSong++;                   // advance to the next character
    }
    if (*currSong=='.')             // a dot can also be found after the octave (???)
    {
      dotFlag = 1;             // if a '.' is found, set the flag
 80039b2:	f04f 0e01 	moveq.w	lr, #1
 80039b6:	461c      	mov	r4, r3
 80039b8:	3301      	adds	r3, #1
      currSong++;                   // advance to the next character
    }
    while (*currSong == ',') currSong++;    // skip the ','
 80039ba:	7821      	ldrb	r1, [r4, #0]
 80039bc:	292c      	cmp	r1, #44	; 0x2c
 80039be:	d0fa      	beq.n	80039b6 <playRTTTLSong+0x202>
    // calculate the note duration
    calcDuration = (60000/tempo)/(tempDuration);
 80039c0:	8831      	ldrh	r1, [r6, #0]
 80039c2:	f64e 2360 	movw	r3, #60000	; 0xea60
 80039c6:	fb93 f1f1 	sdiv	r1, r3, r1
 80039ca:	fb91 f1fc 	sdiv	r1, r1, ip
    calcDuration *= 4;         // a whole note has four beats
 80039ce:	0089      	lsls	r1, r1, #2
 80039d0:	b289      	uxth	r1, r1
    // check if the dot flag is set, if it is set, extend the duration in 50%
    if (dotFlag) calcDuration = (calcDuration*3)/2;
 80039d2:	f1be 0f00 	cmp.w	lr, #0
 80039d6:	d003      	beq.n	80039e0 <playRTTTLSong+0x22c>
 80039d8:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 80039dc:	1049      	asrs	r1, r1, #1
 80039de:	b289      	uxth	r1, r1
    // if the current note is not a pause, play the note using the sound function
    if (currentNote<255) playSound(note[tempOctave-4][currentNote],calcDuration);
 80039e0:	2aff      	cmp	r2, #255	; 0xff
 80039e2:	d008      	beq.n	80039f6 <playRTTTLSong+0x242>
 80039e4:	3804      	subs	r0, #4
 80039e6:	230c      	movs	r3, #12
 80039e8:	fb03 2200 	mla	r2, r3, r0, r2
 80039ec:	f839 0012 	ldrh.w	r0, [r9, r2, lsl #1]
 80039f0:	f7ff fed2 	bl	8003798 <playSound>
 80039f4:	e79e      	b.n	8003934 <playRTTTLSong+0x180>
    else { // if the current note = 255 (pause), just wait for the specified amount of time
    	HAL_Delay(calcDuration);
 80039f6:	4608      	mov	r0, r1
 80039f8:	f7fd fa76 	bl	8000ee8 <HAL_Delay>
 80039fc:	e79a      	b.n	8003934 <playRTTTLSong+0x180>
    }
  }
}
 80039fe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8003a02:	bf00      	nop
 8003a04:	2000014c 	.word	0x2000014c
 8003a08:	2000014e 	.word	0x2000014e
 8003a0c:	2000014d 	.word	0x2000014d
 8003a10:	080079d7 	.word	0x080079d7
 8003a14:	080079de 	.word	0x080079de

08003a18 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8003a18:	4b21      	ldr	r3, [pc, #132]	; (8003aa0 <HAL_MspInit+0x88>)
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8003a1a:	b507      	push	{r0, r1, r2, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8003a1c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8003a1e:	f042 0201 	orr.w	r2, r2, #1
 8003a22:	661a      	str	r2, [r3, #96]	; 0x60
 8003a24:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8003a26:	f002 0201 	and.w	r2, r2, #1
 8003a2a:	9200      	str	r2, [sp, #0]
 8003a2c:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8003a2e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8003a30:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8003a34:	659a      	str	r2, [r3, #88]	; 0x58
 8003a36:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003a38:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003a3c:	9301      	str	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8003a3e:	2003      	movs	r0, #3
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
  __HAL_RCC_PWR_CLK_ENABLE();
 8003a40:	9b01      	ldr	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8003a42:	f7fd fa5f 	bl	8000f04 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 8003a46:	2200      	movs	r2, #0
 8003a48:	4611      	mov	r1, r2
 8003a4a:	f06f 000b 	mvn.w	r0, #11
 8003a4e:	f7fd fa6b 	bl	8000f28 <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 8003a52:	2200      	movs	r2, #0
 8003a54:	4611      	mov	r1, r2
 8003a56:	f06f 000a 	mvn.w	r0, #10
 8003a5a:	f7fd fa65 	bl	8000f28 <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 8003a5e:	2200      	movs	r2, #0
 8003a60:	4611      	mov	r1, r2
 8003a62:	f06f 0009 	mvn.w	r0, #9
 8003a66:	f7fd fa5f 	bl	8000f28 <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 8003a6a:	2200      	movs	r2, #0
 8003a6c:	4611      	mov	r1, r2
 8003a6e:	f06f 0004 	mvn.w	r0, #4
 8003a72:	f7fd fa59 	bl	8000f28 <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 8003a76:	2200      	movs	r2, #0
 8003a78:	4611      	mov	r1, r2
 8003a7a:	f06f 0003 	mvn.w	r0, #3
 8003a7e:	f7fd fa53 	bl	8000f28 <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
 8003a82:	2200      	movs	r2, #0
 8003a84:	4611      	mov	r1, r2
 8003a86:	f06f 0001 	mvn.w	r0, #1
 8003a8a:	f7fd fa4d 	bl	8000f28 <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8003a8e:	2200      	movs	r2, #0
 8003a90:	4611      	mov	r1, r2
 8003a92:	f04f 30ff 	mov.w	r0, #4294967295
 8003a96:	f7fd fa47 	bl	8000f28 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8003a9a:	b003      	add	sp, #12
 8003a9c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003aa0:	40021000 	.word	0x40021000

08003aa4 <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8003aa4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hspi->Instance==SPI1)
 8003aa6:	6802      	ldr	r2, [r0, #0]
 8003aa8:	4b0f      	ldr	r3, [pc, #60]	; (8003ae8 <HAL_SPI_MspInit+0x44>)
 8003aaa:	429a      	cmp	r2, r3
 8003aac:	d118      	bne.n	8003ae0 <HAL_SPI_MspInit+0x3c>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8003aae:	f503 4360 	add.w	r3, r3, #57344	; 0xe000
    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8003ab2:	a901      	add	r1, sp, #4
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8003ab4:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8003ab6:	480d      	ldr	r0, [pc, #52]	; (8003aec <HAL_SPI_MspInit+0x48>)
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8003ab8:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8003abc:	661a      	str	r2, [r3, #96]	; 0x60
 8003abe:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8003ac0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8003ac4:	9300      	str	r3, [sp, #0]
 8003ac6:	9b00      	ldr	r3, [sp, #0]
  
    /**SPI1 GPIO Configuration    
    PB3 (JTDO-TRACESWO)     ------> SPI1_SCK
    PB5     ------> SPI1_MOSI 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_5;
 8003ac8:	2328      	movs	r3, #40	; 0x28
 8003aca:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8003acc:	2302      	movs	r3, #2
 8003ace:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003ad0:	2300      	movs	r3, #0
 8003ad2:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8003ad4:	2303      	movs	r3, #3
 8003ad6:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 8003ad8:	2305      	movs	r3, #5
 8003ada:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8003adc:	f7fd fa80 	bl	8000fe0 <HAL_GPIO_Init>
  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }

}
 8003ae0:	b007      	add	sp, #28
 8003ae2:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ae6:	bf00      	nop
 8003ae8:	40013000 	.word	0x40013000
 8003aec:	48000400 	.word	0x48000400

08003af0 <HAL_TIM_PWM_MspInit>:
}

void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* htim_pwm)
{

  if(htim_pwm->Instance==TIM1)
 8003af0:	6803      	ldr	r3, [r0, #0]
 8003af2:	4a0f      	ldr	r2, [pc, #60]	; (8003b30 <HAL_TIM_PWM_MspInit+0x40>)
 8003af4:	4293      	cmp	r3, r2
  }

}

void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* htim_pwm)
{
 8003af6:	b082      	sub	sp, #8

  if(htim_pwm->Instance==TIM1)
 8003af8:	d10a      	bne.n	8003b10 <HAL_TIM_PWM_MspInit+0x20>
  {
  /* USER CODE BEGIN TIM1_MspInit 0 */

  /* USER CODE END TIM1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM1_CLK_ENABLE();
 8003afa:	4b0e      	ldr	r3, [pc, #56]	; (8003b34 <HAL_TIM_PWM_MspInit+0x44>)
 8003afc:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8003afe:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8003b02:	661a      	str	r2, [r3, #96]	; 0x60
 8003b04:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8003b06:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8003b0a:	9300      	str	r3, [sp, #0]
 8003b0c:	9b00      	ldr	r3, [sp, #0]
 8003b0e:	e00d      	b.n	8003b2c <HAL_TIM_PWM_MspInit+0x3c>
  /* USER CODE BEGIN TIM1_MspInit 1 */

  /* USER CODE END TIM1_MspInit 1 */
  }
  else if(htim_pwm->Instance==TIM2)
 8003b10:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8003b14:	d10a      	bne.n	8003b2c <HAL_TIM_PWM_MspInit+0x3c>
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();
 8003b16:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 8003b1a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8003b1c:	f042 0201 	orr.w	r2, r2, #1
 8003b20:	659a      	str	r2, [r3, #88]	; 0x58
 8003b22:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003b24:	f003 0301 	and.w	r3, r3, #1
 8003b28:	9301      	str	r3, [sp, #4]
 8003b2a:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }

}
 8003b2c:	b002      	add	sp, #8
 8003b2e:	4770      	bx	lr
 8003b30:	40012c00 	.word	0x40012c00
 8003b34:	40021000 	.word	0x40021000

08003b38 <HAL_TIM_MspPostInit>:

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
 8003b38:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(htim->Instance==TIM1)
 8003b3a:	6803      	ldr	r3, [r0, #0]
 8003b3c:	4a0c      	ldr	r2, [pc, #48]	; (8003b70 <HAL_TIM_MspPostInit+0x38>)
 8003b3e:	4293      	cmp	r3, r2
 8003b40:	d101      	bne.n	8003b46 <HAL_TIM_MspPostInit+0xe>

  /* USER CODE END TIM1_MspPostInit 0 */
    /**TIM1 GPIO Configuration    
    PA7     ------> TIM1_CH1N 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_7;
 8003b42:	2380      	movs	r3, #128	; 0x80
 8003b44:	e003      	b.n	8003b4e <HAL_TIM_MspPostInit+0x16>

  /* USER CODE BEGIN TIM1_MspPostInit 1 */

  /* USER CODE END TIM1_MspPostInit 1 */
  }
  else if(htim->Instance==TIM2)
 8003b46:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8003b4a:	d10d      	bne.n	8003b68 <HAL_TIM_MspPostInit+0x30>
    /**TIM2 GPIO Configuration    
    PA1     ------> TIM2_CH2
    PA3     ------> TIM2_CH4
    PA5     ------> TIM2_CH1 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_3|GPIO_PIN_5;
 8003b4c:	232a      	movs	r3, #42	; 0x2a
 8003b4e:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8003b50:	2302      	movs	r3, #2
 8003b52:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003b54:	2300      	movs	r3, #0
 8003b56:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8003b58:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003b5a:	a901      	add	r1, sp, #4
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_3|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8003b5c:	2301      	movs	r3, #1
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003b5e:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_3|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8003b62:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003b64:	f7fd fa3c 	bl	8000fe0 <HAL_GPIO_Init>
  /* USER CODE BEGIN TIM2_MspPostInit 1 */

  /* USER CODE END TIM2_MspPostInit 1 */
  }

}
 8003b68:	b007      	add	sp, #28
 8003b6a:	f85d fb04 	ldr.w	pc, [sp], #4
 8003b6e:	bf00      	nop
 8003b70:	40012c00 	.word	0x40012c00

08003b74 <HAL_UART_MspInit>:
  }

}

void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8003b74:	b570      	push	{r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(huart->Instance==USART2)
 8003b76:	6802      	ldr	r2, [r0, #0]
 8003b78:	4b15      	ldr	r3, [pc, #84]	; (8003bd0 <HAL_UART_MspInit+0x5c>)
 8003b7a:	429a      	cmp	r2, r3
  }

}

void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8003b7c:	b086      	sub	sp, #24

  GPIO_InitTypeDef GPIO_InitStruct;
  if(huart->Instance==USART2)
 8003b7e:	d125      	bne.n	8003bcc <HAL_UART_MspInit+0x58>
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 8003b80:	f503 33e6 	add.w	r3, r3, #117760	; 0x1cc00
    PA15 (JTDI)     ------> USART2_RX 
    */
    GPIO_InitStruct.Pin = VCP_TX_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8003b84:	2403      	movs	r4, #3
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 8003b86:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8003b88:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8003b8c:	659a      	str	r2, [r3, #88]	; 0x58
 8003b8e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    PA15 (JTDI)     ------> USART2_RX 
    */
    GPIO_InitStruct.Pin = VCP_TX_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8003b90:	9404      	str	r4, [sp, #16]
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 8003b92:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003b96:	9300      	str	r3, [sp, #0]
 8003b98:	9b00      	ldr	r3, [sp, #0]
  
    /**USART2 GPIO Configuration    
    PA2     ------> USART2_TX
    PA15 (JTDI)     ------> USART2_RX 
    */
    GPIO_InitStruct.Pin = VCP_TX_Pin;
 8003b9a:	2304      	movs	r3, #4
 8003b9c:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8003b9e:	2602      	movs	r6, #2
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8003ba0:	2307      	movs	r3, #7
    PA2     ------> USART2_TX
    PA15 (JTDI)     ------> USART2_RX 
    */
    GPIO_InitStruct.Pin = VCP_TX_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8003ba2:	2501      	movs	r5, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(VCP_TX_GPIO_Port, &GPIO_InitStruct);
 8003ba4:	a901      	add	r1, sp, #4
 8003ba6:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    */
    GPIO_InitStruct.Pin = VCP_TX_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8003baa:	9305      	str	r3, [sp, #20]
    /**USART2 GPIO Configuration    
    PA2     ------> USART2_TX
    PA15 (JTDI)     ------> USART2_RX 
    */
    GPIO_InitStruct.Pin = VCP_TX_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8003bac:	9602      	str	r6, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8003bae:	9503      	str	r5, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(VCP_TX_GPIO_Port, &GPIO_InitStruct);
 8003bb0:	f7fd fa16 	bl	8000fe0 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = VCP_RX_Pin;
 8003bb4:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF3_USART2;
    HAL_GPIO_Init(VCP_RX_GPIO_Port, &GPIO_InitStruct);
 8003bb8:	a901      	add	r1, sp, #4
 8003bba:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(VCP_TX_GPIO_Port, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = VCP_RX_Pin;
 8003bbe:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8003bc0:	9602      	str	r6, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8003bc2:	9503      	str	r5, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8003bc4:	9404      	str	r4, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF3_USART2;
 8003bc6:	9405      	str	r4, [sp, #20]
    HAL_GPIO_Init(VCP_RX_GPIO_Port, &GPIO_InitStruct);
 8003bc8:	f7fd fa0a 	bl	8000fe0 <HAL_GPIO_Init>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }

}
 8003bcc:	b006      	add	sp, #24
 8003bce:	bd70      	pop	{r4, r5, r6, pc}
 8003bd0:	40004400 	.word	0x40004400

08003bd4 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 8003bd4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8003bd6:	f7fd f979 	bl	8000ecc <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8003bda:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  HAL_SYSTICK_IRQHandler();
 8003bde:	f7fd b9fa 	b.w	8000fd6 <HAL_SYSTICK_IRQHandler>
	...

08003be4 <_write>:
{
	while (1) {}		/* Make sure we hang here */
}

int _write(int32_t file, uint8_t *ptr, int32_t len)
{
 8003be4:	b510      	push	{r4, lr}
	HAL_StatusTypeDef result = HAL_OK;
	result = HAL_UART_Transmit(&huart2,ptr,len,500);
 8003be6:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
{
	while (1) {}		/* Make sure we hang here */
}

int _write(int32_t file, uint8_t *ptr, int32_t len)
{
 8003bea:	4614      	mov	r4, r2
	HAL_StatusTypeDef result = HAL_OK;
	result = HAL_UART_Transmit(&huart2,ptr,len,500);
 8003bec:	4802      	ldr	r0, [pc, #8]	; (8003bf8 <_write+0x14>)
 8003bee:	b292      	uxth	r2, r2
 8003bf0:	f7fe ff3d 	bl	8002a6e <HAL_UART_Transmit>
	if(result == HAL_ERROR|| result == HAL_BUSY)
	{
		//Error_Handler();
	}
	return len;
}
 8003bf4:	4620      	mov	r0, r4
 8003bf6:	bd10      	pop	{r4, pc}
 8003bf8:	2000023c 	.word	0x2000023c

08003bfc <_sbrk>:
{
	extern char   end; /* Set by linker.  */
	static char * heap_end;
	char *        prev_heap_end;

	if (heap_end == 0) {
 8003bfc:	4b04      	ldr	r3, [pc, #16]	; (8003c10 <_sbrk+0x14>)
 8003bfe:	6819      	ldr	r1, [r3, #0]
	}
	return len;
}

void * _sbrk(int32_t incr)
{
 8003c00:	4602      	mov	r2, r0
	extern char   end; /* Set by linker.  */
	static char * heap_end;
	char *        prev_heap_end;

	if (heap_end == 0) {
 8003c02:	b909      	cbnz	r1, 8003c08 <_sbrk+0xc>
		heap_end = & end;
 8003c04:	4903      	ldr	r1, [pc, #12]	; (8003c14 <_sbrk+0x18>)
 8003c06:	6019      	str	r1, [r3, #0]
	}

	prev_heap_end = heap_end;
 8003c08:	6818      	ldr	r0, [r3, #0]
	heap_end += incr;
 8003c0a:	4402      	add	r2, r0
 8003c0c:	601a      	str	r2, [r3, #0]

	return (void *) prev_heap_end;
}
 8003c0e:	4770      	bx	lr
 8003c10:	20000150 	.word	0x20000150
 8003c14:	200002b0 	.word	0x200002b0

08003c18 <_close>:

int _close(int32_t file)
{
	errno = ENOSYS;
 8003c18:	4b02      	ldr	r3, [pc, #8]	; (8003c24 <_close+0xc>)
 8003c1a:	2258      	movs	r2, #88	; 0x58
 8003c1c:	601a      	str	r2, [r3, #0]
	return -1;
}
 8003c1e:	f04f 30ff 	mov.w	r0, #4294967295
 8003c22:	4770      	bx	lr
 8003c24:	200002ac 	.word	0x200002ac

08003c28 <_fstat>:


int _fstat(int32_t file, struct stat *st)
{
	errno = ENOSYS;
 8003c28:	4b02      	ldr	r3, [pc, #8]	; (8003c34 <_fstat+0xc>)
 8003c2a:	2258      	movs	r2, #88	; 0x58
 8003c2c:	601a      	str	r2, [r3, #0]
	return -1;
}
 8003c2e:	f04f 30ff 	mov.w	r0, #4294967295
 8003c32:	4770      	bx	lr
 8003c34:	200002ac 	.word	0x200002ac

08003c38 <_isatty>:

int _isatty(int32_t file)
{
	errno = ENOSYS;
 8003c38:	4b02      	ldr	r3, [pc, #8]	; (8003c44 <_isatty+0xc>)
 8003c3a:	2258      	movs	r2, #88	; 0x58
 8003c3c:	601a      	str	r2, [r3, #0]
	return 0;
}
 8003c3e:	2000      	movs	r0, #0
 8003c40:	4770      	bx	lr
 8003c42:	bf00      	nop
 8003c44:	200002ac 	.word	0x200002ac

08003c48 <_lseek>:

int _lseek(int32_t file, int32_t ptr, int32_t dir)
{
	errno = ENOSYS;
 8003c48:	4b02      	ldr	r3, [pc, #8]	; (8003c54 <_lseek+0xc>)
 8003c4a:	2258      	movs	r2, #88	; 0x58
 8003c4c:	601a      	str	r2, [r3, #0]
	return -1;
}
 8003c4e:	f04f 30ff 	mov.w	r0, #4294967295
 8003c52:	4770      	bx	lr
 8003c54:	200002ac 	.word	0x200002ac

08003c58 <_read>:

int _read(int32_t file, uint8_t *ptr, int32_t len)
{
 8003c58:	b508      	push	{r3, lr}
	HAL_UART_Receive(&huart2,ptr,1,HAL_MAX_DELAY);
 8003c5a:	2201      	movs	r2, #1
 8003c5c:	f04f 33ff 	mov.w	r3, #4294967295
 8003c60:	4802      	ldr	r0, [pc, #8]	; (8003c6c <_read+0x14>)
 8003c62:	f7fe ff5e 	bl	8002b22 <HAL_UART_Receive>
	return 1;
}
 8003c66:	2001      	movs	r0, #1
 8003c68:	bd08      	pop	{r3, pc}
 8003c6a:	bf00      	nop
 8003c6c:	2000023c 	.word	0x2000023c

08003c70 <SystemInit>:

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8003c70:	490f      	ldr	r1, [pc, #60]	; (8003cb0 <SystemInit+0x40>)
 8003c72:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8003c76:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8003c7a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8003c7e:	4b0d      	ldr	r3, [pc, #52]	; (8003cb4 <SystemInit+0x44>)
 8003c80:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8003c82:	2000      	movs	r0, #0
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8003c84:	f042 0201 	orr.w	r2, r2, #1
 8003c88:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8003c8a:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= (uint32_t)0xEAF6FFFF;
 8003c8c:	681a      	ldr	r2, [r3, #0]
 8003c8e:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
 8003c92:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
 8003c96:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000;
 8003c98:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8003c9c:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8003c9e:	681a      	ldr	r2, [r3, #0]
 8003ca0:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8003ca4:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 8003ca6:	6198      	str	r0, [r3, #24]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8003ca8:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8003cac:	608b      	str	r3, [r1, #8]
 8003cae:	4770      	bx	lr
 8003cb0:	e000ed00 	.word	0xe000ed00
 8003cb4:	40021000 	.word	0x40021000

08003cb8 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8003cb8:	f8df d034 	ldr.w	sp, [pc, #52]	; 8003cf0 <LoopForever+0x2>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8003cbc:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8003cbe:	e003      	b.n	8003cc8 <LoopCopyDataInit>

08003cc0 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8003cc0:	4b0c      	ldr	r3, [pc, #48]	; (8003cf4 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 8003cc2:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8003cc4:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 8003cc6:	3104      	adds	r1, #4

08003cc8 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 8003cc8:	480b      	ldr	r0, [pc, #44]	; (8003cf8 <LoopForever+0xa>)
	ldr	r3, =_edata
 8003cca:	4b0c      	ldr	r3, [pc, #48]	; (8003cfc <LoopForever+0xe>)
	adds	r2, r0, r1
 8003ccc:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8003cce:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8003cd0:	d3f6      	bcc.n	8003cc0 <CopyDataInit>
	ldr	r2, =_sbss
 8003cd2:	4a0b      	ldr	r2, [pc, #44]	; (8003d00 <LoopForever+0x12>)
	b	LoopFillZerobss
 8003cd4:	e002      	b.n	8003cdc <LoopFillZerobss>

08003cd6 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 8003cd6:	2300      	movs	r3, #0
	str	r3, [r2], #4
 8003cd8:	f842 3b04 	str.w	r3, [r2], #4

08003cdc <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 8003cdc:	4b09      	ldr	r3, [pc, #36]	; (8003d04 <LoopForever+0x16>)
	cmp	r2, r3
 8003cde:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8003ce0:	d3f9      	bcc.n	8003cd6 <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 8003ce2:	f7ff ffc5 	bl	8003c70 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8003ce6:	f000 f811 	bl	8003d0c <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 8003cea:	f7ff fb8d 	bl	8003408 <main>

08003cee <LoopForever>:

LoopForever:
    b LoopForever
 8003cee:	e7fe      	b.n	8003cee <LoopForever>

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8003cf0:	20010000 	.word	0x20010000
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
 8003cf4:	08007df8 	.word	0x08007df8
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
 8003cf8:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8003cfc:	20000114 	.word	0x20000114
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
 8003d00:	20000114 	.word	0x20000114
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
 8003d04:	200002b0 	.word	0x200002b0

08003d08 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8003d08:	e7fe      	b.n	8003d08 <ADC1_IRQHandler>
	...

08003d0c <__libc_init_array>:
 8003d0c:	b570      	push	{r4, r5, r6, lr}
 8003d0e:	4b0e      	ldr	r3, [pc, #56]	; (8003d48 <__libc_init_array+0x3c>)
 8003d10:	4c0e      	ldr	r4, [pc, #56]	; (8003d4c <__libc_init_array+0x40>)
 8003d12:	1ae4      	subs	r4, r4, r3
 8003d14:	10a4      	asrs	r4, r4, #2
 8003d16:	2500      	movs	r5, #0
 8003d18:	461e      	mov	r6, r3
 8003d1a:	42a5      	cmp	r5, r4
 8003d1c:	d004      	beq.n	8003d28 <__libc_init_array+0x1c>
 8003d1e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8003d22:	4798      	blx	r3
 8003d24:	3501      	adds	r5, #1
 8003d26:	e7f8      	b.n	8003d1a <__libc_init_array+0xe>
 8003d28:	f002 fae6 	bl	80062f8 <_init>
 8003d2c:	4c08      	ldr	r4, [pc, #32]	; (8003d50 <__libc_init_array+0x44>)
 8003d2e:	4b09      	ldr	r3, [pc, #36]	; (8003d54 <__libc_init_array+0x48>)
 8003d30:	1ae4      	subs	r4, r4, r3
 8003d32:	10a4      	asrs	r4, r4, #2
 8003d34:	2500      	movs	r5, #0
 8003d36:	461e      	mov	r6, r3
 8003d38:	42a5      	cmp	r5, r4
 8003d3a:	d004      	beq.n	8003d46 <__libc_init_array+0x3a>
 8003d3c:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8003d40:	4798      	blx	r3
 8003d42:	3501      	adds	r5, #1
 8003d44:	e7f8      	b.n	8003d38 <__libc_init_array+0x2c>
 8003d46:	bd70      	pop	{r4, r5, r6, pc}
 8003d48:	08007df0 	.word	0x08007df0
 8003d4c:	08007df0 	.word	0x08007df0
 8003d50:	08007df4 	.word	0x08007df4
 8003d54:	08007df0 	.word	0x08007df0

08003d58 <memset>:
 8003d58:	4402      	add	r2, r0
 8003d5a:	4603      	mov	r3, r0
 8003d5c:	4293      	cmp	r3, r2
 8003d5e:	d002      	beq.n	8003d66 <memset+0xe>
 8003d60:	f803 1b01 	strb.w	r1, [r3], #1
 8003d64:	e7fa      	b.n	8003d5c <memset+0x4>
 8003d66:	4770      	bx	lr

08003d68 <_free_r>:
 8003d68:	b538      	push	{r3, r4, r5, lr}
 8003d6a:	4605      	mov	r5, r0
 8003d6c:	2900      	cmp	r1, #0
 8003d6e:	d046      	beq.n	8003dfe <_free_r+0x96>
 8003d70:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8003d74:	1f0c      	subs	r4, r1, #4
 8003d76:	2b00      	cmp	r3, #0
 8003d78:	bfb8      	it	lt
 8003d7a:	18e4      	addlt	r4, r4, r3
 8003d7c:	f000 fbf6 	bl	800456c <__malloc_lock>
 8003d80:	4a1f      	ldr	r2, [pc, #124]	; (8003e00 <_free_r+0x98>)
 8003d82:	6813      	ldr	r3, [r2, #0]
 8003d84:	4611      	mov	r1, r2
 8003d86:	b913      	cbnz	r3, 8003d8e <_free_r+0x26>
 8003d88:	6063      	str	r3, [r4, #4]
 8003d8a:	6014      	str	r4, [r2, #0]
 8003d8c:	e032      	b.n	8003df4 <_free_r+0x8c>
 8003d8e:	42a3      	cmp	r3, r4
 8003d90:	d90e      	bls.n	8003db0 <_free_r+0x48>
 8003d92:	6822      	ldr	r2, [r4, #0]
 8003d94:	18a0      	adds	r0, r4, r2
 8003d96:	4283      	cmp	r3, r0
 8003d98:	bf04      	itt	eq
 8003d9a:	6818      	ldreq	r0, [r3, #0]
 8003d9c:	685b      	ldreq	r3, [r3, #4]
 8003d9e:	6063      	str	r3, [r4, #4]
 8003da0:	bf04      	itt	eq
 8003da2:	1812      	addeq	r2, r2, r0
 8003da4:	6022      	streq	r2, [r4, #0]
 8003da6:	600c      	str	r4, [r1, #0]
 8003da8:	e024      	b.n	8003df4 <_free_r+0x8c>
 8003daa:	42a2      	cmp	r2, r4
 8003dac:	d803      	bhi.n	8003db6 <_free_r+0x4e>
 8003dae:	4613      	mov	r3, r2
 8003db0:	685a      	ldr	r2, [r3, #4]
 8003db2:	2a00      	cmp	r2, #0
 8003db4:	d1f9      	bne.n	8003daa <_free_r+0x42>
 8003db6:	6818      	ldr	r0, [r3, #0]
 8003db8:	1819      	adds	r1, r3, r0
 8003dba:	42a1      	cmp	r1, r4
 8003dbc:	d10b      	bne.n	8003dd6 <_free_r+0x6e>
 8003dbe:	6821      	ldr	r1, [r4, #0]
 8003dc0:	4401      	add	r1, r0
 8003dc2:	1858      	adds	r0, r3, r1
 8003dc4:	4282      	cmp	r2, r0
 8003dc6:	6019      	str	r1, [r3, #0]
 8003dc8:	d114      	bne.n	8003df4 <_free_r+0x8c>
 8003dca:	6810      	ldr	r0, [r2, #0]
 8003dcc:	6852      	ldr	r2, [r2, #4]
 8003dce:	605a      	str	r2, [r3, #4]
 8003dd0:	4401      	add	r1, r0
 8003dd2:	6019      	str	r1, [r3, #0]
 8003dd4:	e00e      	b.n	8003df4 <_free_r+0x8c>
 8003dd6:	d902      	bls.n	8003dde <_free_r+0x76>
 8003dd8:	230c      	movs	r3, #12
 8003dda:	602b      	str	r3, [r5, #0]
 8003ddc:	e00a      	b.n	8003df4 <_free_r+0x8c>
 8003dde:	6821      	ldr	r1, [r4, #0]
 8003de0:	1860      	adds	r0, r4, r1
 8003de2:	4282      	cmp	r2, r0
 8003de4:	bf04      	itt	eq
 8003de6:	6810      	ldreq	r0, [r2, #0]
 8003de8:	6852      	ldreq	r2, [r2, #4]
 8003dea:	6062      	str	r2, [r4, #4]
 8003dec:	bf04      	itt	eq
 8003dee:	1809      	addeq	r1, r1, r0
 8003df0:	6021      	streq	r1, [r4, #0]
 8003df2:	605c      	str	r4, [r3, #4]
 8003df4:	4628      	mov	r0, r5
 8003df6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8003dfa:	f000 bbb8 	b.w	800456e <__malloc_unlock>
 8003dfe:	bd38      	pop	{r3, r4, r5, pc}
 8003e00:	20000158 	.word	0x20000158

08003e04 <_malloc_r>:
 8003e04:	b570      	push	{r4, r5, r6, lr}
 8003e06:	1ccd      	adds	r5, r1, #3
 8003e08:	f025 0503 	bic.w	r5, r5, #3
 8003e0c:	3508      	adds	r5, #8
 8003e0e:	2d0c      	cmp	r5, #12
 8003e10:	bf38      	it	cc
 8003e12:	250c      	movcc	r5, #12
 8003e14:	2d00      	cmp	r5, #0
 8003e16:	4606      	mov	r6, r0
 8003e18:	db01      	blt.n	8003e1e <_malloc_r+0x1a>
 8003e1a:	42a9      	cmp	r1, r5
 8003e1c:	d902      	bls.n	8003e24 <_malloc_r+0x20>
 8003e1e:	230c      	movs	r3, #12
 8003e20:	6033      	str	r3, [r6, #0]
 8003e22:	e046      	b.n	8003eb2 <_malloc_r+0xae>
 8003e24:	f000 fba2 	bl	800456c <__malloc_lock>
 8003e28:	4b23      	ldr	r3, [pc, #140]	; (8003eb8 <_malloc_r+0xb4>)
 8003e2a:	681c      	ldr	r4, [r3, #0]
 8003e2c:	461a      	mov	r2, r3
 8003e2e:	4621      	mov	r1, r4
 8003e30:	b1a1      	cbz	r1, 8003e5c <_malloc_r+0x58>
 8003e32:	680b      	ldr	r3, [r1, #0]
 8003e34:	1b5b      	subs	r3, r3, r5
 8003e36:	d40e      	bmi.n	8003e56 <_malloc_r+0x52>
 8003e38:	2b0b      	cmp	r3, #11
 8003e3a:	d903      	bls.n	8003e44 <_malloc_r+0x40>
 8003e3c:	600b      	str	r3, [r1, #0]
 8003e3e:	18cc      	adds	r4, r1, r3
 8003e40:	50cd      	str	r5, [r1, r3]
 8003e42:	e01e      	b.n	8003e82 <_malloc_r+0x7e>
 8003e44:	428c      	cmp	r4, r1
 8003e46:	bf0d      	iteet	eq
 8003e48:	6863      	ldreq	r3, [r4, #4]
 8003e4a:	684b      	ldrne	r3, [r1, #4]
 8003e4c:	6063      	strne	r3, [r4, #4]
 8003e4e:	6013      	streq	r3, [r2, #0]
 8003e50:	bf18      	it	ne
 8003e52:	460c      	movne	r4, r1
 8003e54:	e015      	b.n	8003e82 <_malloc_r+0x7e>
 8003e56:	460c      	mov	r4, r1
 8003e58:	6849      	ldr	r1, [r1, #4]
 8003e5a:	e7e9      	b.n	8003e30 <_malloc_r+0x2c>
 8003e5c:	4c17      	ldr	r4, [pc, #92]	; (8003ebc <_malloc_r+0xb8>)
 8003e5e:	6823      	ldr	r3, [r4, #0]
 8003e60:	b91b      	cbnz	r3, 8003e6a <_malloc_r+0x66>
 8003e62:	4630      	mov	r0, r6
 8003e64:	f000 f88e 	bl	8003f84 <_sbrk_r>
 8003e68:	6020      	str	r0, [r4, #0]
 8003e6a:	4629      	mov	r1, r5
 8003e6c:	4630      	mov	r0, r6
 8003e6e:	f000 f889 	bl	8003f84 <_sbrk_r>
 8003e72:	1c43      	adds	r3, r0, #1
 8003e74:	d018      	beq.n	8003ea8 <_malloc_r+0xa4>
 8003e76:	1cc4      	adds	r4, r0, #3
 8003e78:	f024 0403 	bic.w	r4, r4, #3
 8003e7c:	42a0      	cmp	r0, r4
 8003e7e:	d10d      	bne.n	8003e9c <_malloc_r+0x98>
 8003e80:	6025      	str	r5, [r4, #0]
 8003e82:	4630      	mov	r0, r6
 8003e84:	f000 fb73 	bl	800456e <__malloc_unlock>
 8003e88:	f104 000b 	add.w	r0, r4, #11
 8003e8c:	1d23      	adds	r3, r4, #4
 8003e8e:	f020 0007 	bic.w	r0, r0, #7
 8003e92:	1ac3      	subs	r3, r0, r3
 8003e94:	d00e      	beq.n	8003eb4 <_malloc_r+0xb0>
 8003e96:	425a      	negs	r2, r3
 8003e98:	50e2      	str	r2, [r4, r3]
 8003e9a:	bd70      	pop	{r4, r5, r6, pc}
 8003e9c:	1a21      	subs	r1, r4, r0
 8003e9e:	4630      	mov	r0, r6
 8003ea0:	f000 f870 	bl	8003f84 <_sbrk_r>
 8003ea4:	3001      	adds	r0, #1
 8003ea6:	d1eb      	bne.n	8003e80 <_malloc_r+0x7c>
 8003ea8:	230c      	movs	r3, #12
 8003eaa:	6033      	str	r3, [r6, #0]
 8003eac:	4630      	mov	r0, r6
 8003eae:	f000 fb5e 	bl	800456e <__malloc_unlock>
 8003eb2:	2000      	movs	r0, #0
 8003eb4:	bd70      	pop	{r4, r5, r6, pc}
 8003eb6:	bf00      	nop
 8003eb8:	20000158 	.word	0x20000158
 8003ebc:	20000154 	.word	0x20000154

08003ec0 <_puts_r>:
 8003ec0:	b570      	push	{r4, r5, r6, lr}
 8003ec2:	460e      	mov	r6, r1
 8003ec4:	4605      	mov	r5, r0
 8003ec6:	b118      	cbz	r0, 8003ed0 <_puts_r+0x10>
 8003ec8:	6983      	ldr	r3, [r0, #24]
 8003eca:	b90b      	cbnz	r3, 8003ed0 <_puts_r+0x10>
 8003ecc:	f000 fa48 	bl	8004360 <__sinit>
 8003ed0:	69ab      	ldr	r3, [r5, #24]
 8003ed2:	68ac      	ldr	r4, [r5, #8]
 8003ed4:	b913      	cbnz	r3, 8003edc <_puts_r+0x1c>
 8003ed6:	4628      	mov	r0, r5
 8003ed8:	f000 fa42 	bl	8004360 <__sinit>
 8003edc:	4b22      	ldr	r3, [pc, #136]	; (8003f68 <_puts_r+0xa8>)
 8003ede:	429c      	cmp	r4, r3
 8003ee0:	d101      	bne.n	8003ee6 <_puts_r+0x26>
 8003ee2:	686c      	ldr	r4, [r5, #4]
 8003ee4:	e008      	b.n	8003ef8 <_puts_r+0x38>
 8003ee6:	4b21      	ldr	r3, [pc, #132]	; (8003f6c <_puts_r+0xac>)
 8003ee8:	429c      	cmp	r4, r3
 8003eea:	d101      	bne.n	8003ef0 <_puts_r+0x30>
 8003eec:	68ac      	ldr	r4, [r5, #8]
 8003eee:	e003      	b.n	8003ef8 <_puts_r+0x38>
 8003ef0:	4b1f      	ldr	r3, [pc, #124]	; (8003f70 <_puts_r+0xb0>)
 8003ef2:	429c      	cmp	r4, r3
 8003ef4:	bf08      	it	eq
 8003ef6:	68ec      	ldreq	r4, [r5, #12]
 8003ef8:	89a3      	ldrh	r3, [r4, #12]
 8003efa:	071b      	lsls	r3, r3, #28
 8003efc:	d501      	bpl.n	8003f02 <_puts_r+0x42>
 8003efe:	6923      	ldr	r3, [r4, #16]
 8003f00:	b93b      	cbnz	r3, 8003f12 <_puts_r+0x52>
 8003f02:	4621      	mov	r1, r4
 8003f04:	4628      	mov	r0, r5
 8003f06:	f000 f8b9 	bl	800407c <__swsetup_r>
 8003f0a:	b110      	cbz	r0, 8003f12 <_puts_r+0x52>
 8003f0c:	f04f 30ff 	mov.w	r0, #4294967295
 8003f10:	bd70      	pop	{r4, r5, r6, pc}
 8003f12:	3e01      	subs	r6, #1
 8003f14:	68a3      	ldr	r3, [r4, #8]
 8003f16:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8003f1a:	3b01      	subs	r3, #1
 8003f1c:	60a3      	str	r3, [r4, #8]
 8003f1e:	b191      	cbz	r1, 8003f46 <_puts_r+0x86>
 8003f20:	2b00      	cmp	r3, #0
 8003f22:	da04      	bge.n	8003f2e <_puts_r+0x6e>
 8003f24:	69a2      	ldr	r2, [r4, #24]
 8003f26:	4293      	cmp	r3, r2
 8003f28:	db06      	blt.n	8003f38 <_puts_r+0x78>
 8003f2a:	290a      	cmp	r1, #10
 8003f2c:	d004      	beq.n	8003f38 <_puts_r+0x78>
 8003f2e:	6823      	ldr	r3, [r4, #0]
 8003f30:	1c5a      	adds	r2, r3, #1
 8003f32:	6022      	str	r2, [r4, #0]
 8003f34:	7019      	strb	r1, [r3, #0]
 8003f36:	e7ed      	b.n	8003f14 <_puts_r+0x54>
 8003f38:	4622      	mov	r2, r4
 8003f3a:	4628      	mov	r0, r5
 8003f3c:	f000 f84a 	bl	8003fd4 <__swbuf_r>
 8003f40:	3001      	adds	r0, #1
 8003f42:	d1e7      	bne.n	8003f14 <_puts_r+0x54>
 8003f44:	e7e2      	b.n	8003f0c <_puts_r+0x4c>
 8003f46:	2b00      	cmp	r3, #0
 8003f48:	da08      	bge.n	8003f5c <_puts_r+0x9c>
 8003f4a:	4622      	mov	r2, r4
 8003f4c:	210a      	movs	r1, #10
 8003f4e:	4628      	mov	r0, r5
 8003f50:	f000 f840 	bl	8003fd4 <__swbuf_r>
 8003f54:	3001      	adds	r0, #1
 8003f56:	d0d9      	beq.n	8003f0c <_puts_r+0x4c>
 8003f58:	200a      	movs	r0, #10
 8003f5a:	bd70      	pop	{r4, r5, r6, pc}
 8003f5c:	6823      	ldr	r3, [r4, #0]
 8003f5e:	200a      	movs	r0, #10
 8003f60:	1c5a      	adds	r2, r3, #1
 8003f62:	6022      	str	r2, [r4, #0]
 8003f64:	7018      	strb	r0, [r3, #0]
 8003f66:	bd70      	pop	{r4, r5, r6, pc}
 8003f68:	08007a88 	.word	0x08007a88
 8003f6c:	08007aa8 	.word	0x08007aa8
 8003f70:	08007ac8 	.word	0x08007ac8

08003f74 <puts>:
 8003f74:	4b02      	ldr	r3, [pc, #8]	; (8003f80 <puts+0xc>)
 8003f76:	4601      	mov	r1, r0
 8003f78:	6818      	ldr	r0, [r3, #0]
 8003f7a:	f7ff bfa1 	b.w	8003ec0 <_puts_r>
 8003f7e:	bf00      	nop
 8003f80:	2000010c 	.word	0x2000010c

08003f84 <_sbrk_r>:
 8003f84:	b538      	push	{r3, r4, r5, lr}
 8003f86:	4c06      	ldr	r4, [pc, #24]	; (8003fa0 <_sbrk_r+0x1c>)
 8003f88:	2300      	movs	r3, #0
 8003f8a:	4605      	mov	r5, r0
 8003f8c:	4608      	mov	r0, r1
 8003f8e:	6023      	str	r3, [r4, #0]
 8003f90:	f7ff fe34 	bl	8003bfc <_sbrk>
 8003f94:	1c43      	adds	r3, r0, #1
 8003f96:	d102      	bne.n	8003f9e <_sbrk_r+0x1a>
 8003f98:	6823      	ldr	r3, [r4, #0]
 8003f9a:	b103      	cbz	r3, 8003f9e <_sbrk_r+0x1a>
 8003f9c:	602b      	str	r3, [r5, #0]
 8003f9e:	bd38      	pop	{r3, r4, r5, pc}
 8003fa0:	200002ac 	.word	0x200002ac

08003fa4 <iscanf>:
 8003fa4:	b40f      	push	{r0, r1, r2, r3}
 8003fa6:	4b0a      	ldr	r3, [pc, #40]	; (8003fd0 <iscanf+0x2c>)
 8003fa8:	b513      	push	{r0, r1, r4, lr}
 8003faa:	681c      	ldr	r4, [r3, #0]
 8003fac:	b124      	cbz	r4, 8003fb8 <iscanf+0x14>
 8003fae:	69a3      	ldr	r3, [r4, #24]
 8003fb0:	b913      	cbnz	r3, 8003fb8 <iscanf+0x14>
 8003fb2:	4620      	mov	r0, r4
 8003fb4:	f000 f9d4 	bl	8004360 <__sinit>
 8003fb8:	ab05      	add	r3, sp, #20
 8003fba:	9a04      	ldr	r2, [sp, #16]
 8003fbc:	6861      	ldr	r1, [r4, #4]
 8003fbe:	9301      	str	r3, [sp, #4]
 8003fc0:	4620      	mov	r0, r4
 8003fc2:	f000 fc29 	bl	8004818 <_vfiscanf_r>
 8003fc6:	b002      	add	sp, #8
 8003fc8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8003fcc:	b004      	add	sp, #16
 8003fce:	4770      	bx	lr
 8003fd0:	2000010c 	.word	0x2000010c

08003fd4 <__swbuf_r>:
 8003fd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003fd6:	460f      	mov	r7, r1
 8003fd8:	4614      	mov	r4, r2
 8003fda:	4606      	mov	r6, r0
 8003fdc:	b118      	cbz	r0, 8003fe6 <__swbuf_r+0x12>
 8003fde:	6983      	ldr	r3, [r0, #24]
 8003fe0:	b90b      	cbnz	r3, 8003fe6 <__swbuf_r+0x12>
 8003fe2:	f000 f9bd 	bl	8004360 <__sinit>
 8003fe6:	4b22      	ldr	r3, [pc, #136]	; (8004070 <__swbuf_r+0x9c>)
 8003fe8:	429c      	cmp	r4, r3
 8003fea:	d101      	bne.n	8003ff0 <__swbuf_r+0x1c>
 8003fec:	6874      	ldr	r4, [r6, #4]
 8003fee:	e008      	b.n	8004002 <__swbuf_r+0x2e>
 8003ff0:	4b20      	ldr	r3, [pc, #128]	; (8004074 <__swbuf_r+0xa0>)
 8003ff2:	429c      	cmp	r4, r3
 8003ff4:	d101      	bne.n	8003ffa <__swbuf_r+0x26>
 8003ff6:	68b4      	ldr	r4, [r6, #8]
 8003ff8:	e003      	b.n	8004002 <__swbuf_r+0x2e>
 8003ffa:	4b1f      	ldr	r3, [pc, #124]	; (8004078 <__swbuf_r+0xa4>)
 8003ffc:	429c      	cmp	r4, r3
 8003ffe:	bf08      	it	eq
 8004000:	68f4      	ldreq	r4, [r6, #12]
 8004002:	69a3      	ldr	r3, [r4, #24]
 8004004:	60a3      	str	r3, [r4, #8]
 8004006:	89a3      	ldrh	r3, [r4, #12]
 8004008:	071a      	lsls	r2, r3, #28
 800400a:	d509      	bpl.n	8004020 <__swbuf_r+0x4c>
 800400c:	6923      	ldr	r3, [r4, #16]
 800400e:	b13b      	cbz	r3, 8004020 <__swbuf_r+0x4c>
 8004010:	6823      	ldr	r3, [r4, #0]
 8004012:	6920      	ldr	r0, [r4, #16]
 8004014:	1a18      	subs	r0, r3, r0
 8004016:	6963      	ldr	r3, [r4, #20]
 8004018:	4298      	cmp	r0, r3
 800401a:	b2fd      	uxtb	r5, r7
 800401c:	db0f      	blt.n	800403e <__swbuf_r+0x6a>
 800401e:	e008      	b.n	8004032 <__swbuf_r+0x5e>
 8004020:	4621      	mov	r1, r4
 8004022:	4630      	mov	r0, r6
 8004024:	f000 f82a 	bl	800407c <__swsetup_r>
 8004028:	2800      	cmp	r0, #0
 800402a:	d0f1      	beq.n	8004010 <__swbuf_r+0x3c>
 800402c:	f04f 30ff 	mov.w	r0, #4294967295
 8004030:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004032:	4621      	mov	r1, r4
 8004034:	4630      	mov	r0, r6
 8004036:	f000 f917 	bl	8004268 <_fflush_r>
 800403a:	2800      	cmp	r0, #0
 800403c:	d1f6      	bne.n	800402c <__swbuf_r+0x58>
 800403e:	68a3      	ldr	r3, [r4, #8]
 8004040:	3b01      	subs	r3, #1
 8004042:	60a3      	str	r3, [r4, #8]
 8004044:	6823      	ldr	r3, [r4, #0]
 8004046:	1c5a      	adds	r2, r3, #1
 8004048:	6022      	str	r2, [r4, #0]
 800404a:	701f      	strb	r7, [r3, #0]
 800404c:	6962      	ldr	r2, [r4, #20]
 800404e:	1c43      	adds	r3, r0, #1
 8004050:	4293      	cmp	r3, r2
 8004052:	d004      	beq.n	800405e <__swbuf_r+0x8a>
 8004054:	89a3      	ldrh	r3, [r4, #12]
 8004056:	07db      	lsls	r3, r3, #31
 8004058:	d507      	bpl.n	800406a <__swbuf_r+0x96>
 800405a:	2d0a      	cmp	r5, #10
 800405c:	d105      	bne.n	800406a <__swbuf_r+0x96>
 800405e:	4621      	mov	r1, r4
 8004060:	4630      	mov	r0, r6
 8004062:	f000 f901 	bl	8004268 <_fflush_r>
 8004066:	2800      	cmp	r0, #0
 8004068:	d1e0      	bne.n	800402c <__swbuf_r+0x58>
 800406a:	4628      	mov	r0, r5
 800406c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800406e:	bf00      	nop
 8004070:	08007a88 	.word	0x08007a88
 8004074:	08007aa8 	.word	0x08007aa8
 8004078:	08007ac8 	.word	0x08007ac8

0800407c <__swsetup_r>:
 800407c:	4b32      	ldr	r3, [pc, #200]	; (8004148 <__swsetup_r+0xcc>)
 800407e:	b570      	push	{r4, r5, r6, lr}
 8004080:	681d      	ldr	r5, [r3, #0]
 8004082:	4606      	mov	r6, r0
 8004084:	460c      	mov	r4, r1
 8004086:	b125      	cbz	r5, 8004092 <__swsetup_r+0x16>
 8004088:	69ab      	ldr	r3, [r5, #24]
 800408a:	b913      	cbnz	r3, 8004092 <__swsetup_r+0x16>
 800408c:	4628      	mov	r0, r5
 800408e:	f000 f967 	bl	8004360 <__sinit>
 8004092:	4b2e      	ldr	r3, [pc, #184]	; (800414c <__swsetup_r+0xd0>)
 8004094:	429c      	cmp	r4, r3
 8004096:	d101      	bne.n	800409c <__swsetup_r+0x20>
 8004098:	686c      	ldr	r4, [r5, #4]
 800409a:	e008      	b.n	80040ae <__swsetup_r+0x32>
 800409c:	4b2c      	ldr	r3, [pc, #176]	; (8004150 <__swsetup_r+0xd4>)
 800409e:	429c      	cmp	r4, r3
 80040a0:	d101      	bne.n	80040a6 <__swsetup_r+0x2a>
 80040a2:	68ac      	ldr	r4, [r5, #8]
 80040a4:	e003      	b.n	80040ae <__swsetup_r+0x32>
 80040a6:	4b2b      	ldr	r3, [pc, #172]	; (8004154 <__swsetup_r+0xd8>)
 80040a8:	429c      	cmp	r4, r3
 80040aa:	bf08      	it	eq
 80040ac:	68ec      	ldreq	r4, [r5, #12]
 80040ae:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80040b2:	b29a      	uxth	r2, r3
 80040b4:	0715      	lsls	r5, r2, #28
 80040b6:	d41d      	bmi.n	80040f4 <__swsetup_r+0x78>
 80040b8:	06d0      	lsls	r0, r2, #27
 80040ba:	d402      	bmi.n	80040c2 <__swsetup_r+0x46>
 80040bc:	2209      	movs	r2, #9
 80040be:	6032      	str	r2, [r6, #0]
 80040c0:	e03a      	b.n	8004138 <__swsetup_r+0xbc>
 80040c2:	0751      	lsls	r1, r2, #29
 80040c4:	d512      	bpl.n	80040ec <__swsetup_r+0x70>
 80040c6:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80040c8:	b141      	cbz	r1, 80040dc <__swsetup_r+0x60>
 80040ca:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80040ce:	4299      	cmp	r1, r3
 80040d0:	d002      	beq.n	80040d8 <__swsetup_r+0x5c>
 80040d2:	4630      	mov	r0, r6
 80040d4:	f7ff fe48 	bl	8003d68 <_free_r>
 80040d8:	2300      	movs	r3, #0
 80040da:	6363      	str	r3, [r4, #52]	; 0x34
 80040dc:	89a3      	ldrh	r3, [r4, #12]
 80040de:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 80040e2:	81a3      	strh	r3, [r4, #12]
 80040e4:	2300      	movs	r3, #0
 80040e6:	6063      	str	r3, [r4, #4]
 80040e8:	6923      	ldr	r3, [r4, #16]
 80040ea:	6023      	str	r3, [r4, #0]
 80040ec:	89a3      	ldrh	r3, [r4, #12]
 80040ee:	f043 0308 	orr.w	r3, r3, #8
 80040f2:	81a3      	strh	r3, [r4, #12]
 80040f4:	6923      	ldr	r3, [r4, #16]
 80040f6:	b94b      	cbnz	r3, 800410c <__swsetup_r+0x90>
 80040f8:	89a3      	ldrh	r3, [r4, #12]
 80040fa:	f403 7320 	and.w	r3, r3, #640	; 0x280
 80040fe:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8004102:	d003      	beq.n	800410c <__swsetup_r+0x90>
 8004104:	4621      	mov	r1, r4
 8004106:	4630      	mov	r0, r6
 8004108:	f000 f9f4 	bl	80044f4 <__smakebuf_r>
 800410c:	89a2      	ldrh	r2, [r4, #12]
 800410e:	f012 0301 	ands.w	r3, r2, #1
 8004112:	d005      	beq.n	8004120 <__swsetup_r+0xa4>
 8004114:	2300      	movs	r3, #0
 8004116:	60a3      	str	r3, [r4, #8]
 8004118:	6963      	ldr	r3, [r4, #20]
 800411a:	425b      	negs	r3, r3
 800411c:	61a3      	str	r3, [r4, #24]
 800411e:	e003      	b.n	8004128 <__swsetup_r+0xac>
 8004120:	0792      	lsls	r2, r2, #30
 8004122:	bf58      	it	pl
 8004124:	6963      	ldrpl	r3, [r4, #20]
 8004126:	60a3      	str	r3, [r4, #8]
 8004128:	6923      	ldr	r3, [r4, #16]
 800412a:	b95b      	cbnz	r3, 8004144 <__swsetup_r+0xc8>
 800412c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8004130:	f003 0080 	and.w	r0, r3, #128	; 0x80
 8004134:	b280      	uxth	r0, r0
 8004136:	b130      	cbz	r0, 8004146 <__swsetup_r+0xca>
 8004138:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800413c:	81a3      	strh	r3, [r4, #12]
 800413e:	f04f 30ff 	mov.w	r0, #4294967295
 8004142:	bd70      	pop	{r4, r5, r6, pc}
 8004144:	2000      	movs	r0, #0
 8004146:	bd70      	pop	{r4, r5, r6, pc}
 8004148:	2000010c 	.word	0x2000010c
 800414c:	08007a88 	.word	0x08007a88
 8004150:	08007aa8 	.word	0x08007aa8
 8004154:	08007ac8 	.word	0x08007ac8

08004158 <__sflush_r>:
 8004158:	898a      	ldrh	r2, [r1, #12]
 800415a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800415e:	4605      	mov	r5, r0
 8004160:	0710      	lsls	r0, r2, #28
 8004162:	460c      	mov	r4, r1
 8004164:	d459      	bmi.n	800421a <__sflush_r+0xc2>
 8004166:	684b      	ldr	r3, [r1, #4]
 8004168:	2b00      	cmp	r3, #0
 800416a:	dc02      	bgt.n	8004172 <__sflush_r+0x1a>
 800416c:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 800416e:	2b00      	cmp	r3, #0
 8004170:	dd17      	ble.n	80041a2 <__sflush_r+0x4a>
 8004172:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8004174:	b1ae      	cbz	r6, 80041a2 <__sflush_r+0x4a>
 8004176:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 800417a:	2300      	movs	r3, #0
 800417c:	b292      	uxth	r2, r2
 800417e:	682f      	ldr	r7, [r5, #0]
 8004180:	602b      	str	r3, [r5, #0]
 8004182:	b10a      	cbz	r2, 8004188 <__sflush_r+0x30>
 8004184:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8004186:	e015      	b.n	80041b4 <__sflush_r+0x5c>
 8004188:	6a21      	ldr	r1, [r4, #32]
 800418a:	2301      	movs	r3, #1
 800418c:	4628      	mov	r0, r5
 800418e:	47b0      	blx	r6
 8004190:	1c41      	adds	r1, r0, #1
 8004192:	d10f      	bne.n	80041b4 <__sflush_r+0x5c>
 8004194:	682b      	ldr	r3, [r5, #0]
 8004196:	b16b      	cbz	r3, 80041b4 <__sflush_r+0x5c>
 8004198:	2b1d      	cmp	r3, #29
 800419a:	d001      	beq.n	80041a0 <__sflush_r+0x48>
 800419c:	2b16      	cmp	r3, #22
 800419e:	d103      	bne.n	80041a8 <__sflush_r+0x50>
 80041a0:	602f      	str	r7, [r5, #0]
 80041a2:	2000      	movs	r0, #0
 80041a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80041a8:	89a3      	ldrh	r3, [r4, #12]
 80041aa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80041ae:	81a3      	strh	r3, [r4, #12]
 80041b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80041b4:	89a3      	ldrh	r3, [r4, #12]
 80041b6:	075a      	lsls	r2, r3, #29
 80041b8:	d505      	bpl.n	80041c6 <__sflush_r+0x6e>
 80041ba:	6863      	ldr	r3, [r4, #4]
 80041bc:	1ac0      	subs	r0, r0, r3
 80041be:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80041c0:	b10b      	cbz	r3, 80041c6 <__sflush_r+0x6e>
 80041c2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80041c4:	1ac0      	subs	r0, r0, r3
 80041c6:	2300      	movs	r3, #0
 80041c8:	4602      	mov	r2, r0
 80041ca:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 80041cc:	6a21      	ldr	r1, [r4, #32]
 80041ce:	4628      	mov	r0, r5
 80041d0:	47b0      	blx	r6
 80041d2:	1c43      	adds	r3, r0, #1
 80041d4:	89a3      	ldrh	r3, [r4, #12]
 80041d6:	d106      	bne.n	80041e6 <__sflush_r+0x8e>
 80041d8:	6829      	ldr	r1, [r5, #0]
 80041da:	291d      	cmp	r1, #29
 80041dc:	d83a      	bhi.n	8004254 <__sflush_r+0xfc>
 80041de:	4a21      	ldr	r2, [pc, #132]	; (8004264 <__sflush_r+0x10c>)
 80041e0:	40ca      	lsrs	r2, r1
 80041e2:	07d6      	lsls	r6, r2, #31
 80041e4:	d536      	bpl.n	8004254 <__sflush_r+0xfc>
 80041e6:	2200      	movs	r2, #0
 80041e8:	6062      	str	r2, [r4, #4]
 80041ea:	04d9      	lsls	r1, r3, #19
 80041ec:	6922      	ldr	r2, [r4, #16]
 80041ee:	6022      	str	r2, [r4, #0]
 80041f0:	d504      	bpl.n	80041fc <__sflush_r+0xa4>
 80041f2:	1c42      	adds	r2, r0, #1
 80041f4:	d101      	bne.n	80041fa <__sflush_r+0xa2>
 80041f6:	682b      	ldr	r3, [r5, #0]
 80041f8:	b903      	cbnz	r3, 80041fc <__sflush_r+0xa4>
 80041fa:	6560      	str	r0, [r4, #84]	; 0x54
 80041fc:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80041fe:	602f      	str	r7, [r5, #0]
 8004200:	2900      	cmp	r1, #0
 8004202:	d0ce      	beq.n	80041a2 <__sflush_r+0x4a>
 8004204:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8004208:	4299      	cmp	r1, r3
 800420a:	d002      	beq.n	8004212 <__sflush_r+0xba>
 800420c:	4628      	mov	r0, r5
 800420e:	f7ff fdab 	bl	8003d68 <_free_r>
 8004212:	2000      	movs	r0, #0
 8004214:	6360      	str	r0, [r4, #52]	; 0x34
 8004216:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800421a:	690f      	ldr	r7, [r1, #16]
 800421c:	2f00      	cmp	r7, #0
 800421e:	d0c0      	beq.n	80041a2 <__sflush_r+0x4a>
 8004220:	0793      	lsls	r3, r2, #30
 8004222:	680e      	ldr	r6, [r1, #0]
 8004224:	bf08      	it	eq
 8004226:	694b      	ldreq	r3, [r1, #20]
 8004228:	600f      	str	r7, [r1, #0]
 800422a:	bf18      	it	ne
 800422c:	2300      	movne	r3, #0
 800422e:	ebc7 0806 	rsb	r8, r7, r6
 8004232:	608b      	str	r3, [r1, #8]
 8004234:	e002      	b.n	800423c <__sflush_r+0xe4>
 8004236:	4407      	add	r7, r0
 8004238:	ebc0 0808 	rsb	r8, r0, r8
 800423c:	f1b8 0f00 	cmp.w	r8, #0
 8004240:	ddaf      	ble.n	80041a2 <__sflush_r+0x4a>
 8004242:	4643      	mov	r3, r8
 8004244:	463a      	mov	r2, r7
 8004246:	6a21      	ldr	r1, [r4, #32]
 8004248:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 800424a:	4628      	mov	r0, r5
 800424c:	47b0      	blx	r6
 800424e:	2800      	cmp	r0, #0
 8004250:	dcf1      	bgt.n	8004236 <__sflush_r+0xde>
 8004252:	89a3      	ldrh	r3, [r4, #12]
 8004254:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8004258:	81a3      	strh	r3, [r4, #12]
 800425a:	f04f 30ff 	mov.w	r0, #4294967295
 800425e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004262:	bf00      	nop
 8004264:	20400001 	.word	0x20400001

08004268 <_fflush_r>:
 8004268:	b538      	push	{r3, r4, r5, lr}
 800426a:	690b      	ldr	r3, [r1, #16]
 800426c:	4605      	mov	r5, r0
 800426e:	460c      	mov	r4, r1
 8004270:	b1db      	cbz	r3, 80042aa <_fflush_r+0x42>
 8004272:	b118      	cbz	r0, 800427c <_fflush_r+0x14>
 8004274:	6983      	ldr	r3, [r0, #24]
 8004276:	b90b      	cbnz	r3, 800427c <_fflush_r+0x14>
 8004278:	f000 f872 	bl	8004360 <__sinit>
 800427c:	4b0c      	ldr	r3, [pc, #48]	; (80042b0 <_fflush_r+0x48>)
 800427e:	429c      	cmp	r4, r3
 8004280:	d101      	bne.n	8004286 <_fflush_r+0x1e>
 8004282:	686c      	ldr	r4, [r5, #4]
 8004284:	e008      	b.n	8004298 <_fflush_r+0x30>
 8004286:	4b0b      	ldr	r3, [pc, #44]	; (80042b4 <_fflush_r+0x4c>)
 8004288:	429c      	cmp	r4, r3
 800428a:	d101      	bne.n	8004290 <_fflush_r+0x28>
 800428c:	68ac      	ldr	r4, [r5, #8]
 800428e:	e003      	b.n	8004298 <_fflush_r+0x30>
 8004290:	4b09      	ldr	r3, [pc, #36]	; (80042b8 <_fflush_r+0x50>)
 8004292:	429c      	cmp	r4, r3
 8004294:	bf08      	it	eq
 8004296:	68ec      	ldreq	r4, [r5, #12]
 8004298:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800429c:	b12b      	cbz	r3, 80042aa <_fflush_r+0x42>
 800429e:	4621      	mov	r1, r4
 80042a0:	4628      	mov	r0, r5
 80042a2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80042a6:	f7ff bf57 	b.w	8004158 <__sflush_r>
 80042aa:	2000      	movs	r0, #0
 80042ac:	bd38      	pop	{r3, r4, r5, pc}
 80042ae:	bf00      	nop
 80042b0:	08007a88 	.word	0x08007a88
 80042b4:	08007aa8 	.word	0x08007aa8
 80042b8:	08007ac8 	.word	0x08007ac8

080042bc <fflush>:
 80042bc:	4601      	mov	r1, r0
 80042be:	b920      	cbnz	r0, 80042ca <fflush+0xe>
 80042c0:	4b04      	ldr	r3, [pc, #16]	; (80042d4 <fflush+0x18>)
 80042c2:	4905      	ldr	r1, [pc, #20]	; (80042d8 <fflush+0x1c>)
 80042c4:	6818      	ldr	r0, [r3, #0]
 80042c6:	f000 b8d3 	b.w	8004470 <_fwalk_reent>
 80042ca:	4b04      	ldr	r3, [pc, #16]	; (80042dc <fflush+0x20>)
 80042cc:	6818      	ldr	r0, [r3, #0]
 80042ce:	f7ff bfcb 	b.w	8004268 <_fflush_r>
 80042d2:	bf00      	nop
 80042d4:	08007aec 	.word	0x08007aec
 80042d8:	08004269 	.word	0x08004269
 80042dc:	2000010c 	.word	0x2000010c

080042e0 <_cleanup_r>:
 80042e0:	4901      	ldr	r1, [pc, #4]	; (80042e8 <_cleanup_r+0x8>)
 80042e2:	f000 b8c5 	b.w	8004470 <_fwalk_reent>
 80042e6:	bf00      	nop
 80042e8:	08004269 	.word	0x08004269

080042ec <std.isra.0>:
 80042ec:	2300      	movs	r3, #0
 80042ee:	b510      	push	{r4, lr}
 80042f0:	4604      	mov	r4, r0
 80042f2:	6003      	str	r3, [r0, #0]
 80042f4:	6043      	str	r3, [r0, #4]
 80042f6:	6083      	str	r3, [r0, #8]
 80042f8:	8181      	strh	r1, [r0, #12]
 80042fa:	6643      	str	r3, [r0, #100]	; 0x64
 80042fc:	81c2      	strh	r2, [r0, #14]
 80042fe:	6103      	str	r3, [r0, #16]
 8004300:	6143      	str	r3, [r0, #20]
 8004302:	6183      	str	r3, [r0, #24]
 8004304:	4619      	mov	r1, r3
 8004306:	2208      	movs	r2, #8
 8004308:	305c      	adds	r0, #92	; 0x5c
 800430a:	f7ff fd25 	bl	8003d58 <memset>
 800430e:	4b05      	ldr	r3, [pc, #20]	; (8004324 <std.isra.0+0x38>)
 8004310:	6263      	str	r3, [r4, #36]	; 0x24
 8004312:	4b05      	ldr	r3, [pc, #20]	; (8004328 <std.isra.0+0x3c>)
 8004314:	62a3      	str	r3, [r4, #40]	; 0x28
 8004316:	4b05      	ldr	r3, [pc, #20]	; (800432c <std.isra.0+0x40>)
 8004318:	62e3      	str	r3, [r4, #44]	; 0x2c
 800431a:	4b05      	ldr	r3, [pc, #20]	; (8004330 <std.isra.0+0x44>)
 800431c:	6224      	str	r4, [r4, #32]
 800431e:	6323      	str	r3, [r4, #48]	; 0x30
 8004320:	bd10      	pop	{r4, pc}
 8004322:	bf00      	nop
 8004324:	08004c9b 	.word	0x08004c9b
 8004328:	08004cbd 	.word	0x08004cbd
 800432c:	08004cf5 	.word	0x08004cf5
 8004330:	08004d19 	.word	0x08004d19

08004334 <__sfmoreglue>:
 8004334:	b570      	push	{r4, r5, r6, lr}
 8004336:	2368      	movs	r3, #104	; 0x68
 8004338:	1e4d      	subs	r5, r1, #1
 800433a:	435d      	muls	r5, r3
 800433c:	460e      	mov	r6, r1
 800433e:	f105 0174 	add.w	r1, r5, #116	; 0x74
 8004342:	f7ff fd5f 	bl	8003e04 <_malloc_r>
 8004346:	4604      	mov	r4, r0
 8004348:	b140      	cbz	r0, 800435c <__sfmoreglue+0x28>
 800434a:	2100      	movs	r1, #0
 800434c:	e880 0042 	stmia.w	r0, {r1, r6}
 8004350:	300c      	adds	r0, #12
 8004352:	60a0      	str	r0, [r4, #8]
 8004354:	f105 0268 	add.w	r2, r5, #104	; 0x68
 8004358:	f7ff fcfe 	bl	8003d58 <memset>
 800435c:	4620      	mov	r0, r4
 800435e:	bd70      	pop	{r4, r5, r6, pc}

08004360 <__sinit>:
 8004360:	6983      	ldr	r3, [r0, #24]
 8004362:	b510      	push	{r4, lr}
 8004364:	4604      	mov	r4, r0
 8004366:	bb33      	cbnz	r3, 80043b6 <__sinit+0x56>
 8004368:	6483      	str	r3, [r0, #72]	; 0x48
 800436a:	64c3      	str	r3, [r0, #76]	; 0x4c
 800436c:	6503      	str	r3, [r0, #80]	; 0x50
 800436e:	4b12      	ldr	r3, [pc, #72]	; (80043b8 <__sinit+0x58>)
 8004370:	4a12      	ldr	r2, [pc, #72]	; (80043bc <__sinit+0x5c>)
 8004372:	681b      	ldr	r3, [r3, #0]
 8004374:	6282      	str	r2, [r0, #40]	; 0x28
 8004376:	4298      	cmp	r0, r3
 8004378:	bf04      	itt	eq
 800437a:	2301      	moveq	r3, #1
 800437c:	6183      	streq	r3, [r0, #24]
 800437e:	f000 f81f 	bl	80043c0 <__sfp>
 8004382:	6060      	str	r0, [r4, #4]
 8004384:	4620      	mov	r0, r4
 8004386:	f000 f81b 	bl	80043c0 <__sfp>
 800438a:	60a0      	str	r0, [r4, #8]
 800438c:	4620      	mov	r0, r4
 800438e:	f000 f817 	bl	80043c0 <__sfp>
 8004392:	2200      	movs	r2, #0
 8004394:	60e0      	str	r0, [r4, #12]
 8004396:	2104      	movs	r1, #4
 8004398:	6860      	ldr	r0, [r4, #4]
 800439a:	f7ff ffa7 	bl	80042ec <std.isra.0>
 800439e:	2201      	movs	r2, #1
 80043a0:	2109      	movs	r1, #9
 80043a2:	68a0      	ldr	r0, [r4, #8]
 80043a4:	f7ff ffa2 	bl	80042ec <std.isra.0>
 80043a8:	2202      	movs	r2, #2
 80043aa:	2112      	movs	r1, #18
 80043ac:	68e0      	ldr	r0, [r4, #12]
 80043ae:	f7ff ff9d 	bl	80042ec <std.isra.0>
 80043b2:	2301      	movs	r3, #1
 80043b4:	61a3      	str	r3, [r4, #24]
 80043b6:	bd10      	pop	{r4, pc}
 80043b8:	08007aec 	.word	0x08007aec
 80043bc:	080042e1 	.word	0x080042e1

080043c0 <__sfp>:
 80043c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80043c2:	4b1c      	ldr	r3, [pc, #112]	; (8004434 <__sfp+0x74>)
 80043c4:	681e      	ldr	r6, [r3, #0]
 80043c6:	69b3      	ldr	r3, [r6, #24]
 80043c8:	4607      	mov	r7, r0
 80043ca:	b913      	cbnz	r3, 80043d2 <__sfp+0x12>
 80043cc:	4630      	mov	r0, r6
 80043ce:	f7ff ffc7 	bl	8004360 <__sinit>
 80043d2:	3648      	adds	r6, #72	; 0x48
 80043d4:	68b4      	ldr	r4, [r6, #8]
 80043d6:	6873      	ldr	r3, [r6, #4]
 80043d8:	3b01      	subs	r3, #1
 80043da:	d404      	bmi.n	80043e6 <__sfp+0x26>
 80043dc:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 80043e0:	b17d      	cbz	r5, 8004402 <__sfp+0x42>
 80043e2:	3468      	adds	r4, #104	; 0x68
 80043e4:	e7f8      	b.n	80043d8 <__sfp+0x18>
 80043e6:	6833      	ldr	r3, [r6, #0]
 80043e8:	b10b      	cbz	r3, 80043ee <__sfp+0x2e>
 80043ea:	6836      	ldr	r6, [r6, #0]
 80043ec:	e7f2      	b.n	80043d4 <__sfp+0x14>
 80043ee:	2104      	movs	r1, #4
 80043f0:	4638      	mov	r0, r7
 80043f2:	f7ff ff9f 	bl	8004334 <__sfmoreglue>
 80043f6:	6030      	str	r0, [r6, #0]
 80043f8:	2800      	cmp	r0, #0
 80043fa:	d1f6      	bne.n	80043ea <__sfp+0x2a>
 80043fc:	230c      	movs	r3, #12
 80043fe:	603b      	str	r3, [r7, #0]
 8004400:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004402:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8004406:	81e3      	strh	r3, [r4, #14]
 8004408:	2301      	movs	r3, #1
 800440a:	81a3      	strh	r3, [r4, #12]
 800440c:	6665      	str	r5, [r4, #100]	; 0x64
 800440e:	6025      	str	r5, [r4, #0]
 8004410:	60a5      	str	r5, [r4, #8]
 8004412:	6065      	str	r5, [r4, #4]
 8004414:	6125      	str	r5, [r4, #16]
 8004416:	6165      	str	r5, [r4, #20]
 8004418:	61a5      	str	r5, [r4, #24]
 800441a:	2208      	movs	r2, #8
 800441c:	4629      	mov	r1, r5
 800441e:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8004422:	f7ff fc99 	bl	8003d58 <memset>
 8004426:	6365      	str	r5, [r4, #52]	; 0x34
 8004428:	63a5      	str	r5, [r4, #56]	; 0x38
 800442a:	64a5      	str	r5, [r4, #72]	; 0x48
 800442c:	64e5      	str	r5, [r4, #76]	; 0x4c
 800442e:	4620      	mov	r0, r4
 8004430:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004432:	bf00      	nop
 8004434:	08007aec 	.word	0x08007aec

08004438 <_fwalk>:
 8004438:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800443c:	4688      	mov	r8, r1
 800443e:	f100 0448 	add.w	r4, r0, #72	; 0x48
 8004442:	2600      	movs	r6, #0
 8004444:	b18c      	cbz	r4, 800446a <_fwalk+0x32>
 8004446:	68a5      	ldr	r5, [r4, #8]
 8004448:	6867      	ldr	r7, [r4, #4]
 800444a:	3f01      	subs	r7, #1
 800444c:	d40b      	bmi.n	8004466 <_fwalk+0x2e>
 800444e:	89ab      	ldrh	r3, [r5, #12]
 8004450:	2b01      	cmp	r3, #1
 8004452:	d906      	bls.n	8004462 <_fwalk+0x2a>
 8004454:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8004458:	3301      	adds	r3, #1
 800445a:	d002      	beq.n	8004462 <_fwalk+0x2a>
 800445c:	4628      	mov	r0, r5
 800445e:	47c0      	blx	r8
 8004460:	4306      	orrs	r6, r0
 8004462:	3568      	adds	r5, #104	; 0x68
 8004464:	e7f1      	b.n	800444a <_fwalk+0x12>
 8004466:	6824      	ldr	r4, [r4, #0]
 8004468:	e7ec      	b.n	8004444 <_fwalk+0xc>
 800446a:	4630      	mov	r0, r6
 800446c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08004470 <_fwalk_reent>:
 8004470:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004474:	4680      	mov	r8, r0
 8004476:	4689      	mov	r9, r1
 8004478:	f100 0448 	add.w	r4, r0, #72	; 0x48
 800447c:	2600      	movs	r6, #0
 800447e:	b194      	cbz	r4, 80044a6 <_fwalk_reent+0x36>
 8004480:	68a5      	ldr	r5, [r4, #8]
 8004482:	6867      	ldr	r7, [r4, #4]
 8004484:	3f01      	subs	r7, #1
 8004486:	d40c      	bmi.n	80044a2 <_fwalk_reent+0x32>
 8004488:	89ab      	ldrh	r3, [r5, #12]
 800448a:	2b01      	cmp	r3, #1
 800448c:	d907      	bls.n	800449e <_fwalk_reent+0x2e>
 800448e:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8004492:	3301      	adds	r3, #1
 8004494:	d003      	beq.n	800449e <_fwalk_reent+0x2e>
 8004496:	4629      	mov	r1, r5
 8004498:	4640      	mov	r0, r8
 800449a:	47c8      	blx	r9
 800449c:	4306      	orrs	r6, r0
 800449e:	3568      	adds	r5, #104	; 0x68
 80044a0:	e7f0      	b.n	8004484 <_fwalk_reent+0x14>
 80044a2:	6824      	ldr	r4, [r4, #0]
 80044a4:	e7eb      	b.n	800447e <_fwalk_reent+0xe>
 80044a6:	4630      	mov	r0, r6
 80044a8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080044ac <__swhatbuf_r>:
 80044ac:	b570      	push	{r4, r5, r6, lr}
 80044ae:	460e      	mov	r6, r1
 80044b0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80044b4:	2900      	cmp	r1, #0
 80044b6:	b090      	sub	sp, #64	; 0x40
 80044b8:	4614      	mov	r4, r2
 80044ba:	461d      	mov	r5, r3
 80044bc:	da06      	bge.n	80044cc <__swhatbuf_r+0x20>
 80044be:	2300      	movs	r3, #0
 80044c0:	602b      	str	r3, [r5, #0]
 80044c2:	89b3      	ldrh	r3, [r6, #12]
 80044c4:	061a      	lsls	r2, r3, #24
 80044c6:	d50e      	bpl.n	80044e6 <__swhatbuf_r+0x3a>
 80044c8:	2340      	movs	r3, #64	; 0x40
 80044ca:	e00e      	b.n	80044ea <__swhatbuf_r+0x3e>
 80044cc:	aa01      	add	r2, sp, #4
 80044ce:	f000 fdfb 	bl	80050c8 <_fstat_r>
 80044d2:	2800      	cmp	r0, #0
 80044d4:	dbf3      	blt.n	80044be <__swhatbuf_r+0x12>
 80044d6:	9a02      	ldr	r2, [sp, #8]
 80044d8:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 80044dc:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 80044e0:	425a      	negs	r2, r3
 80044e2:	415a      	adcs	r2, r3
 80044e4:	602a      	str	r2, [r5, #0]
 80044e6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80044ea:	2000      	movs	r0, #0
 80044ec:	6023      	str	r3, [r4, #0]
 80044ee:	b010      	add	sp, #64	; 0x40
 80044f0:	bd70      	pop	{r4, r5, r6, pc}
	...

080044f4 <__smakebuf_r>:
 80044f4:	898b      	ldrh	r3, [r1, #12]
 80044f6:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80044f8:	079e      	lsls	r6, r3, #30
 80044fa:	4605      	mov	r5, r0
 80044fc:	460c      	mov	r4, r1
 80044fe:	d410      	bmi.n	8004522 <__smakebuf_r+0x2e>
 8004500:	ab01      	add	r3, sp, #4
 8004502:	466a      	mov	r2, sp
 8004504:	f7ff ffd2 	bl	80044ac <__swhatbuf_r>
 8004508:	9900      	ldr	r1, [sp, #0]
 800450a:	4606      	mov	r6, r0
 800450c:	4628      	mov	r0, r5
 800450e:	f7ff fc79 	bl	8003e04 <_malloc_r>
 8004512:	b968      	cbnz	r0, 8004530 <__smakebuf_r+0x3c>
 8004514:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8004518:	059a      	lsls	r2, r3, #22
 800451a:	d422      	bmi.n	8004562 <__smakebuf_r+0x6e>
 800451c:	f043 0302 	orr.w	r3, r3, #2
 8004520:	81a3      	strh	r3, [r4, #12]
 8004522:	f104 0347 	add.w	r3, r4, #71	; 0x47
 8004526:	6023      	str	r3, [r4, #0]
 8004528:	6123      	str	r3, [r4, #16]
 800452a:	2301      	movs	r3, #1
 800452c:	6163      	str	r3, [r4, #20]
 800452e:	e018      	b.n	8004562 <__smakebuf_r+0x6e>
 8004530:	4b0d      	ldr	r3, [pc, #52]	; (8004568 <__smakebuf_r+0x74>)
 8004532:	62ab      	str	r3, [r5, #40]	; 0x28
 8004534:	89a3      	ldrh	r3, [r4, #12]
 8004536:	6020      	str	r0, [r4, #0]
 8004538:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800453c:	81a3      	strh	r3, [r4, #12]
 800453e:	9b00      	ldr	r3, [sp, #0]
 8004540:	6163      	str	r3, [r4, #20]
 8004542:	9b01      	ldr	r3, [sp, #4]
 8004544:	6120      	str	r0, [r4, #16]
 8004546:	b14b      	cbz	r3, 800455c <__smakebuf_r+0x68>
 8004548:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800454c:	4628      	mov	r0, r5
 800454e:	f000 fdcd 	bl	80050ec <_isatty_r>
 8004552:	b118      	cbz	r0, 800455c <__smakebuf_r+0x68>
 8004554:	89a3      	ldrh	r3, [r4, #12]
 8004556:	f043 0301 	orr.w	r3, r3, #1
 800455a:	81a3      	strh	r3, [r4, #12]
 800455c:	89a0      	ldrh	r0, [r4, #12]
 800455e:	4330      	orrs	r0, r6
 8004560:	81a0      	strh	r0, [r4, #12]
 8004562:	b002      	add	sp, #8
 8004564:	bd70      	pop	{r4, r5, r6, pc}
 8004566:	bf00      	nop
 8004568:	080042e1 	.word	0x080042e1

0800456c <__malloc_lock>:
 800456c:	4770      	bx	lr

0800456e <__malloc_unlock>:
 800456e:	4770      	bx	lr

08004570 <__svfiscanf_r>:
 8004570:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004574:	f5ad 7d25 	sub.w	sp, sp, #660	; 0x294
 8004578:	f8df 9298 	ldr.w	r9, [pc, #664]	; 8004814 <__svfiscanf_r+0x2a4>
 800457c:	9301      	str	r3, [sp, #4]
 800457e:	2300      	movs	r3, #0
 8004580:	9346      	str	r3, [sp, #280]	; 0x118
 8004582:	9347      	str	r3, [sp, #284]	; 0x11c
 8004584:	4b9f      	ldr	r3, [pc, #636]	; (8004804 <__svfiscanf_r+0x294>)
 8004586:	93a2      	str	r3, [sp, #648]	; 0x288
 8004588:	f10d 080c 	add.w	r8, sp, #12
 800458c:	4b9e      	ldr	r3, [pc, #632]	; (8004808 <__svfiscanf_r+0x298>)
 800458e:	f8df b27c 	ldr.w	fp, [pc, #636]	; 800480c <__svfiscanf_r+0x29c>
 8004592:	f8cd 8120 	str.w	r8, [sp, #288]	; 0x120
 8004596:	4607      	mov	r7, r0
 8004598:	460d      	mov	r5, r1
 800459a:	93a3      	str	r3, [sp, #652]	; 0x28c
 800459c:	46ca      	mov	sl, r9
 800459e:	7814      	ldrb	r4, [r2, #0]
 80045a0:	2c00      	cmp	r4, #0
 80045a2:	f000 8127 	beq.w	80047f4 <__svfiscanf_r+0x284>
 80045a6:	f8d9 3000 	ldr.w	r3, [r9]
 80045aa:	4423      	add	r3, r4
 80045ac:	785b      	ldrb	r3, [r3, #1]
 80045ae:	f003 0308 	and.w	r3, r3, #8
 80045b2:	f003 01ff 	and.w	r1, r3, #255	; 0xff
 80045b6:	b1f3      	cbz	r3, 80045f6 <__svfiscanf_r+0x86>
 80045b8:	686b      	ldr	r3, [r5, #4]
 80045ba:	2b00      	cmp	r3, #0
 80045bc:	dd10      	ble.n	80045e0 <__svfiscanf_r+0x70>
 80045be:	682b      	ldr	r3, [r5, #0]
 80045c0:	f8da 0000 	ldr.w	r0, [sl]
 80045c4:	7819      	ldrb	r1, [r3, #0]
 80045c6:	4401      	add	r1, r0
 80045c8:	7849      	ldrb	r1, [r1, #1]
 80045ca:	070c      	lsls	r4, r1, #28
 80045cc:	d510      	bpl.n	80045f0 <__svfiscanf_r+0x80>
 80045ce:	9947      	ldr	r1, [sp, #284]	; 0x11c
 80045d0:	3101      	adds	r1, #1
 80045d2:	9147      	str	r1, [sp, #284]	; 0x11c
 80045d4:	6869      	ldr	r1, [r5, #4]
 80045d6:	3301      	adds	r3, #1
 80045d8:	3901      	subs	r1, #1
 80045da:	6069      	str	r1, [r5, #4]
 80045dc:	602b      	str	r3, [r5, #0]
 80045de:	e7eb      	b.n	80045b8 <__svfiscanf_r+0x48>
 80045e0:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
 80045e2:	9200      	str	r2, [sp, #0]
 80045e4:	4629      	mov	r1, r5
 80045e6:	4638      	mov	r0, r7
 80045e8:	4798      	blx	r3
 80045ea:	9a00      	ldr	r2, [sp, #0]
 80045ec:	2800      	cmp	r0, #0
 80045ee:	d0e6      	beq.n	80045be <__svfiscanf_r+0x4e>
 80045f0:	1c56      	adds	r6, r2, #1
 80045f2:	4632      	mov	r2, r6
 80045f4:	e7d3      	b.n	800459e <__svfiscanf_r+0x2e>
 80045f6:	2c25      	cmp	r4, #37	; 0x25
 80045f8:	f102 0601 	add.w	r6, r2, #1
 80045fc:	d152      	bne.n	80046a4 <__svfiscanf_r+0x134>
 80045fe:	9143      	str	r1, [sp, #268]	; 0x10c
 8004600:	9145      	str	r1, [sp, #276]	; 0x114
 8004602:	7853      	ldrb	r3, [r2, #1]
 8004604:	2b2a      	cmp	r3, #42	; 0x2a
 8004606:	bf02      	ittt	eq
 8004608:	2310      	moveq	r3, #16
 800460a:	1c96      	addeq	r6, r2, #2
 800460c:	9343      	streq	r3, [sp, #268]	; 0x10c
 800460e:	220a      	movs	r2, #10
 8004610:	7831      	ldrb	r1, [r6, #0]
 8004612:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 8004616:	2b09      	cmp	r3, #9
 8004618:	4634      	mov	r4, r6
 800461a:	f106 0601 	add.w	r6, r6, #1
 800461e:	d805      	bhi.n	800462c <__svfiscanf_r+0xbc>
 8004620:	9b45      	ldr	r3, [sp, #276]	; 0x114
 8004622:	fb02 1303 	mla	r3, r2, r3, r1
 8004626:	3b30      	subs	r3, #48	; 0x30
 8004628:	9345      	str	r3, [sp, #276]	; 0x114
 800462a:	e7f1      	b.n	8004610 <__svfiscanf_r+0xa0>
 800462c:	2203      	movs	r2, #3
 800462e:	4877      	ldr	r0, [pc, #476]	; (800480c <__svfiscanf_r+0x29c>)
 8004630:	f7fb fdd6 	bl	80001e0 <memchr>
 8004634:	b140      	cbz	r0, 8004648 <__svfiscanf_r+0xd8>
 8004636:	2301      	movs	r3, #1
 8004638:	ebcb 0000 	rsb	r0, fp, r0
 800463c:	fa03 f000 	lsl.w	r0, r3, r0
 8004640:	9b43      	ldr	r3, [sp, #268]	; 0x10c
 8004642:	4303      	orrs	r3, r0
 8004644:	9343      	str	r3, [sp, #268]	; 0x10c
 8004646:	4634      	mov	r4, r6
 8004648:	1c66      	adds	r6, r4, #1
 800464a:	7824      	ldrb	r4, [r4, #0]
 800464c:	2c67      	cmp	r4, #103	; 0x67
 800464e:	d816      	bhi.n	800467e <__svfiscanf_r+0x10e>
 8004650:	2c65      	cmp	r4, #101	; 0x65
 8004652:	d27f      	bcs.n	8004754 <__svfiscanf_r+0x1e4>
 8004654:	2c47      	cmp	r4, #71	; 0x47
 8004656:	d807      	bhi.n	8004668 <__svfiscanf_r+0xf8>
 8004658:	2c45      	cmp	r4, #69	; 0x45
 800465a:	d27b      	bcs.n	8004754 <__svfiscanf_r+0x1e4>
 800465c:	2c00      	cmp	r4, #0
 800465e:	f000 80cb 	beq.w	80047f8 <__svfiscanf_r+0x288>
 8004662:	2c25      	cmp	r4, #37	; 0x25
 8004664:	d01e      	beq.n	80046a4 <__svfiscanf_r+0x134>
 8004666:	e077      	b.n	8004758 <__svfiscanf_r+0x1e8>
 8004668:	2c5b      	cmp	r4, #91	; 0x5b
 800466a:	d051      	beq.n	8004710 <__svfiscanf_r+0x1a0>
 800466c:	d802      	bhi.n	8004674 <__svfiscanf_r+0x104>
 800466e:	2c58      	cmp	r4, #88	; 0x58
 8004670:	d03e      	beq.n	80046f0 <__svfiscanf_r+0x180>
 8004672:	e071      	b.n	8004758 <__svfiscanf_r+0x1e8>
 8004674:	2c63      	cmp	r4, #99	; 0x63
 8004676:	d057      	beq.n	8004728 <__svfiscanf_r+0x1b8>
 8004678:	2c64      	cmp	r4, #100	; 0x64
 800467a:	d03f      	beq.n	80046fc <__svfiscanf_r+0x18c>
 800467c:	e06c      	b.n	8004758 <__svfiscanf_r+0x1e8>
 800467e:	2c70      	cmp	r4, #112	; 0x70
 8004680:	d032      	beq.n	80046e8 <__svfiscanf_r+0x178>
 8004682:	d807      	bhi.n	8004694 <__svfiscanf_r+0x124>
 8004684:	2c6e      	cmp	r4, #110	; 0x6e
 8004686:	d055      	beq.n	8004734 <__svfiscanf_r+0x1c4>
 8004688:	d83a      	bhi.n	8004700 <__svfiscanf_r+0x190>
 800468a:	2c69      	cmp	r4, #105	; 0x69
 800468c:	d164      	bne.n	8004758 <__svfiscanf_r+0x1e8>
 800468e:	2300      	movs	r3, #0
 8004690:	9344      	str	r3, [sp, #272]	; 0x110
 8004692:	e03b      	b.n	800470c <__svfiscanf_r+0x19c>
 8004694:	2c75      	cmp	r4, #117	; 0x75
 8004696:	d031      	beq.n	80046fc <__svfiscanf_r+0x18c>
 8004698:	2c78      	cmp	r4, #120	; 0x78
 800469a:	d029      	beq.n	80046f0 <__svfiscanf_r+0x180>
 800469c:	2c73      	cmp	r4, #115	; 0x73
 800469e:	d15b      	bne.n	8004758 <__svfiscanf_r+0x1e8>
 80046a0:	2302      	movs	r3, #2
 80046a2:	e03f      	b.n	8004724 <__svfiscanf_r+0x1b4>
 80046a4:	686b      	ldr	r3, [r5, #4]
 80046a6:	2b00      	cmp	r3, #0
 80046a8:	dd0d      	ble.n	80046c6 <__svfiscanf_r+0x156>
 80046aa:	682b      	ldr	r3, [r5, #0]
 80046ac:	781a      	ldrb	r2, [r3, #0]
 80046ae:	4294      	cmp	r4, r2
 80046b0:	f040 80a0 	bne.w	80047f4 <__svfiscanf_r+0x284>
 80046b4:	3301      	adds	r3, #1
 80046b6:	686a      	ldr	r2, [r5, #4]
 80046b8:	602b      	str	r3, [r5, #0]
 80046ba:	9b47      	ldr	r3, [sp, #284]	; 0x11c
 80046bc:	3a01      	subs	r2, #1
 80046be:	3301      	adds	r3, #1
 80046c0:	606a      	str	r2, [r5, #4]
 80046c2:	9347      	str	r3, [sp, #284]	; 0x11c
 80046c4:	e795      	b.n	80045f2 <__svfiscanf_r+0x82>
 80046c6:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
 80046c8:	4629      	mov	r1, r5
 80046ca:	4638      	mov	r0, r7
 80046cc:	4798      	blx	r3
 80046ce:	2800      	cmp	r0, #0
 80046d0:	d0eb      	beq.n	80046aa <__svfiscanf_r+0x13a>
 80046d2:	9846      	ldr	r0, [sp, #280]	; 0x118
 80046d4:	2800      	cmp	r0, #0
 80046d6:	f000 808f 	beq.w	80047f8 <__svfiscanf_r+0x288>
 80046da:	89ab      	ldrh	r3, [r5, #12]
 80046dc:	f013 0f40 	tst.w	r3, #64	; 0x40
 80046e0:	bf18      	it	ne
 80046e2:	f04f 30ff 	movne.w	r0, #4294967295
 80046e6:	e089      	b.n	80047fc <__svfiscanf_r+0x28c>
 80046e8:	9b43      	ldr	r3, [sp, #268]	; 0x10c
 80046ea:	f043 0320 	orr.w	r3, r3, #32
 80046ee:	9343      	str	r3, [sp, #268]	; 0x10c
 80046f0:	9b43      	ldr	r3, [sp, #268]	; 0x10c
 80046f2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80046f6:	9343      	str	r3, [sp, #268]	; 0x10c
 80046f8:	2310      	movs	r3, #16
 80046fa:	e002      	b.n	8004702 <__svfiscanf_r+0x192>
 80046fc:	230a      	movs	r3, #10
 80046fe:	e000      	b.n	8004702 <__svfiscanf_r+0x192>
 8004700:	2308      	movs	r3, #8
 8004702:	2c6e      	cmp	r4, #110	; 0x6e
 8004704:	9344      	str	r3, [sp, #272]	; 0x110
 8004706:	dd01      	ble.n	800470c <__svfiscanf_r+0x19c>
 8004708:	2304      	movs	r3, #4
 800470a:	e00b      	b.n	8004724 <__svfiscanf_r+0x1b4>
 800470c:	2303      	movs	r3, #3
 800470e:	e009      	b.n	8004724 <__svfiscanf_r+0x1b4>
 8004710:	4631      	mov	r1, r6
 8004712:	4640      	mov	r0, r8
 8004714:	f000 fa90 	bl	8004c38 <__sccl>
 8004718:	9b43      	ldr	r3, [sp, #268]	; 0x10c
 800471a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800471e:	9343      	str	r3, [sp, #268]	; 0x10c
 8004720:	4606      	mov	r6, r0
 8004722:	2301      	movs	r3, #1
 8004724:	9349      	str	r3, [sp, #292]	; 0x124
 8004726:	e01b      	b.n	8004760 <__svfiscanf_r+0x1f0>
 8004728:	9b43      	ldr	r3, [sp, #268]	; 0x10c
 800472a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800472e:	9343      	str	r3, [sp, #268]	; 0x10c
 8004730:	2300      	movs	r3, #0
 8004732:	e7f7      	b.n	8004724 <__svfiscanf_r+0x1b4>
 8004734:	9a43      	ldr	r2, [sp, #268]	; 0x10c
 8004736:	06d0      	lsls	r0, r2, #27
 8004738:	f53f af5b 	bmi.w	80045f2 <__svfiscanf_r+0x82>
 800473c:	f012 0f01 	tst.w	r2, #1
 8004740:	9a01      	ldr	r2, [sp, #4]
 8004742:	9b47      	ldr	r3, [sp, #284]	; 0x11c
 8004744:	f102 0104 	add.w	r1, r2, #4
 8004748:	9101      	str	r1, [sp, #4]
 800474a:	6812      	ldr	r2, [r2, #0]
 800474c:	bf14      	ite	ne
 800474e:	8013      	strhne	r3, [r2, #0]
 8004750:	6013      	streq	r3, [r2, #0]
 8004752:	e74e      	b.n	80045f2 <__svfiscanf_r+0x82>
 8004754:	2305      	movs	r3, #5
 8004756:	e7e5      	b.n	8004724 <__svfiscanf_r+0x1b4>
 8004758:	2303      	movs	r3, #3
 800475a:	9349      	str	r3, [sp, #292]	; 0x124
 800475c:	230a      	movs	r3, #10
 800475e:	9344      	str	r3, [sp, #272]	; 0x110
 8004760:	686b      	ldr	r3, [r5, #4]
 8004762:	2b00      	cmp	r3, #0
 8004764:	dd03      	ble.n	800476e <__svfiscanf_r+0x1fe>
 8004766:	9b43      	ldr	r3, [sp, #268]	; 0x10c
 8004768:	0659      	lsls	r1, r3, #25
 800476a:	d511      	bpl.n	8004790 <__svfiscanf_r+0x220>
 800476c:	e018      	b.n	80047a0 <__svfiscanf_r+0x230>
 800476e:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
 8004770:	4629      	mov	r1, r5
 8004772:	4638      	mov	r0, r7
 8004774:	4798      	blx	r3
 8004776:	2800      	cmp	r0, #0
 8004778:	d0f5      	beq.n	8004766 <__svfiscanf_r+0x1f6>
 800477a:	e7aa      	b.n	80046d2 <__svfiscanf_r+0x162>
 800477c:	9a47      	ldr	r2, [sp, #284]	; 0x11c
 800477e:	3201      	adds	r2, #1
 8004780:	9247      	str	r2, [sp, #284]	; 0x11c
 8004782:	686a      	ldr	r2, [r5, #4]
 8004784:	3a01      	subs	r2, #1
 8004786:	2a00      	cmp	r2, #0
 8004788:	606a      	str	r2, [r5, #4]
 800478a:	dd13      	ble.n	80047b4 <__svfiscanf_r+0x244>
 800478c:	3301      	adds	r3, #1
 800478e:	602b      	str	r3, [r5, #0]
 8004790:	682b      	ldr	r3, [r5, #0]
 8004792:	f8da 1000 	ldr.w	r1, [sl]
 8004796:	781a      	ldrb	r2, [r3, #0]
 8004798:	440a      	add	r2, r1
 800479a:	7852      	ldrb	r2, [r2, #1]
 800479c:	0712      	lsls	r2, r2, #28
 800479e:	d4ed      	bmi.n	800477c <__svfiscanf_r+0x20c>
 80047a0:	9b49      	ldr	r3, [sp, #292]	; 0x124
 80047a2:	2b02      	cmp	r3, #2
 80047a4:	dc0d      	bgt.n	80047c2 <__svfiscanf_r+0x252>
 80047a6:	ab01      	add	r3, sp, #4
 80047a8:	462a      	mov	r2, r5
 80047aa:	a943      	add	r1, sp, #268	; 0x10c
 80047ac:	4638      	mov	r0, r7
 80047ae:	f000 f85b 	bl	8004868 <_scanf_chars>
 80047b2:	e019      	b.n	80047e8 <__svfiscanf_r+0x278>
 80047b4:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
 80047b6:	4629      	mov	r1, r5
 80047b8:	4638      	mov	r0, r7
 80047ba:	4798      	blx	r3
 80047bc:	2800      	cmp	r0, #0
 80047be:	d0e7      	beq.n	8004790 <__svfiscanf_r+0x220>
 80047c0:	e787      	b.n	80046d2 <__svfiscanf_r+0x162>
 80047c2:	2b04      	cmp	r3, #4
 80047c4:	dc06      	bgt.n	80047d4 <__svfiscanf_r+0x264>
 80047c6:	ab01      	add	r3, sp, #4
 80047c8:	462a      	mov	r2, r5
 80047ca:	a943      	add	r1, sp, #268	; 0x10c
 80047cc:	4638      	mov	r0, r7
 80047ce:	f000 f8af 	bl	8004930 <_scanf_i>
 80047d2:	e009      	b.n	80047e8 <__svfiscanf_r+0x278>
 80047d4:	4b0e      	ldr	r3, [pc, #56]	; (8004810 <__svfiscanf_r+0x2a0>)
 80047d6:	2b00      	cmp	r3, #0
 80047d8:	f43f af0b 	beq.w	80045f2 <__svfiscanf_r+0x82>
 80047dc:	ab01      	add	r3, sp, #4
 80047de:	462a      	mov	r2, r5
 80047e0:	a943      	add	r1, sp, #268	; 0x10c
 80047e2:	4638      	mov	r0, r7
 80047e4:	f3af 8000 	nop.w
 80047e8:	2801      	cmp	r0, #1
 80047ea:	d003      	beq.n	80047f4 <__svfiscanf_r+0x284>
 80047ec:	2802      	cmp	r0, #2
 80047ee:	f47f af00 	bne.w	80045f2 <__svfiscanf_r+0x82>
 80047f2:	e76e      	b.n	80046d2 <__svfiscanf_r+0x162>
 80047f4:	9846      	ldr	r0, [sp, #280]	; 0x118
 80047f6:	e001      	b.n	80047fc <__svfiscanf_r+0x28c>
 80047f8:	f04f 30ff 	mov.w	r0, #4294967295
 80047fc:	f50d 7d25 	add.w	sp, sp, #660	; 0x294
 8004800:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004804:	08004fa1 	.word	0x08004fa1
 8004808:	08004b29 	.word	0x08004b29
 800480c:	08007af0 	.word	0x08007af0
 8004810:	00000000 	.word	0x00000000
 8004814:	20000110 	.word	0x20000110

08004818 <_vfiscanf_r>:
 8004818:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800481c:	460c      	mov	r4, r1
 800481e:	4616      	mov	r6, r2
 8004820:	461f      	mov	r7, r3
 8004822:	4605      	mov	r5, r0
 8004824:	b118      	cbz	r0, 800482e <_vfiscanf_r+0x16>
 8004826:	6983      	ldr	r3, [r0, #24]
 8004828:	b90b      	cbnz	r3, 800482e <_vfiscanf_r+0x16>
 800482a:	f7ff fd99 	bl	8004360 <__sinit>
 800482e:	4b0b      	ldr	r3, [pc, #44]	; (800485c <_vfiscanf_r+0x44>)
 8004830:	429c      	cmp	r4, r3
 8004832:	d101      	bne.n	8004838 <_vfiscanf_r+0x20>
 8004834:	686c      	ldr	r4, [r5, #4]
 8004836:	e008      	b.n	800484a <_vfiscanf_r+0x32>
 8004838:	4b09      	ldr	r3, [pc, #36]	; (8004860 <_vfiscanf_r+0x48>)
 800483a:	429c      	cmp	r4, r3
 800483c:	d101      	bne.n	8004842 <_vfiscanf_r+0x2a>
 800483e:	68ac      	ldr	r4, [r5, #8]
 8004840:	e003      	b.n	800484a <_vfiscanf_r+0x32>
 8004842:	4b08      	ldr	r3, [pc, #32]	; (8004864 <_vfiscanf_r+0x4c>)
 8004844:	429c      	cmp	r4, r3
 8004846:	bf08      	it	eq
 8004848:	68ec      	ldreq	r4, [r5, #12]
 800484a:	463b      	mov	r3, r7
 800484c:	4632      	mov	r2, r6
 800484e:	4621      	mov	r1, r4
 8004850:	4628      	mov	r0, r5
 8004852:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8004856:	f7ff be8b 	b.w	8004570 <__svfiscanf_r>
 800485a:	bf00      	nop
 800485c:	08007a88 	.word	0x08007a88
 8004860:	08007aa8 	.word	0x08007aa8
 8004864:	08007ac8 	.word	0x08007ac8

08004868 <_scanf_chars>:
 8004868:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800486c:	4615      	mov	r5, r2
 800486e:	688a      	ldr	r2, [r1, #8]
 8004870:	4680      	mov	r8, r0
 8004872:	460c      	mov	r4, r1
 8004874:	b932      	cbnz	r2, 8004884 <_scanf_chars+0x1c>
 8004876:	698a      	ldr	r2, [r1, #24]
 8004878:	2a00      	cmp	r2, #0
 800487a:	bf0c      	ite	eq
 800487c:	2201      	moveq	r2, #1
 800487e:	f04f 32ff 	movne.w	r2, #4294967295
 8004882:	608a      	str	r2, [r1, #8]
 8004884:	6822      	ldr	r2, [r4, #0]
 8004886:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 800492c <_scanf_chars+0xc4>
 800488a:	06d1      	lsls	r1, r2, #27
 800488c:	bf5f      	itttt	pl
 800488e:	681a      	ldrpl	r2, [r3, #0]
 8004890:	1d11      	addpl	r1, r2, #4
 8004892:	6019      	strpl	r1, [r3, #0]
 8004894:	6817      	ldrpl	r7, [r2, #0]
 8004896:	2600      	movs	r6, #0
 8004898:	69a0      	ldr	r0, [r4, #24]
 800489a:	bb00      	cbnz	r0, 80048de <_scanf_chars+0x76>
 800489c:	6823      	ldr	r3, [r4, #0]
 800489e:	06da      	lsls	r2, r3, #27
 80048a0:	bf5e      	ittt	pl
 80048a2:	682b      	ldrpl	r3, [r5, #0]
 80048a4:	781b      	ldrbpl	r3, [r3, #0]
 80048a6:	703b      	strbpl	r3, [r7, #0]
 80048a8:	682a      	ldr	r2, [r5, #0]
 80048aa:	686b      	ldr	r3, [r5, #4]
 80048ac:	f102 0201 	add.w	r2, r2, #1
 80048b0:	602a      	str	r2, [r5, #0]
 80048b2:	68a2      	ldr	r2, [r4, #8]
 80048b4:	f103 33ff 	add.w	r3, r3, #4294967295
 80048b8:	f102 32ff 	add.w	r2, r2, #4294967295
 80048bc:	606b      	str	r3, [r5, #4]
 80048be:	f106 0601 	add.w	r6, r6, #1
 80048c2:	bf58      	it	pl
 80048c4:	3701      	addpl	r7, #1
 80048c6:	60a2      	str	r2, [r4, #8]
 80048c8:	b1e2      	cbz	r2, 8004904 <_scanf_chars+0x9c>
 80048ca:	2b00      	cmp	r3, #0
 80048cc:	dce4      	bgt.n	8004898 <_scanf_chars+0x30>
 80048ce:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
 80048d2:	4629      	mov	r1, r5
 80048d4:	4640      	mov	r0, r8
 80048d6:	4798      	blx	r3
 80048d8:	2800      	cmp	r0, #0
 80048da:	d0dd      	beq.n	8004898 <_scanf_chars+0x30>
 80048dc:	e012      	b.n	8004904 <_scanf_chars+0x9c>
 80048de:	2801      	cmp	r0, #1
 80048e0:	d106      	bne.n	80048f0 <_scanf_chars+0x88>
 80048e2:	682b      	ldr	r3, [r5, #0]
 80048e4:	781a      	ldrb	r2, [r3, #0]
 80048e6:	6963      	ldr	r3, [r4, #20]
 80048e8:	5c9b      	ldrb	r3, [r3, r2]
 80048ea:	2b00      	cmp	r3, #0
 80048ec:	d1d6      	bne.n	800489c <_scanf_chars+0x34>
 80048ee:	e019      	b.n	8004924 <_scanf_chars+0xbc>
 80048f0:	2802      	cmp	r0, #2
 80048f2:	d107      	bne.n	8004904 <_scanf_chars+0x9c>
 80048f4:	682b      	ldr	r3, [r5, #0]
 80048f6:	f8d9 2000 	ldr.w	r2, [r9]
 80048fa:	781b      	ldrb	r3, [r3, #0]
 80048fc:	4413      	add	r3, r2
 80048fe:	785b      	ldrb	r3, [r3, #1]
 8004900:	071b      	lsls	r3, r3, #28
 8004902:	d5cb      	bpl.n	800489c <_scanf_chars+0x34>
 8004904:	6823      	ldr	r3, [r4, #0]
 8004906:	f013 0310 	ands.w	r3, r3, #16
 800490a:	d105      	bne.n	8004918 <_scanf_chars+0xb0>
 800490c:	68e2      	ldr	r2, [r4, #12]
 800490e:	3201      	adds	r2, #1
 8004910:	60e2      	str	r2, [r4, #12]
 8004912:	69a2      	ldr	r2, [r4, #24]
 8004914:	b102      	cbz	r2, 8004918 <_scanf_chars+0xb0>
 8004916:	703b      	strb	r3, [r7, #0]
 8004918:	6923      	ldr	r3, [r4, #16]
 800491a:	441e      	add	r6, r3
 800491c:	6126      	str	r6, [r4, #16]
 800491e:	2000      	movs	r0, #0
 8004920:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004924:	2e00      	cmp	r6, #0
 8004926:	d1ed      	bne.n	8004904 <_scanf_chars+0x9c>
 8004928:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800492c:	20000110 	.word	0x20000110

08004930 <_scanf_i>:
 8004930:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004934:	469a      	mov	sl, r3
 8004936:	4b73      	ldr	r3, [pc, #460]	; (8004b04 <_scanf_i+0x1d4>)
 8004938:	460c      	mov	r4, r1
 800493a:	4683      	mov	fp, r0
 800493c:	4616      	mov	r6, r2
 800493e:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8004942:	b087      	sub	sp, #28
 8004944:	ab03      	add	r3, sp, #12
 8004946:	68a7      	ldr	r7, [r4, #8]
 8004948:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 800494c:	4b6e      	ldr	r3, [pc, #440]	; (8004b08 <_scanf_i+0x1d8>)
 800494e:	69a1      	ldr	r1, [r4, #24]
 8004950:	4a6e      	ldr	r2, [pc, #440]	; (8004b0c <_scanf_i+0x1dc>)
 8004952:	2903      	cmp	r1, #3
 8004954:	bf18      	it	ne
 8004956:	461a      	movne	r2, r3
 8004958:	1e7b      	subs	r3, r7, #1
 800495a:	f5b3 7fae 	cmp.w	r3, #348	; 0x15c
 800495e:	bf84      	itt	hi
 8004960:	f240 135d 	movwhi	r3, #349	; 0x15d
 8004964:	60a3      	strhi	r3, [r4, #8]
 8004966:	6823      	ldr	r3, [r4, #0]
 8004968:	9200      	str	r2, [sp, #0]
 800496a:	f443 6350 	orr.w	r3, r3, #3328	; 0xd00
 800496e:	bf88      	it	hi
 8004970:	f46f 75ae 	mvnhi.w	r5, #348	; 0x15c
 8004974:	f104 091c 	add.w	r9, r4, #28
 8004978:	6023      	str	r3, [r4, #0]
 800497a:	bf8c      	ite	hi
 800497c:	197f      	addhi	r7, r7, r5
 800497e:	2700      	movls	r7, #0
 8004980:	464b      	mov	r3, r9
 8004982:	f04f 0800 	mov.w	r8, #0
 8004986:	9301      	str	r3, [sp, #4]
 8004988:	6831      	ldr	r1, [r6, #0]
 800498a:	ab03      	add	r3, sp, #12
 800498c:	2202      	movs	r2, #2
 800498e:	f853 0028 	ldr.w	r0, [r3, r8, lsl #2]
 8004992:	7809      	ldrb	r1, [r1, #0]
 8004994:	f7fb fc24 	bl	80001e0 <memchr>
 8004998:	9b01      	ldr	r3, [sp, #4]
 800499a:	2800      	cmp	r0, #0
 800499c:	d033      	beq.n	8004a06 <_scanf_i+0xd6>
 800499e:	f1b8 0f01 	cmp.w	r8, #1
 80049a2:	d10b      	bne.n	80049bc <_scanf_i+0x8c>
 80049a4:	6862      	ldr	r2, [r4, #4]
 80049a6:	b92a      	cbnz	r2, 80049b4 <_scanf_i+0x84>
 80049a8:	2208      	movs	r2, #8
 80049aa:	6062      	str	r2, [r4, #4]
 80049ac:	6822      	ldr	r2, [r4, #0]
 80049ae:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80049b2:	6022      	str	r2, [r4, #0]
 80049b4:	6822      	ldr	r2, [r4, #0]
 80049b6:	f422 62a0 	bic.w	r2, r2, #1280	; 0x500
 80049ba:	e00c      	b.n	80049d6 <_scanf_i+0xa6>
 80049bc:	f1b8 0f02 	cmp.w	r8, #2
 80049c0:	d10a      	bne.n	80049d8 <_scanf_i+0xa8>
 80049c2:	6822      	ldr	r2, [r4, #0]
 80049c4:	f402 61c0 	and.w	r1, r2, #1536	; 0x600
 80049c8:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 80049cc:	d11b      	bne.n	8004a06 <_scanf_i+0xd6>
 80049ce:	2110      	movs	r1, #16
 80049d0:	6061      	str	r1, [r4, #4]
 80049d2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80049d6:	6022      	str	r2, [r4, #0]
 80049d8:	68a2      	ldr	r2, [r4, #8]
 80049da:	1e51      	subs	r1, r2, #1
 80049dc:	60a1      	str	r1, [r4, #8]
 80049de:	b192      	cbz	r2, 8004a06 <_scanf_i+0xd6>
 80049e0:	6832      	ldr	r2, [r6, #0]
 80049e2:	1c51      	adds	r1, r2, #1
 80049e4:	6031      	str	r1, [r6, #0]
 80049e6:	7812      	ldrb	r2, [r2, #0]
 80049e8:	701a      	strb	r2, [r3, #0]
 80049ea:	1c5d      	adds	r5, r3, #1
 80049ec:	6873      	ldr	r3, [r6, #4]
 80049ee:	3b01      	subs	r3, #1
 80049f0:	2b00      	cmp	r3, #0
 80049f2:	6073      	str	r3, [r6, #4]
 80049f4:	dc06      	bgt.n	8004a04 <_scanf_i+0xd4>
 80049f6:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
 80049fa:	4631      	mov	r1, r6
 80049fc:	4658      	mov	r0, fp
 80049fe:	4798      	blx	r3
 8004a00:	2800      	cmp	r0, #0
 8004a02:	d140      	bne.n	8004a86 <_scanf_i+0x156>
 8004a04:	462b      	mov	r3, r5
 8004a06:	f108 0801 	add.w	r8, r8, #1
 8004a0a:	f1b8 0f03 	cmp.w	r8, #3
 8004a0e:	d1ba      	bne.n	8004986 <_scanf_i+0x56>
 8004a10:	6862      	ldr	r2, [r4, #4]
 8004a12:	b90a      	cbnz	r2, 8004a18 <_scanf_i+0xe8>
 8004a14:	220a      	movs	r2, #10
 8004a16:	6062      	str	r2, [r4, #4]
 8004a18:	6862      	ldr	r2, [r4, #4]
 8004a1a:	493d      	ldr	r1, [pc, #244]	; (8004b10 <_scanf_i+0x1e0>)
 8004a1c:	6960      	ldr	r0, [r4, #20]
 8004a1e:	9301      	str	r3, [sp, #4]
 8004a20:	1a89      	subs	r1, r1, r2
 8004a22:	f000 f909 	bl	8004c38 <__sccl>
 8004a26:	9b01      	ldr	r3, [sp, #4]
 8004a28:	f04f 0800 	mov.w	r8, #0
 8004a2c:	461d      	mov	r5, r3
 8004a2e:	68a3      	ldr	r3, [r4, #8]
 8004a30:	b35b      	cbz	r3, 8004a8a <_scanf_i+0x15a>
 8004a32:	6831      	ldr	r1, [r6, #0]
 8004a34:	6960      	ldr	r0, [r4, #20]
 8004a36:	780a      	ldrb	r2, [r1, #0]
 8004a38:	5c80      	ldrb	r0, [r0, r2]
 8004a3a:	b330      	cbz	r0, 8004a8a <_scanf_i+0x15a>
 8004a3c:	2a30      	cmp	r2, #48	; 0x30
 8004a3e:	6822      	ldr	r2, [r4, #0]
 8004a40:	d108      	bne.n	8004a54 <_scanf_i+0x124>
 8004a42:	0510      	lsls	r0, r2, #20
 8004a44:	d506      	bpl.n	8004a54 <_scanf_i+0x124>
 8004a46:	f108 0801 	add.w	r8, r8, #1
 8004a4a:	b14f      	cbz	r7, 8004a60 <_scanf_i+0x130>
 8004a4c:	3301      	adds	r3, #1
 8004a4e:	3f01      	subs	r7, #1
 8004a50:	60a3      	str	r3, [r4, #8]
 8004a52:	e005      	b.n	8004a60 <_scanf_i+0x130>
 8004a54:	f422 6210 	bic.w	r2, r2, #2304	; 0x900
 8004a58:	6022      	str	r2, [r4, #0]
 8004a5a:	780b      	ldrb	r3, [r1, #0]
 8004a5c:	702b      	strb	r3, [r5, #0]
 8004a5e:	3501      	adds	r5, #1
 8004a60:	6873      	ldr	r3, [r6, #4]
 8004a62:	3b01      	subs	r3, #1
 8004a64:	2b00      	cmp	r3, #0
 8004a66:	6073      	str	r3, [r6, #4]
 8004a68:	dd03      	ble.n	8004a72 <_scanf_i+0x142>
 8004a6a:	6833      	ldr	r3, [r6, #0]
 8004a6c:	3301      	adds	r3, #1
 8004a6e:	6033      	str	r3, [r6, #0]
 8004a70:	e005      	b.n	8004a7e <_scanf_i+0x14e>
 8004a72:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
 8004a76:	4631      	mov	r1, r6
 8004a78:	4658      	mov	r0, fp
 8004a7a:	4798      	blx	r3
 8004a7c:	b928      	cbnz	r0, 8004a8a <_scanf_i+0x15a>
 8004a7e:	68a3      	ldr	r3, [r4, #8]
 8004a80:	3b01      	subs	r3, #1
 8004a82:	60a3      	str	r3, [r4, #8]
 8004a84:	e7d3      	b.n	8004a2e <_scanf_i+0xfe>
 8004a86:	f04f 0800 	mov.w	r8, #0
 8004a8a:	6823      	ldr	r3, [r4, #0]
 8004a8c:	05d9      	lsls	r1, r3, #23
 8004a8e:	d50c      	bpl.n	8004aaa <_scanf_i+0x17a>
 8004a90:	454d      	cmp	r5, r9
 8004a92:	d908      	bls.n	8004aa6 <_scanf_i+0x176>
 8004a94:	f815 1c01 	ldrb.w	r1, [r5, #-1]
 8004a98:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
 8004a9c:	4632      	mov	r2, r6
 8004a9e:	4658      	mov	r0, fp
 8004aa0:	4798      	blx	r3
 8004aa2:	1e6f      	subs	r7, r5, #1
 8004aa4:	463d      	mov	r5, r7
 8004aa6:	454d      	cmp	r5, r9
 8004aa8:	d027      	beq.n	8004afa <_scanf_i+0x1ca>
 8004aaa:	6822      	ldr	r2, [r4, #0]
 8004aac:	f012 0210 	ands.w	r2, r2, #16
 8004ab0:	d11b      	bne.n	8004aea <_scanf_i+0x1ba>
 8004ab2:	702a      	strb	r2, [r5, #0]
 8004ab4:	6863      	ldr	r3, [r4, #4]
 8004ab6:	9e00      	ldr	r6, [sp, #0]
 8004ab8:	4649      	mov	r1, r9
 8004aba:	4658      	mov	r0, fp
 8004abc:	47b0      	blx	r6
 8004abe:	6822      	ldr	r2, [r4, #0]
 8004ac0:	f8da 3000 	ldr.w	r3, [sl]
 8004ac4:	f012 0f20 	tst.w	r2, #32
 8004ac8:	d107      	bne.n	8004ada <_scanf_i+0x1aa>
 8004aca:	07d2      	lsls	r2, r2, #31
 8004acc:	d505      	bpl.n	8004ada <_scanf_i+0x1aa>
 8004ace:	1d1a      	adds	r2, r3, #4
 8004ad0:	f8ca 2000 	str.w	r2, [sl]
 8004ad4:	681b      	ldr	r3, [r3, #0]
 8004ad6:	8018      	strh	r0, [r3, #0]
 8004ad8:	e004      	b.n	8004ae4 <_scanf_i+0x1b4>
 8004ada:	1d1a      	adds	r2, r3, #4
 8004adc:	f8ca 2000 	str.w	r2, [sl]
 8004ae0:	681b      	ldr	r3, [r3, #0]
 8004ae2:	6018      	str	r0, [r3, #0]
 8004ae4:	68e3      	ldr	r3, [r4, #12]
 8004ae6:	3301      	adds	r3, #1
 8004ae8:	60e3      	str	r3, [r4, #12]
 8004aea:	6923      	ldr	r3, [r4, #16]
 8004aec:	ebc9 0505 	rsb	r5, r9, r5
 8004af0:	4445      	add	r5, r8
 8004af2:	441d      	add	r5, r3
 8004af4:	6125      	str	r5, [r4, #16]
 8004af6:	2000      	movs	r0, #0
 8004af8:	e000      	b.n	8004afc <_scanf_i+0x1cc>
 8004afa:	2001      	movs	r0, #1
 8004afc:	b007      	add	sp, #28
 8004afe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004b02:	bf00      	nop
 8004b04:	08006310 	.word	0x08006310
 8004b08:	08004e2d 	.word	0x08004e2d
 8004b0c:	08004d21 	.word	0x08004d21
 8004b10:	08007b04 	.word	0x08007b04

08004b14 <lflush>:
 8004b14:	8983      	ldrh	r3, [r0, #12]
 8004b16:	f003 0309 	and.w	r3, r3, #9
 8004b1a:	2b09      	cmp	r3, #9
 8004b1c:	d101      	bne.n	8004b22 <lflush+0xe>
 8004b1e:	f7ff bbcd 	b.w	80042bc <fflush>
 8004b22:	2000      	movs	r0, #0
 8004b24:	4770      	bx	lr
	...

08004b28 <__srefill_r>:
 8004b28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004b2a:	460c      	mov	r4, r1
 8004b2c:	4605      	mov	r5, r0
 8004b2e:	b118      	cbz	r0, 8004b38 <__srefill_r+0x10>
 8004b30:	6983      	ldr	r3, [r0, #24]
 8004b32:	b90b      	cbnz	r3, 8004b38 <__srefill_r+0x10>
 8004b34:	f7ff fc14 	bl	8004360 <__sinit>
 8004b38:	4b3a      	ldr	r3, [pc, #232]	; (8004c24 <__srefill_r+0xfc>)
 8004b3a:	429c      	cmp	r4, r3
 8004b3c:	d101      	bne.n	8004b42 <__srefill_r+0x1a>
 8004b3e:	686c      	ldr	r4, [r5, #4]
 8004b40:	e008      	b.n	8004b54 <__srefill_r+0x2c>
 8004b42:	4b39      	ldr	r3, [pc, #228]	; (8004c28 <__srefill_r+0x100>)
 8004b44:	429c      	cmp	r4, r3
 8004b46:	d101      	bne.n	8004b4c <__srefill_r+0x24>
 8004b48:	68ac      	ldr	r4, [r5, #8]
 8004b4a:	e003      	b.n	8004b54 <__srefill_r+0x2c>
 8004b4c:	4b37      	ldr	r3, [pc, #220]	; (8004c2c <__srefill_r+0x104>)
 8004b4e:	429c      	cmp	r4, r3
 8004b50:	bf08      	it	eq
 8004b52:	68ec      	ldreq	r4, [r5, #12]
 8004b54:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8004b58:	2300      	movs	r3, #0
 8004b5a:	6063      	str	r3, [r4, #4]
 8004b5c:	b293      	uxth	r3, r2
 8004b5e:	069e      	lsls	r6, r3, #26
 8004b60:	d45b      	bmi.n	8004c1a <__srefill_r+0xf2>
 8004b62:	0758      	lsls	r0, r3, #29
 8004b64:	d41a      	bmi.n	8004b9c <__srefill_r+0x74>
 8004b66:	06d9      	lsls	r1, r3, #27
 8004b68:	d405      	bmi.n	8004b76 <__srefill_r+0x4e>
 8004b6a:	2309      	movs	r3, #9
 8004b6c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8004b70:	602b      	str	r3, [r5, #0]
 8004b72:	81a2      	strh	r2, [r4, #12]
 8004b74:	e051      	b.n	8004c1a <__srefill_r+0xf2>
 8004b76:	071a      	lsls	r2, r3, #28
 8004b78:	d50b      	bpl.n	8004b92 <__srefill_r+0x6a>
 8004b7a:	4621      	mov	r1, r4
 8004b7c:	4628      	mov	r0, r5
 8004b7e:	f7ff fb73 	bl	8004268 <_fflush_r>
 8004b82:	2800      	cmp	r0, #0
 8004b84:	d149      	bne.n	8004c1a <__srefill_r+0xf2>
 8004b86:	89a3      	ldrh	r3, [r4, #12]
 8004b88:	60a0      	str	r0, [r4, #8]
 8004b8a:	f023 0308 	bic.w	r3, r3, #8
 8004b8e:	81a3      	strh	r3, [r4, #12]
 8004b90:	61a0      	str	r0, [r4, #24]
 8004b92:	89a3      	ldrh	r3, [r4, #12]
 8004b94:	f043 0304 	orr.w	r3, r3, #4
 8004b98:	81a3      	strh	r3, [r4, #12]
 8004b9a:	e010      	b.n	8004bbe <__srefill_r+0x96>
 8004b9c:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8004b9e:	b171      	cbz	r1, 8004bbe <__srefill_r+0x96>
 8004ba0:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8004ba4:	4299      	cmp	r1, r3
 8004ba6:	d002      	beq.n	8004bae <__srefill_r+0x86>
 8004ba8:	4628      	mov	r0, r5
 8004baa:	f7ff f8dd 	bl	8003d68 <_free_r>
 8004bae:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8004bb0:	6063      	str	r3, [r4, #4]
 8004bb2:	2000      	movs	r0, #0
 8004bb4:	6360      	str	r0, [r4, #52]	; 0x34
 8004bb6:	b113      	cbz	r3, 8004bbe <__srefill_r+0x96>
 8004bb8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004bba:	6023      	str	r3, [r4, #0]
 8004bbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004bbe:	6923      	ldr	r3, [r4, #16]
 8004bc0:	b91b      	cbnz	r3, 8004bca <__srefill_r+0xa2>
 8004bc2:	4621      	mov	r1, r4
 8004bc4:	4628      	mov	r0, r5
 8004bc6:	f7ff fc95 	bl	80044f4 <__smakebuf_r>
 8004bca:	f9b4 700c 	ldrsh.w	r7, [r4, #12]
 8004bce:	b2be      	uxth	r6, r7
 8004bd0:	07b3      	lsls	r3, r6, #30
 8004bd2:	d00f      	beq.n	8004bf4 <__srefill_r+0xcc>
 8004bd4:	2301      	movs	r3, #1
 8004bd6:	81a3      	strh	r3, [r4, #12]
 8004bd8:	4b15      	ldr	r3, [pc, #84]	; (8004c30 <__srefill_r+0x108>)
 8004bda:	4916      	ldr	r1, [pc, #88]	; (8004c34 <__srefill_r+0x10c>)
 8004bdc:	6818      	ldr	r0, [r3, #0]
 8004bde:	f006 0609 	and.w	r6, r6, #9
 8004be2:	f7ff fc29 	bl	8004438 <_fwalk>
 8004be6:	2e09      	cmp	r6, #9
 8004be8:	81a7      	strh	r7, [r4, #12]
 8004bea:	d103      	bne.n	8004bf4 <__srefill_r+0xcc>
 8004bec:	4621      	mov	r1, r4
 8004bee:	4628      	mov	r0, r5
 8004bf0:	f7ff fab2 	bl	8004158 <__sflush_r>
 8004bf4:	6922      	ldr	r2, [r4, #16]
 8004bf6:	6022      	str	r2, [r4, #0]
 8004bf8:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8004bfa:	6963      	ldr	r3, [r4, #20]
 8004bfc:	6a21      	ldr	r1, [r4, #32]
 8004bfe:	4628      	mov	r0, r5
 8004c00:	47b0      	blx	r6
 8004c02:	2800      	cmp	r0, #0
 8004c04:	6060      	str	r0, [r4, #4]
 8004c06:	dc0b      	bgt.n	8004c20 <__srefill_r+0xf8>
 8004c08:	89a3      	ldrh	r3, [r4, #12]
 8004c0a:	bf17      	itett	ne
 8004c0c:	2200      	movne	r2, #0
 8004c0e:	f043 0320 	orreq.w	r3, r3, #32
 8004c12:	f043 0340 	orrne.w	r3, r3, #64	; 0x40
 8004c16:	6062      	strne	r2, [r4, #4]
 8004c18:	81a3      	strh	r3, [r4, #12]
 8004c1a:	f04f 30ff 	mov.w	r0, #4294967295
 8004c1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004c20:	2000      	movs	r0, #0
 8004c22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004c24:	08007a88 	.word	0x08007a88
 8004c28:	08007aa8 	.word	0x08007aa8
 8004c2c:	08007ac8 	.word	0x08007ac8
 8004c30:	08007aec 	.word	0x08007aec
 8004c34:	08004b15 	.word	0x08004b15

08004c38 <__sccl>:
 8004c38:	b570      	push	{r4, r5, r6, lr}
 8004c3a:	780b      	ldrb	r3, [r1, #0]
 8004c3c:	2b5e      	cmp	r3, #94	; 0x5e
 8004c3e:	bf13      	iteet	ne
 8004c40:	1c4a      	addne	r2, r1, #1
 8004c42:	1c8a      	addeq	r2, r1, #2
 8004c44:	784b      	ldrbeq	r3, [r1, #1]
 8004c46:	2100      	movne	r1, #0
 8004c48:	bf08      	it	eq
 8004c4a:	2101      	moveq	r1, #1
 8004c4c:	1e44      	subs	r4, r0, #1
 8004c4e:	f100 05ff 	add.w	r5, r0, #255	; 0xff
 8004c52:	f804 1f01 	strb.w	r1, [r4, #1]!
 8004c56:	42ac      	cmp	r4, r5
 8004c58:	d1fb      	bne.n	8004c52 <__sccl+0x1a>
 8004c5a:	b90b      	cbnz	r3, 8004c60 <__sccl+0x28>
 8004c5c:	1e50      	subs	r0, r2, #1
 8004c5e:	bd70      	pop	{r4, r5, r6, pc}
 8004c60:	f081 0401 	eor.w	r4, r1, #1
 8004c64:	54c4      	strb	r4, [r0, r3]
 8004c66:	4611      	mov	r1, r2
 8004c68:	780d      	ldrb	r5, [r1, #0]
 8004c6a:	2d2d      	cmp	r5, #45	; 0x2d
 8004c6c:	f101 0201 	add.w	r2, r1, #1
 8004c70:	d006      	beq.n	8004c80 <__sccl+0x48>
 8004c72:	2d5d      	cmp	r5, #93	; 0x5d
 8004c74:	d00f      	beq.n	8004c96 <__sccl+0x5e>
 8004c76:	b10d      	cbz	r5, 8004c7c <__sccl+0x44>
 8004c78:	462b      	mov	r3, r5
 8004c7a:	e7f3      	b.n	8004c64 <__sccl+0x2c>
 8004c7c:	4608      	mov	r0, r1
 8004c7e:	bd70      	pop	{r4, r5, r6, pc}
 8004c80:	784e      	ldrb	r6, [r1, #1]
 8004c82:	2e5d      	cmp	r6, #93	; 0x5d
 8004c84:	d0f8      	beq.n	8004c78 <__sccl+0x40>
 8004c86:	42b3      	cmp	r3, r6
 8004c88:	dcf6      	bgt.n	8004c78 <__sccl+0x40>
 8004c8a:	3102      	adds	r1, #2
 8004c8c:	3301      	adds	r3, #1
 8004c8e:	429e      	cmp	r6, r3
 8004c90:	54c4      	strb	r4, [r0, r3]
 8004c92:	dcfb      	bgt.n	8004c8c <__sccl+0x54>
 8004c94:	e7e8      	b.n	8004c68 <__sccl+0x30>
 8004c96:	4610      	mov	r0, r2
 8004c98:	bd70      	pop	{r4, r5, r6, pc}

08004c9a <__sread>:
 8004c9a:	b510      	push	{r4, lr}
 8004c9c:	460c      	mov	r4, r1
 8004c9e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8004ca2:	f000 fa77 	bl	8005194 <_read_r>
 8004ca6:	2800      	cmp	r0, #0
 8004ca8:	bfab      	itete	ge
 8004caa:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8004cac:	89a3      	ldrhlt	r3, [r4, #12]
 8004cae:	181b      	addge	r3, r3, r0
 8004cb0:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8004cb4:	bfac      	ite	ge
 8004cb6:	6563      	strge	r3, [r4, #84]	; 0x54
 8004cb8:	81a3      	strhlt	r3, [r4, #12]
 8004cba:	bd10      	pop	{r4, pc}

08004cbc <__swrite>:
 8004cbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004cc0:	461f      	mov	r7, r3
 8004cc2:	898b      	ldrh	r3, [r1, #12]
 8004cc4:	05db      	lsls	r3, r3, #23
 8004cc6:	4605      	mov	r5, r0
 8004cc8:	460c      	mov	r4, r1
 8004cca:	4616      	mov	r6, r2
 8004ccc:	d505      	bpl.n	8004cda <__swrite+0x1e>
 8004cce:	2302      	movs	r3, #2
 8004cd0:	2200      	movs	r2, #0
 8004cd2:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8004cd6:	f000 fa19 	bl	800510c <_lseek_r>
 8004cda:	89a3      	ldrh	r3, [r4, #12]
 8004cdc:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8004ce0:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8004ce4:	81a3      	strh	r3, [r4, #12]
 8004ce6:	4632      	mov	r2, r6
 8004ce8:	463b      	mov	r3, r7
 8004cea:	4628      	mov	r0, r5
 8004cec:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8004cf0:	f000 b9c8 	b.w	8005084 <_write_r>

08004cf4 <__sseek>:
 8004cf4:	b510      	push	{r4, lr}
 8004cf6:	460c      	mov	r4, r1
 8004cf8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8004cfc:	f000 fa06 	bl	800510c <_lseek_r>
 8004d00:	1c43      	adds	r3, r0, #1
 8004d02:	89a3      	ldrh	r3, [r4, #12]
 8004d04:	bf15      	itete	ne
 8004d06:	6560      	strne	r0, [r4, #84]	; 0x54
 8004d08:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8004d0c:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8004d10:	81a3      	strheq	r3, [r4, #12]
 8004d12:	bf18      	it	ne
 8004d14:	81a3      	strhne	r3, [r4, #12]
 8004d16:	bd10      	pop	{r4, pc}

08004d18 <__sclose>:
 8004d18:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8004d1c:	f000 b9c4 	b.w	80050a8 <_close_r>

08004d20 <_strtol_r>:
 8004d20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004d24:	4680      	mov	r8, r0
 8004d26:	4840      	ldr	r0, [pc, #256]	; (8004e28 <_strtol_r+0x108>)
 8004d28:	f8d0 9000 	ldr.w	r9, [r0]
 8004d2c:	460f      	mov	r7, r1
 8004d2e:	463d      	mov	r5, r7
 8004d30:	f815 4b01 	ldrb.w	r4, [r5], #1
 8004d34:	eb09 0004 	add.w	r0, r9, r4
 8004d38:	7840      	ldrb	r0, [r0, #1]
 8004d3a:	f000 0008 	and.w	r0, r0, #8
 8004d3e:	f000 06ff 	and.w	r6, r0, #255	; 0xff
 8004d42:	b108      	cbz	r0, 8004d48 <_strtol_r+0x28>
 8004d44:	462f      	mov	r7, r5
 8004d46:	e7f2      	b.n	8004d2e <_strtol_r+0xe>
 8004d48:	2c2d      	cmp	r4, #45	; 0x2d
 8004d4a:	d103      	bne.n	8004d54 <_strtol_r+0x34>
 8004d4c:	1cbd      	adds	r5, r7, #2
 8004d4e:	787c      	ldrb	r4, [r7, #1]
 8004d50:	2601      	movs	r6, #1
 8004d52:	e003      	b.n	8004d5c <_strtol_r+0x3c>
 8004d54:	2c2b      	cmp	r4, #43	; 0x2b
 8004d56:	bf04      	itt	eq
 8004d58:	787c      	ldrbeq	r4, [r7, #1]
 8004d5a:	1cbd      	addeq	r5, r7, #2
 8004d5c:	b113      	cbz	r3, 8004d64 <_strtol_r+0x44>
 8004d5e:	2b10      	cmp	r3, #16
 8004d60:	d10a      	bne.n	8004d78 <_strtol_r+0x58>
 8004d62:	e05b      	b.n	8004e1c <_strtol_r+0xfc>
 8004d64:	2c30      	cmp	r4, #48	; 0x30
 8004d66:	d157      	bne.n	8004e18 <_strtol_r+0xf8>
 8004d68:	7828      	ldrb	r0, [r5, #0]
 8004d6a:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 8004d6e:	2858      	cmp	r0, #88	; 0x58
 8004d70:	d14d      	bne.n	8004e0e <_strtol_r+0xee>
 8004d72:	786c      	ldrb	r4, [r5, #1]
 8004d74:	2310      	movs	r3, #16
 8004d76:	3502      	adds	r5, #2
 8004d78:	2e00      	cmp	r6, #0
 8004d7a:	bf14      	ite	ne
 8004d7c:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
 8004d80:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
 8004d84:	2700      	movs	r7, #0
 8004d86:	fbbc faf3 	udiv	sl, ip, r3
 8004d8a:	4638      	mov	r0, r7
 8004d8c:	fb03 cc1a 	mls	ip, r3, sl, ip
 8004d90:	eb09 0e04 	add.w	lr, r9, r4
 8004d94:	f89e e001 	ldrb.w	lr, [lr, #1]
 8004d98:	f01e 0f04 	tst.w	lr, #4
 8004d9c:	d001      	beq.n	8004da2 <_strtol_r+0x82>
 8004d9e:	3c30      	subs	r4, #48	; 0x30
 8004da0:	e00b      	b.n	8004dba <_strtol_r+0x9a>
 8004da2:	f01e 0e03 	ands.w	lr, lr, #3
 8004da6:	d01b      	beq.n	8004de0 <_strtol_r+0xc0>
 8004da8:	f1be 0f01 	cmp.w	lr, #1
 8004dac:	bf0c      	ite	eq
 8004dae:	f04f 0e37 	moveq.w	lr, #55	; 0x37
 8004db2:	f04f 0e57 	movne.w	lr, #87	; 0x57
 8004db6:	ebce 0404 	rsb	r4, lr, r4
 8004dba:	42a3      	cmp	r3, r4
 8004dbc:	dd10      	ble.n	8004de0 <_strtol_r+0xc0>
 8004dbe:	f1b7 3fff 	cmp.w	r7, #4294967295
 8004dc2:	d00a      	beq.n	8004dda <_strtol_r+0xba>
 8004dc4:	4550      	cmp	r0, sl
 8004dc6:	d806      	bhi.n	8004dd6 <_strtol_r+0xb6>
 8004dc8:	d101      	bne.n	8004dce <_strtol_r+0xae>
 8004dca:	4564      	cmp	r4, ip
 8004dcc:	dc03      	bgt.n	8004dd6 <_strtol_r+0xb6>
 8004dce:	fb03 4000 	mla	r0, r3, r0, r4
 8004dd2:	2701      	movs	r7, #1
 8004dd4:	e001      	b.n	8004dda <_strtol_r+0xba>
 8004dd6:	f04f 37ff 	mov.w	r7, #4294967295
 8004dda:	f815 4b01 	ldrb.w	r4, [r5], #1
 8004dde:	e7d7      	b.n	8004d90 <_strtol_r+0x70>
 8004de0:	1c7b      	adds	r3, r7, #1
 8004de2:	d10c      	bne.n	8004dfe <_strtol_r+0xde>
 8004de4:	2e00      	cmp	r6, #0
 8004de6:	f04f 0322 	mov.w	r3, #34	; 0x22
 8004dea:	bf14      	ite	ne
 8004dec:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 8004df0:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8004df4:	f8c8 3000 	str.w	r3, [r8]
 8004df8:	b92a      	cbnz	r2, 8004e06 <_strtol_r+0xe6>
 8004dfa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8004dfe:	b106      	cbz	r6, 8004e02 <_strtol_r+0xe2>
 8004e00:	4240      	negs	r0, r0
 8004e02:	b172      	cbz	r2, 8004e22 <_strtol_r+0x102>
 8004e04:	b107      	cbz	r7, 8004e08 <_strtol_r+0xe8>
 8004e06:	1e69      	subs	r1, r5, #1
 8004e08:	6011      	str	r1, [r2, #0]
 8004e0a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8004e0e:	2430      	movs	r4, #48	; 0x30
 8004e10:	2b00      	cmp	r3, #0
 8004e12:	d1b1      	bne.n	8004d78 <_strtol_r+0x58>
 8004e14:	2308      	movs	r3, #8
 8004e16:	e7af      	b.n	8004d78 <_strtol_r+0x58>
 8004e18:	230a      	movs	r3, #10
 8004e1a:	e7ad      	b.n	8004d78 <_strtol_r+0x58>
 8004e1c:	2c30      	cmp	r4, #48	; 0x30
 8004e1e:	d0a3      	beq.n	8004d68 <_strtol_r+0x48>
 8004e20:	e7aa      	b.n	8004d78 <_strtol_r+0x58>
 8004e22:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8004e26:	bf00      	nop
 8004e28:	20000110 	.word	0x20000110

08004e2c <_strtoul_r>:
 8004e2c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004e30:	4680      	mov	r8, r0
 8004e32:	483c      	ldr	r0, [pc, #240]	; (8004f24 <_strtoul_r+0xf8>)
 8004e34:	f8d0 9000 	ldr.w	r9, [r0]
 8004e38:	460e      	mov	r6, r1
 8004e3a:	4635      	mov	r5, r6
 8004e3c:	f815 4b01 	ldrb.w	r4, [r5], #1
 8004e40:	eb09 0004 	add.w	r0, r9, r4
 8004e44:	7840      	ldrb	r0, [r0, #1]
 8004e46:	f000 0008 	and.w	r0, r0, #8
 8004e4a:	f000 07ff 	and.w	r7, r0, #255	; 0xff
 8004e4e:	b108      	cbz	r0, 8004e54 <_strtoul_r+0x28>
 8004e50:	462e      	mov	r6, r5
 8004e52:	e7f2      	b.n	8004e3a <_strtoul_r+0xe>
 8004e54:	2c2d      	cmp	r4, #45	; 0x2d
 8004e56:	d103      	bne.n	8004e60 <_strtoul_r+0x34>
 8004e58:	1cb5      	adds	r5, r6, #2
 8004e5a:	7874      	ldrb	r4, [r6, #1]
 8004e5c:	2701      	movs	r7, #1
 8004e5e:	e003      	b.n	8004e68 <_strtoul_r+0x3c>
 8004e60:	2c2b      	cmp	r4, #43	; 0x2b
 8004e62:	bf04      	itt	eq
 8004e64:	7874      	ldrbeq	r4, [r6, #1]
 8004e66:	1cb5      	addeq	r5, r6, #2
 8004e68:	b113      	cbz	r3, 8004e70 <_strtoul_r+0x44>
 8004e6a:	2b10      	cmp	r3, #16
 8004e6c:	d10a      	bne.n	8004e84 <_strtoul_r+0x58>
 8004e6e:	e053      	b.n	8004f18 <_strtoul_r+0xec>
 8004e70:	2c30      	cmp	r4, #48	; 0x30
 8004e72:	d14f      	bne.n	8004f14 <_strtoul_r+0xe8>
 8004e74:	7828      	ldrb	r0, [r5, #0]
 8004e76:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 8004e7a:	2858      	cmp	r0, #88	; 0x58
 8004e7c:	d145      	bne.n	8004f0a <_strtoul_r+0xde>
 8004e7e:	786c      	ldrb	r4, [r5, #1]
 8004e80:	2310      	movs	r3, #16
 8004e82:	3502      	adds	r5, #2
 8004e84:	f04f 3cff 	mov.w	ip, #4294967295
 8004e88:	2600      	movs	r6, #0
 8004e8a:	fbbc fcf3 	udiv	ip, ip, r3
 8004e8e:	fb03 fa0c 	mul.w	sl, r3, ip
 8004e92:	ea6f 0a0a 	mvn.w	sl, sl
 8004e96:	4630      	mov	r0, r6
 8004e98:	eb09 0e04 	add.w	lr, r9, r4
 8004e9c:	f89e e001 	ldrb.w	lr, [lr, #1]
 8004ea0:	f01e 0f04 	tst.w	lr, #4
 8004ea4:	d001      	beq.n	8004eaa <_strtoul_r+0x7e>
 8004ea6:	3c30      	subs	r4, #48	; 0x30
 8004ea8:	e00b      	b.n	8004ec2 <_strtoul_r+0x96>
 8004eaa:	f01e 0e03 	ands.w	lr, lr, #3
 8004eae:	d01a      	beq.n	8004ee6 <_strtoul_r+0xba>
 8004eb0:	f1be 0f01 	cmp.w	lr, #1
 8004eb4:	bf0c      	ite	eq
 8004eb6:	f04f 0e37 	moveq.w	lr, #55	; 0x37
 8004eba:	f04f 0e57 	movne.w	lr, #87	; 0x57
 8004ebe:	ebce 0404 	rsb	r4, lr, r4
 8004ec2:	42a3      	cmp	r3, r4
 8004ec4:	dd0f      	ble.n	8004ee6 <_strtoul_r+0xba>
 8004ec6:	2e00      	cmp	r6, #0
 8004ec8:	db08      	blt.n	8004edc <_strtoul_r+0xb0>
 8004eca:	4560      	cmp	r0, ip
 8004ecc:	d806      	bhi.n	8004edc <_strtoul_r+0xb0>
 8004ece:	d101      	bne.n	8004ed4 <_strtoul_r+0xa8>
 8004ed0:	4554      	cmp	r4, sl
 8004ed2:	dc03      	bgt.n	8004edc <_strtoul_r+0xb0>
 8004ed4:	fb03 4000 	mla	r0, r3, r0, r4
 8004ed8:	2601      	movs	r6, #1
 8004eda:	e001      	b.n	8004ee0 <_strtoul_r+0xb4>
 8004edc:	f04f 36ff 	mov.w	r6, #4294967295
 8004ee0:	f815 4b01 	ldrb.w	r4, [r5], #1
 8004ee4:	e7d8      	b.n	8004e98 <_strtoul_r+0x6c>
 8004ee6:	2e00      	cmp	r6, #0
 8004ee8:	da07      	bge.n	8004efa <_strtoul_r+0xce>
 8004eea:	2322      	movs	r3, #34	; 0x22
 8004eec:	f8c8 3000 	str.w	r3, [r8]
 8004ef0:	f04f 30ff 	mov.w	r0, #4294967295
 8004ef4:	b92a      	cbnz	r2, 8004f02 <_strtoul_r+0xd6>
 8004ef6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8004efa:	b107      	cbz	r7, 8004efe <_strtoul_r+0xd2>
 8004efc:	4240      	negs	r0, r0
 8004efe:	b172      	cbz	r2, 8004f1e <_strtoul_r+0xf2>
 8004f00:	b106      	cbz	r6, 8004f04 <_strtoul_r+0xd8>
 8004f02:	1e69      	subs	r1, r5, #1
 8004f04:	6011      	str	r1, [r2, #0]
 8004f06:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8004f0a:	2430      	movs	r4, #48	; 0x30
 8004f0c:	2b00      	cmp	r3, #0
 8004f0e:	d1b9      	bne.n	8004e84 <_strtoul_r+0x58>
 8004f10:	2308      	movs	r3, #8
 8004f12:	e7b7      	b.n	8004e84 <_strtoul_r+0x58>
 8004f14:	230a      	movs	r3, #10
 8004f16:	e7b5      	b.n	8004e84 <_strtoul_r+0x58>
 8004f18:	2c30      	cmp	r4, #48	; 0x30
 8004f1a:	d0ab      	beq.n	8004e74 <_strtoul_r+0x48>
 8004f1c:	e7b2      	b.n	8004e84 <_strtoul_r+0x58>
 8004f1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8004f22:	bf00      	nop
 8004f24:	20000110 	.word	0x20000110

08004f28 <__submore>:
 8004f28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004f2c:	460c      	mov	r4, r1
 8004f2e:	6b49      	ldr	r1, [r1, #52]	; 0x34
 8004f30:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8004f34:	4299      	cmp	r1, r3
 8004f36:	d11c      	bne.n	8004f72 <__submore+0x4a>
 8004f38:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8004f3c:	f7fe ff62 	bl	8003e04 <_malloc_r>
 8004f40:	b918      	cbnz	r0, 8004f4a <__submore+0x22>
 8004f42:	f04f 30ff 	mov.w	r0, #4294967295
 8004f46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004f4a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004f4e:	63a3      	str	r3, [r4, #56]	; 0x38
 8004f50:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8004f54:	6360      	str	r0, [r4, #52]	; 0x34
 8004f56:	f880 33ff 	strb.w	r3, [r0, #1023]	; 0x3ff
 8004f5a:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8004f5e:	f880 33fe 	strb.w	r3, [r0, #1022]	; 0x3fe
 8004f62:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8004f66:	f880 33fd 	strb.w	r3, [r0, #1021]	; 0x3fd
 8004f6a:	f200 30fd 	addw	r0, r0, #1021	; 0x3fd
 8004f6e:	6020      	str	r0, [r4, #0]
 8004f70:	e012      	b.n	8004f98 <__submore+0x70>
 8004f72:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 8004f74:	0077      	lsls	r7, r6, #1
 8004f76:	463a      	mov	r2, r7
 8004f78:	f000 f8e5 	bl	8005146 <_realloc_r>
 8004f7c:	4605      	mov	r5, r0
 8004f7e:	2800      	cmp	r0, #0
 8004f80:	d0df      	beq.n	8004f42 <__submore+0x1a>
 8004f82:	eb00 0806 	add.w	r8, r0, r6
 8004f86:	4601      	mov	r1, r0
 8004f88:	4632      	mov	r2, r6
 8004f8a:	4640      	mov	r0, r8
 8004f8c:	f000 f8d0 	bl	8005130 <memcpy>
 8004f90:	f8c4 8000 	str.w	r8, [r4]
 8004f94:	6365      	str	r5, [r4, #52]	; 0x34
 8004f96:	63a7      	str	r7, [r4, #56]	; 0x38
 8004f98:	2000      	movs	r0, #0
 8004f9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08004fa0 <_ungetc_r>:
 8004fa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004fa2:	1c4d      	adds	r5, r1, #1
 8004fa4:	4606      	mov	r6, r0
 8004fa6:	460f      	mov	r7, r1
 8004fa8:	4614      	mov	r4, r2
 8004faa:	d102      	bne.n	8004fb2 <_ungetc_r+0x12>
 8004fac:	f04f 30ff 	mov.w	r0, #4294967295
 8004fb0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004fb2:	b118      	cbz	r0, 8004fbc <_ungetc_r+0x1c>
 8004fb4:	6983      	ldr	r3, [r0, #24]
 8004fb6:	b90b      	cbnz	r3, 8004fbc <_ungetc_r+0x1c>
 8004fb8:	f7ff f9d2 	bl	8004360 <__sinit>
 8004fbc:	4b2e      	ldr	r3, [pc, #184]	; (8005078 <_ungetc_r+0xd8>)
 8004fbe:	429c      	cmp	r4, r3
 8004fc0:	d101      	bne.n	8004fc6 <_ungetc_r+0x26>
 8004fc2:	6874      	ldr	r4, [r6, #4]
 8004fc4:	e008      	b.n	8004fd8 <_ungetc_r+0x38>
 8004fc6:	4b2d      	ldr	r3, [pc, #180]	; (800507c <_ungetc_r+0xdc>)
 8004fc8:	429c      	cmp	r4, r3
 8004fca:	d101      	bne.n	8004fd0 <_ungetc_r+0x30>
 8004fcc:	68b4      	ldr	r4, [r6, #8]
 8004fce:	e003      	b.n	8004fd8 <_ungetc_r+0x38>
 8004fd0:	4b2b      	ldr	r3, [pc, #172]	; (8005080 <_ungetc_r+0xe0>)
 8004fd2:	429c      	cmp	r4, r3
 8004fd4:	bf08      	it	eq
 8004fd6:	68f4      	ldreq	r4, [r6, #12]
 8004fd8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8004fdc:	f023 0320 	bic.w	r3, r3, #32
 8004fe0:	81a3      	strh	r3, [r4, #12]
 8004fe2:	b29b      	uxth	r3, r3
 8004fe4:	0759      	lsls	r1, r3, #29
 8004fe6:	d413      	bmi.n	8005010 <_ungetc_r+0x70>
 8004fe8:	06da      	lsls	r2, r3, #27
 8004fea:	d5df      	bpl.n	8004fac <_ungetc_r+0xc>
 8004fec:	071b      	lsls	r3, r3, #28
 8004fee:	d50b      	bpl.n	8005008 <_ungetc_r+0x68>
 8004ff0:	4621      	mov	r1, r4
 8004ff2:	4630      	mov	r0, r6
 8004ff4:	f7ff f938 	bl	8004268 <_fflush_r>
 8004ff8:	2800      	cmp	r0, #0
 8004ffa:	d1d7      	bne.n	8004fac <_ungetc_r+0xc>
 8004ffc:	89a3      	ldrh	r3, [r4, #12]
 8004ffe:	60a0      	str	r0, [r4, #8]
 8005000:	f023 0308 	bic.w	r3, r3, #8
 8005004:	81a3      	strh	r3, [r4, #12]
 8005006:	61a0      	str	r0, [r4, #24]
 8005008:	89a3      	ldrh	r3, [r4, #12]
 800500a:	f043 0304 	orr.w	r3, r3, #4
 800500e:	81a3      	strh	r3, [r4, #12]
 8005010:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005012:	6862      	ldr	r2, [r4, #4]
 8005014:	b2fd      	uxtb	r5, r7
 8005016:	b18b      	cbz	r3, 800503c <_ungetc_r+0x9c>
 8005018:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800501a:	429a      	cmp	r2, r3
 800501c:	da07      	bge.n	800502e <_ungetc_r+0x8e>
 800501e:	6823      	ldr	r3, [r4, #0]
 8005020:	1e5a      	subs	r2, r3, #1
 8005022:	6022      	str	r2, [r4, #0]
 8005024:	f803 7c01 	strb.w	r7, [r3, #-1]
 8005028:	6863      	ldr	r3, [r4, #4]
 800502a:	3301      	adds	r3, #1
 800502c:	e020      	b.n	8005070 <_ungetc_r+0xd0>
 800502e:	4621      	mov	r1, r4
 8005030:	4630      	mov	r0, r6
 8005032:	f7ff ff79 	bl	8004f28 <__submore>
 8005036:	2800      	cmp	r0, #0
 8005038:	d0f1      	beq.n	800501e <_ungetc_r+0x7e>
 800503a:	e7b7      	b.n	8004fac <_ungetc_r+0xc>
 800503c:	6921      	ldr	r1, [r4, #16]
 800503e:	6823      	ldr	r3, [r4, #0]
 8005040:	b151      	cbz	r1, 8005058 <_ungetc_r+0xb8>
 8005042:	4299      	cmp	r1, r3
 8005044:	d208      	bcs.n	8005058 <_ungetc_r+0xb8>
 8005046:	f813 1c01 	ldrb.w	r1, [r3, #-1]
 800504a:	428d      	cmp	r5, r1
 800504c:	d104      	bne.n	8005058 <_ungetc_r+0xb8>
 800504e:	3b01      	subs	r3, #1
 8005050:	3201      	adds	r2, #1
 8005052:	6023      	str	r3, [r4, #0]
 8005054:	6062      	str	r2, [r4, #4]
 8005056:	e00c      	b.n	8005072 <_ungetc_r+0xd2>
 8005058:	63e3      	str	r3, [r4, #60]	; 0x3c
 800505a:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800505e:	6363      	str	r3, [r4, #52]	; 0x34
 8005060:	2303      	movs	r3, #3
 8005062:	63a3      	str	r3, [r4, #56]	; 0x38
 8005064:	4623      	mov	r3, r4
 8005066:	6422      	str	r2, [r4, #64]	; 0x40
 8005068:	f803 7f46 	strb.w	r7, [r3, #70]!
 800506c:	6023      	str	r3, [r4, #0]
 800506e:	2301      	movs	r3, #1
 8005070:	6063      	str	r3, [r4, #4]
 8005072:	4628      	mov	r0, r5
 8005074:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005076:	bf00      	nop
 8005078:	08007a88 	.word	0x08007a88
 800507c:	08007aa8 	.word	0x08007aa8
 8005080:	08007ac8 	.word	0x08007ac8

08005084 <_write_r>:
 8005084:	b538      	push	{r3, r4, r5, lr}
 8005086:	4c07      	ldr	r4, [pc, #28]	; (80050a4 <_write_r+0x20>)
 8005088:	4605      	mov	r5, r0
 800508a:	4608      	mov	r0, r1
 800508c:	4611      	mov	r1, r2
 800508e:	2200      	movs	r2, #0
 8005090:	6022      	str	r2, [r4, #0]
 8005092:	461a      	mov	r2, r3
 8005094:	f7fe fda6 	bl	8003be4 <_write>
 8005098:	1c43      	adds	r3, r0, #1
 800509a:	d102      	bne.n	80050a2 <_write_r+0x1e>
 800509c:	6823      	ldr	r3, [r4, #0]
 800509e:	b103      	cbz	r3, 80050a2 <_write_r+0x1e>
 80050a0:	602b      	str	r3, [r5, #0]
 80050a2:	bd38      	pop	{r3, r4, r5, pc}
 80050a4:	200002ac 	.word	0x200002ac

080050a8 <_close_r>:
 80050a8:	b538      	push	{r3, r4, r5, lr}
 80050aa:	4c06      	ldr	r4, [pc, #24]	; (80050c4 <_close_r+0x1c>)
 80050ac:	2300      	movs	r3, #0
 80050ae:	4605      	mov	r5, r0
 80050b0:	4608      	mov	r0, r1
 80050b2:	6023      	str	r3, [r4, #0]
 80050b4:	f7fe fdb0 	bl	8003c18 <_close>
 80050b8:	1c43      	adds	r3, r0, #1
 80050ba:	d102      	bne.n	80050c2 <_close_r+0x1a>
 80050bc:	6823      	ldr	r3, [r4, #0]
 80050be:	b103      	cbz	r3, 80050c2 <_close_r+0x1a>
 80050c0:	602b      	str	r3, [r5, #0]
 80050c2:	bd38      	pop	{r3, r4, r5, pc}
 80050c4:	200002ac 	.word	0x200002ac

080050c8 <_fstat_r>:
 80050c8:	b538      	push	{r3, r4, r5, lr}
 80050ca:	4c07      	ldr	r4, [pc, #28]	; (80050e8 <_fstat_r+0x20>)
 80050cc:	2300      	movs	r3, #0
 80050ce:	4605      	mov	r5, r0
 80050d0:	4608      	mov	r0, r1
 80050d2:	4611      	mov	r1, r2
 80050d4:	6023      	str	r3, [r4, #0]
 80050d6:	f7fe fda7 	bl	8003c28 <_fstat>
 80050da:	1c43      	adds	r3, r0, #1
 80050dc:	d102      	bne.n	80050e4 <_fstat_r+0x1c>
 80050de:	6823      	ldr	r3, [r4, #0]
 80050e0:	b103      	cbz	r3, 80050e4 <_fstat_r+0x1c>
 80050e2:	602b      	str	r3, [r5, #0]
 80050e4:	bd38      	pop	{r3, r4, r5, pc}
 80050e6:	bf00      	nop
 80050e8:	200002ac 	.word	0x200002ac

080050ec <_isatty_r>:
 80050ec:	b538      	push	{r3, r4, r5, lr}
 80050ee:	4c06      	ldr	r4, [pc, #24]	; (8005108 <_isatty_r+0x1c>)
 80050f0:	2300      	movs	r3, #0
 80050f2:	4605      	mov	r5, r0
 80050f4:	4608      	mov	r0, r1
 80050f6:	6023      	str	r3, [r4, #0]
 80050f8:	f7fe fd9e 	bl	8003c38 <_isatty>
 80050fc:	1c43      	adds	r3, r0, #1
 80050fe:	d102      	bne.n	8005106 <_isatty_r+0x1a>
 8005100:	6823      	ldr	r3, [r4, #0]
 8005102:	b103      	cbz	r3, 8005106 <_isatty_r+0x1a>
 8005104:	602b      	str	r3, [r5, #0]
 8005106:	bd38      	pop	{r3, r4, r5, pc}
 8005108:	200002ac 	.word	0x200002ac

0800510c <_lseek_r>:
 800510c:	b538      	push	{r3, r4, r5, lr}
 800510e:	4c07      	ldr	r4, [pc, #28]	; (800512c <_lseek_r+0x20>)
 8005110:	4605      	mov	r5, r0
 8005112:	4608      	mov	r0, r1
 8005114:	4611      	mov	r1, r2
 8005116:	2200      	movs	r2, #0
 8005118:	6022      	str	r2, [r4, #0]
 800511a:	461a      	mov	r2, r3
 800511c:	f7fe fd94 	bl	8003c48 <_lseek>
 8005120:	1c43      	adds	r3, r0, #1
 8005122:	d102      	bne.n	800512a <_lseek_r+0x1e>
 8005124:	6823      	ldr	r3, [r4, #0]
 8005126:	b103      	cbz	r3, 800512a <_lseek_r+0x1e>
 8005128:	602b      	str	r3, [r5, #0]
 800512a:	bd38      	pop	{r3, r4, r5, pc}
 800512c:	200002ac 	.word	0x200002ac

08005130 <memcpy>:
 8005130:	b510      	push	{r4, lr}
 8005132:	1e43      	subs	r3, r0, #1
 8005134:	440a      	add	r2, r1
 8005136:	4291      	cmp	r1, r2
 8005138:	d004      	beq.n	8005144 <memcpy+0x14>
 800513a:	f811 4b01 	ldrb.w	r4, [r1], #1
 800513e:	f803 4f01 	strb.w	r4, [r3, #1]!
 8005142:	e7f8      	b.n	8005136 <memcpy+0x6>
 8005144:	bd10      	pop	{r4, pc}

08005146 <_realloc_r>:
 8005146:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005148:	4607      	mov	r7, r0
 800514a:	4615      	mov	r5, r2
 800514c:	460e      	mov	r6, r1
 800514e:	b921      	cbnz	r1, 800515a <_realloc_r+0x14>
 8005150:	4611      	mov	r1, r2
 8005152:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8005156:	f7fe be55 	b.w	8003e04 <_malloc_r>
 800515a:	b91a      	cbnz	r2, 8005164 <_realloc_r+0x1e>
 800515c:	f7fe fe04 	bl	8003d68 <_free_r>
 8005160:	4628      	mov	r0, r5
 8005162:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005164:	f000 f828 	bl	80051b8 <_malloc_usable_size_r>
 8005168:	4285      	cmp	r5, r0
 800516a:	d90e      	bls.n	800518a <_realloc_r+0x44>
 800516c:	4629      	mov	r1, r5
 800516e:	4638      	mov	r0, r7
 8005170:	f7fe fe48 	bl	8003e04 <_malloc_r>
 8005174:	4604      	mov	r4, r0
 8005176:	b150      	cbz	r0, 800518e <_realloc_r+0x48>
 8005178:	4631      	mov	r1, r6
 800517a:	462a      	mov	r2, r5
 800517c:	f7ff ffd8 	bl	8005130 <memcpy>
 8005180:	4631      	mov	r1, r6
 8005182:	4638      	mov	r0, r7
 8005184:	f7fe fdf0 	bl	8003d68 <_free_r>
 8005188:	e001      	b.n	800518e <_realloc_r+0x48>
 800518a:	4630      	mov	r0, r6
 800518c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800518e:	4620      	mov	r0, r4
 8005190:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08005194 <_read_r>:
 8005194:	b538      	push	{r3, r4, r5, lr}
 8005196:	4c07      	ldr	r4, [pc, #28]	; (80051b4 <_read_r+0x20>)
 8005198:	4605      	mov	r5, r0
 800519a:	4608      	mov	r0, r1
 800519c:	4611      	mov	r1, r2
 800519e:	2200      	movs	r2, #0
 80051a0:	6022      	str	r2, [r4, #0]
 80051a2:	461a      	mov	r2, r3
 80051a4:	f7fe fd58 	bl	8003c58 <_read>
 80051a8:	1c43      	adds	r3, r0, #1
 80051aa:	d102      	bne.n	80051b2 <_read_r+0x1e>
 80051ac:	6823      	ldr	r3, [r4, #0]
 80051ae:	b103      	cbz	r3, 80051b2 <_read_r+0x1e>
 80051b0:	602b      	str	r3, [r5, #0]
 80051b2:	bd38      	pop	{r3, r4, r5, pc}
 80051b4:	200002ac 	.word	0x200002ac

080051b8 <_malloc_usable_size_r>:
 80051b8:	f851 0c04 	ldr.w	r0, [r1, #-4]
 80051bc:	2800      	cmp	r0, #0
 80051be:	bfbe      	ittt	lt
 80051c0:	1809      	addlt	r1, r1, r0
 80051c2:	f851 3c04 	ldrlt.w	r3, [r1, #-4]
 80051c6:	18c0      	addlt	r0, r0, r3
 80051c8:	3804      	subs	r0, #4
 80051ca:	4770      	bx	lr
 80051cc:	0000      	movs	r0, r0
	...

080051d0 <cos>:
 80051d0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80051d2:	ec51 0b10 	vmov	r0, r1, d0
 80051d6:	4a1e      	ldr	r2, [pc, #120]	; (8005250 <cos+0x80>)
 80051d8:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 80051dc:	4293      	cmp	r3, r2
 80051de:	dc02      	bgt.n	80051e6 <cos+0x16>
 80051e0:	ed9f 1b19 	vldr	d1, [pc, #100]	; 8005248 <cos+0x78>
 80051e4:	e016      	b.n	8005214 <cos+0x44>
 80051e6:	4a1b      	ldr	r2, [pc, #108]	; (8005254 <cos+0x84>)
 80051e8:	4293      	cmp	r3, r2
 80051ea:	dd05      	ble.n	80051f8 <cos+0x28>
 80051ec:	ee10 2a10 	vmov	r2, s0
 80051f0:	460b      	mov	r3, r1
 80051f2:	f7fb f849 	bl	8000288 <__aeabi_dsub>
 80051f6:	e021      	b.n	800523c <cos+0x6c>
 80051f8:	4668      	mov	r0, sp
 80051fa:	f000 f875 	bl	80052e8 <__ieee754_rem_pio2>
 80051fe:	f000 0003 	and.w	r0, r0, #3
 8005202:	2801      	cmp	r0, #1
 8005204:	ed9d 1b02 	vldr	d1, [sp, #8]
 8005208:	ed9d 0b00 	vldr	d0, [sp]
 800520c:	d005      	beq.n	800521a <cos+0x4a>
 800520e:	2802      	cmp	r0, #2
 8005210:	d006      	beq.n	8005220 <cos+0x50>
 8005212:	b970      	cbnz	r0, 8005232 <cos+0x62>
 8005214:	f000 fa68 	bl	80056e8 <__kernel_cos>
 8005218:	e00e      	b.n	8005238 <cos+0x68>
 800521a:	f000 fe9d 	bl	8005f58 <__kernel_sin>
 800521e:	e001      	b.n	8005224 <cos+0x54>
 8005220:	f000 fa62 	bl	80056e8 <__kernel_cos>
 8005224:	ec53 2b10 	vmov	r2, r3, d0
 8005228:	ee10 0a10 	vmov	r0, s0
 800522c:	f103 4100 	add.w	r1, r3, #2147483648	; 0x80000000
 8005230:	e004      	b.n	800523c <cos+0x6c>
 8005232:	2001      	movs	r0, #1
 8005234:	f000 fe90 	bl	8005f58 <__kernel_sin>
 8005238:	ec51 0b10 	vmov	r0, r1, d0
 800523c:	ec41 0b10 	vmov	d0, r0, r1
 8005240:	b005      	add	sp, #20
 8005242:	f85d fb04 	ldr.w	pc, [sp], #4
 8005246:	bf00      	nop
	...
 8005250:	3fe921fb 	.word	0x3fe921fb
 8005254:	7fefffff 	.word	0x7fefffff

08005258 <sin>:
 8005258:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800525a:	ec51 0b10 	vmov	r0, r1, d0
 800525e:	4a20      	ldr	r2, [pc, #128]	; (80052e0 <sin+0x88>)
 8005260:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 8005264:	4293      	cmp	r3, r2
 8005266:	dc03      	bgt.n	8005270 <sin+0x18>
 8005268:	2000      	movs	r0, #0
 800526a:	ed9f 1b1b 	vldr	d1, [pc, #108]	; 80052d8 <sin+0x80>
 800526e:	e017      	b.n	80052a0 <sin+0x48>
 8005270:	4a1c      	ldr	r2, [pc, #112]	; (80052e4 <sin+0x8c>)
 8005272:	4293      	cmp	r3, r2
 8005274:	dd05      	ble.n	8005282 <sin+0x2a>
 8005276:	ee10 2a10 	vmov	r2, s0
 800527a:	460b      	mov	r3, r1
 800527c:	f7fb f804 	bl	8000288 <__aeabi_dsub>
 8005280:	e022      	b.n	80052c8 <sin+0x70>
 8005282:	4668      	mov	r0, sp
 8005284:	f000 f830 	bl	80052e8 <__ieee754_rem_pio2>
 8005288:	f000 0003 	and.w	r0, r0, #3
 800528c:	2801      	cmp	r0, #1
 800528e:	ed9d 1b02 	vldr	d1, [sp, #8]
 8005292:	ed9d 0b00 	vldr	d0, [sp]
 8005296:	d008      	beq.n	80052aa <sin+0x52>
 8005298:	2802      	cmp	r0, #2
 800529a:	d009      	beq.n	80052b0 <sin+0x58>
 800529c:	b960      	cbnz	r0, 80052b8 <sin+0x60>
 800529e:	2001      	movs	r0, #1
 80052a0:	f000 fe5a 	bl	8005f58 <__kernel_sin>
 80052a4:	ec51 0b10 	vmov	r0, r1, d0
 80052a8:	e00e      	b.n	80052c8 <sin+0x70>
 80052aa:	f000 fa1d 	bl	80056e8 <__kernel_cos>
 80052ae:	e7f9      	b.n	80052a4 <sin+0x4c>
 80052b0:	2001      	movs	r0, #1
 80052b2:	f000 fe51 	bl	8005f58 <__kernel_sin>
 80052b6:	e001      	b.n	80052bc <sin+0x64>
 80052b8:	f000 fa16 	bl	80056e8 <__kernel_cos>
 80052bc:	ec53 2b10 	vmov	r2, r3, d0
 80052c0:	ee10 0a10 	vmov	r0, s0
 80052c4:	f103 4100 	add.w	r1, r3, #2147483648	; 0x80000000
 80052c8:	ec41 0b10 	vmov	d0, r0, r1
 80052cc:	b005      	add	sp, #20
 80052ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80052d2:	bf00      	nop
 80052d4:	f3af 8000 	nop.w
	...
 80052e0:	3fe921fb 	.word	0x3fe921fb
 80052e4:	7fefffff 	.word	0x7fefffff

080052e8 <__ieee754_rem_pio2>:
 80052e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80052ec:	ec55 4b10 	vmov	r4, r5, d0
 80052f0:	4bc7      	ldr	r3, [pc, #796]	; (8005610 <__ieee754_rem_pio2+0x328>)
 80052f2:	f025 4800 	bic.w	r8, r5, #2147483648	; 0x80000000
 80052f6:	4598      	cmp	r8, r3
 80052f8:	b08d      	sub	sp, #52	; 0x34
 80052fa:	4682      	mov	sl, r0
 80052fc:	46ab      	mov	fp, r5
 80052fe:	dc06      	bgt.n	800530e <__ieee754_rem_pio2+0x26>
 8005300:	2200      	movs	r2, #0
 8005302:	2300      	movs	r3, #0
 8005304:	ed8a 0b00 	vstr	d0, [sl]
 8005308:	e9c0 2302 	strd	r2, r3, [r0, #8]
 800530c:	e160      	b.n	80055d0 <__ieee754_rem_pio2+0x2e8>
 800530e:	4bc1      	ldr	r3, [pc, #772]	; (8005614 <__ieee754_rem_pio2+0x32c>)
 8005310:	4598      	cmp	r8, r3
 8005312:	dc71      	bgt.n	80053f8 <__ieee754_rem_pio2+0x110>
 8005314:	2d00      	cmp	r5, #0
 8005316:	a3b0      	add	r3, pc, #704	; (adr r3, 80055d8 <__ieee754_rem_pio2+0x2f0>)
 8005318:	e9d3 2300 	ldrd	r2, r3, [r3]
 800531c:	ee10 0a10 	vmov	r0, s0
 8005320:	4629      	mov	r1, r5
 8005322:	4ebd      	ldr	r6, [pc, #756]	; (8005618 <__ieee754_rem_pio2+0x330>)
 8005324:	dd33      	ble.n	800538e <__ieee754_rem_pio2+0xa6>
 8005326:	f7fa ffaf 	bl	8000288 <__aeabi_dsub>
 800532a:	45b0      	cmp	r8, r6
 800532c:	4604      	mov	r4, r0
 800532e:	460d      	mov	r5, r1
 8005330:	d010      	beq.n	8005354 <__ieee754_rem_pio2+0x6c>
 8005332:	a3ab      	add	r3, pc, #684	; (adr r3, 80055e0 <__ieee754_rem_pio2+0x2f8>)
 8005334:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005338:	f7fa ffa6 	bl	8000288 <__aeabi_dsub>
 800533c:	4602      	mov	r2, r0
 800533e:	460b      	mov	r3, r1
 8005340:	e9ca 2300 	strd	r2, r3, [sl]
 8005344:	4620      	mov	r0, r4
 8005346:	4629      	mov	r1, r5
 8005348:	f7fa ff9e 	bl	8000288 <__aeabi_dsub>
 800534c:	a3a4      	add	r3, pc, #656	; (adr r3, 80055e0 <__ieee754_rem_pio2+0x2f8>)
 800534e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005352:	e016      	b.n	8005382 <__ieee754_rem_pio2+0x9a>
 8005354:	a3a4      	add	r3, pc, #656	; (adr r3, 80055e8 <__ieee754_rem_pio2+0x300>)
 8005356:	e9d3 2300 	ldrd	r2, r3, [r3]
 800535a:	f7fa ff95 	bl	8000288 <__aeabi_dsub>
 800535e:	a3a4      	add	r3, pc, #656	; (adr r3, 80055f0 <__ieee754_rem_pio2+0x308>)
 8005360:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005364:	4604      	mov	r4, r0
 8005366:	460d      	mov	r5, r1
 8005368:	f7fa ff8e 	bl	8000288 <__aeabi_dsub>
 800536c:	4602      	mov	r2, r0
 800536e:	460b      	mov	r3, r1
 8005370:	e9ca 2300 	strd	r2, r3, [sl]
 8005374:	4620      	mov	r0, r4
 8005376:	4629      	mov	r1, r5
 8005378:	f7fa ff86 	bl	8000288 <__aeabi_dsub>
 800537c:	a39c      	add	r3, pc, #624	; (adr r3, 80055f0 <__ieee754_rem_pio2+0x308>)
 800537e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005382:	f7fa ff81 	bl	8000288 <__aeabi_dsub>
 8005386:	e9ca 0102 	strd	r0, r1, [sl, #8]
 800538a:	2001      	movs	r0, #1
 800538c:	e1a2      	b.n	80056d4 <__ieee754_rem_pio2+0x3ec>
 800538e:	f7fa ff7d 	bl	800028c <__adddf3>
 8005392:	45b0      	cmp	r8, r6
 8005394:	4604      	mov	r4, r0
 8005396:	460d      	mov	r5, r1
 8005398:	d010      	beq.n	80053bc <__ieee754_rem_pio2+0xd4>
 800539a:	a391      	add	r3, pc, #580	; (adr r3, 80055e0 <__ieee754_rem_pio2+0x2f8>)
 800539c:	e9d3 2300 	ldrd	r2, r3, [r3]
 80053a0:	f7fa ff74 	bl	800028c <__adddf3>
 80053a4:	4602      	mov	r2, r0
 80053a6:	460b      	mov	r3, r1
 80053a8:	e9ca 2300 	strd	r2, r3, [sl]
 80053ac:	4620      	mov	r0, r4
 80053ae:	4629      	mov	r1, r5
 80053b0:	f7fa ff6a 	bl	8000288 <__aeabi_dsub>
 80053b4:	a38a      	add	r3, pc, #552	; (adr r3, 80055e0 <__ieee754_rem_pio2+0x2f8>)
 80053b6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80053ba:	e016      	b.n	80053ea <__ieee754_rem_pio2+0x102>
 80053bc:	a38a      	add	r3, pc, #552	; (adr r3, 80055e8 <__ieee754_rem_pio2+0x300>)
 80053be:	e9d3 2300 	ldrd	r2, r3, [r3]
 80053c2:	f7fa ff63 	bl	800028c <__adddf3>
 80053c6:	a38a      	add	r3, pc, #552	; (adr r3, 80055f0 <__ieee754_rem_pio2+0x308>)
 80053c8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80053cc:	4604      	mov	r4, r0
 80053ce:	460d      	mov	r5, r1
 80053d0:	f7fa ff5c 	bl	800028c <__adddf3>
 80053d4:	4602      	mov	r2, r0
 80053d6:	460b      	mov	r3, r1
 80053d8:	e9ca 2300 	strd	r2, r3, [sl]
 80053dc:	4620      	mov	r0, r4
 80053de:	4629      	mov	r1, r5
 80053e0:	f7fa ff52 	bl	8000288 <__aeabi_dsub>
 80053e4:	a382      	add	r3, pc, #520	; (adr r3, 80055f0 <__ieee754_rem_pio2+0x308>)
 80053e6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80053ea:	f7fa ff4f 	bl	800028c <__adddf3>
 80053ee:	e9ca 0102 	strd	r0, r1, [sl, #8]
 80053f2:	f04f 30ff 	mov.w	r0, #4294967295
 80053f6:	e16d      	b.n	80056d4 <__ieee754_rem_pio2+0x3ec>
 80053f8:	4b88      	ldr	r3, [pc, #544]	; (800561c <__ieee754_rem_pio2+0x334>)
 80053fa:	4598      	cmp	r8, r3
 80053fc:	f300 80da 	bgt.w	80055b4 <__ieee754_rem_pio2+0x2cc>
 8005400:	f000 fe64 	bl	80060cc <fabs>
 8005404:	ec55 4b10 	vmov	r4, r5, d0
 8005408:	ee10 0a10 	vmov	r0, s0
 800540c:	a37a      	add	r3, pc, #488	; (adr r3, 80055f8 <__ieee754_rem_pio2+0x310>)
 800540e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005412:	4629      	mov	r1, r5
 8005414:	f7fb f8ec 	bl	80005f0 <__aeabi_dmul>
 8005418:	2200      	movs	r2, #0
 800541a:	4b81      	ldr	r3, [pc, #516]	; (8005620 <__ieee754_rem_pio2+0x338>)
 800541c:	f7fa ff36 	bl	800028c <__adddf3>
 8005420:	f7fb fb80 	bl	8000b24 <__aeabi_d2iz>
 8005424:	4681      	mov	r9, r0
 8005426:	f7fb f87d 	bl	8000524 <__aeabi_i2d>
 800542a:	a36b      	add	r3, pc, #428	; (adr r3, 80055d8 <__ieee754_rem_pio2+0x2f0>)
 800542c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005430:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8005434:	f7fb f8dc 	bl	80005f0 <__aeabi_dmul>
 8005438:	4602      	mov	r2, r0
 800543a:	460b      	mov	r3, r1
 800543c:	4620      	mov	r0, r4
 800543e:	4629      	mov	r1, r5
 8005440:	f7fa ff22 	bl	8000288 <__aeabi_dsub>
 8005444:	a366      	add	r3, pc, #408	; (adr r3, 80055e0 <__ieee754_rem_pio2+0x2f8>)
 8005446:	e9d3 2300 	ldrd	r2, r3, [r3]
 800544a:	4604      	mov	r4, r0
 800544c:	460d      	mov	r5, r1
 800544e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005452:	f7fb f8cd 	bl	80005f0 <__aeabi_dmul>
 8005456:	f1b9 0f1f 	cmp.w	r9, #31
 800545a:	4606      	mov	r6, r0
 800545c:	460f      	mov	r7, r1
 800545e:	dc06      	bgt.n	800546e <__ieee754_rem_pio2+0x186>
 8005460:	f109 32ff 	add.w	r2, r9, #4294967295
 8005464:	4b6f      	ldr	r3, [pc, #444]	; (8005624 <__ieee754_rem_pio2+0x33c>)
 8005466:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800546a:	4598      	cmp	r8, r3
 800546c:	d172      	bne.n	8005554 <__ieee754_rem_pio2+0x26c>
 800546e:	463b      	mov	r3, r7
 8005470:	4632      	mov	r2, r6
 8005472:	4620      	mov	r0, r4
 8005474:	4629      	mov	r1, r5
 8005476:	f7fa ff07 	bl	8000288 <__aeabi_dsub>
 800547a:	ea4f 5828 	mov.w	r8, r8, asr #20
 800547e:	f3c1 530a 	ubfx	r3, r1, #20, #11
 8005482:	ebc3 0308 	rsb	r3, r3, r8
 8005486:	2b10      	cmp	r3, #16
 8005488:	e9ca 0100 	strd	r0, r1, [sl]
 800548c:	dd6d      	ble.n	800556a <__ieee754_rem_pio2+0x282>
 800548e:	a356      	add	r3, pc, #344	; (adr r3, 80055e8 <__ieee754_rem_pio2+0x300>)
 8005490:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005494:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005498:	f7fb f8aa 	bl	80005f0 <__aeabi_dmul>
 800549c:	4606      	mov	r6, r0
 800549e:	460f      	mov	r7, r1
 80054a0:	4602      	mov	r2, r0
 80054a2:	460b      	mov	r3, r1
 80054a4:	4620      	mov	r0, r4
 80054a6:	4629      	mov	r1, r5
 80054a8:	f7fa feee 	bl	8000288 <__aeabi_dsub>
 80054ac:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80054b0:	4602      	mov	r2, r0
 80054b2:	460b      	mov	r3, r1
 80054b4:	4620      	mov	r0, r4
 80054b6:	4629      	mov	r1, r5
 80054b8:	f7fa fee6 	bl	8000288 <__aeabi_dsub>
 80054bc:	4632      	mov	r2, r6
 80054be:	463b      	mov	r3, r7
 80054c0:	f7fa fee2 	bl	8000288 <__aeabi_dsub>
 80054c4:	a34a      	add	r3, pc, #296	; (adr r3, 80055f0 <__ieee754_rem_pio2+0x308>)
 80054c6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80054ca:	4604      	mov	r4, r0
 80054cc:	460d      	mov	r5, r1
 80054ce:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80054d2:	f7fb f88d 	bl	80005f0 <__aeabi_dmul>
 80054d6:	4622      	mov	r2, r4
 80054d8:	462b      	mov	r3, r5
 80054da:	f7fa fed5 	bl	8000288 <__aeabi_dsub>
 80054de:	460b      	mov	r3, r1
 80054e0:	4602      	mov	r2, r0
 80054e2:	4606      	mov	r6, r0
 80054e4:	460f      	mov	r7, r1
 80054e6:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 80054ea:	f7fa fecd 	bl	8000288 <__aeabi_dsub>
 80054ee:	f3c1 530a 	ubfx	r3, r1, #20, #11
 80054f2:	ebc3 0808 	rsb	r8, r3, r8
 80054f6:	f1b8 0f31 	cmp.w	r8, #49	; 0x31
 80054fa:	e9ca 0100 	strd	r0, r1, [sl]
 80054fe:	dd32      	ble.n	8005566 <__ieee754_rem_pio2+0x27e>
 8005500:	a33f      	add	r3, pc, #252	; (adr r3, 8005600 <__ieee754_rem_pio2+0x318>)
 8005502:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005506:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800550a:	f7fb f871 	bl	80005f0 <__aeabi_dmul>
 800550e:	4606      	mov	r6, r0
 8005510:	460f      	mov	r7, r1
 8005512:	4602      	mov	r2, r0
 8005514:	460b      	mov	r3, r1
 8005516:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 800551a:	f7fa feb5 	bl	8000288 <__aeabi_dsub>
 800551e:	4602      	mov	r2, r0
 8005520:	460b      	mov	r3, r1
 8005522:	4604      	mov	r4, r0
 8005524:	460d      	mov	r5, r1
 8005526:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 800552a:	f7fa fead 	bl	8000288 <__aeabi_dsub>
 800552e:	4632      	mov	r2, r6
 8005530:	463b      	mov	r3, r7
 8005532:	f7fa fea9 	bl	8000288 <__aeabi_dsub>
 8005536:	a334      	add	r3, pc, #208	; (adr r3, 8005608 <__ieee754_rem_pio2+0x320>)
 8005538:	e9d3 2300 	ldrd	r2, r3, [r3]
 800553c:	4606      	mov	r6, r0
 800553e:	460f      	mov	r7, r1
 8005540:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005544:	f7fb f854 	bl	80005f0 <__aeabi_dmul>
 8005548:	4632      	mov	r2, r6
 800554a:	463b      	mov	r3, r7
 800554c:	f7fa fe9c 	bl	8000288 <__aeabi_dsub>
 8005550:	4606      	mov	r6, r0
 8005552:	460f      	mov	r7, r1
 8005554:	4632      	mov	r2, r6
 8005556:	463b      	mov	r3, r7
 8005558:	4620      	mov	r0, r4
 800555a:	4629      	mov	r1, r5
 800555c:	f7fa fe94 	bl	8000288 <__aeabi_dsub>
 8005560:	e9ca 0100 	strd	r0, r1, [sl]
 8005564:	e001      	b.n	800556a <__ieee754_rem_pio2+0x282>
 8005566:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
 800556a:	ed9a 7b00 	vldr	d7, [sl]
 800556e:	4620      	mov	r0, r4
 8005570:	ec53 2b17 	vmov	r2, r3, d7
 8005574:	4629      	mov	r1, r5
 8005576:	ed8d 7b02 	vstr	d7, [sp, #8]
 800557a:	f7fa fe85 	bl	8000288 <__aeabi_dsub>
 800557e:	4632      	mov	r2, r6
 8005580:	463b      	mov	r3, r7
 8005582:	f7fa fe81 	bl	8000288 <__aeabi_dsub>
 8005586:	f1bb 0f00 	cmp.w	fp, #0
 800558a:	e9ca 0102 	strd	r0, r1, [sl, #8]
 800558e:	f280 80a0 	bge.w	80056d2 <__ieee754_rem_pio2+0x3ea>
 8005592:	9b02      	ldr	r3, [sp, #8]
 8005594:	f8ca 3000 	str.w	r3, [sl]
 8005598:	9b03      	ldr	r3, [sp, #12]
 800559a:	f8ca 0008 	str.w	r0, [sl, #8]
 800559e:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 80055a2:	f8ca 3004 	str.w	r3, [sl, #4]
 80055a6:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 80055aa:	f8ca 300c 	str.w	r3, [sl, #12]
 80055ae:	f1c9 0000 	rsb	r0, r9, #0
 80055b2:	e08f      	b.n	80056d4 <__ieee754_rem_pio2+0x3ec>
 80055b4:	4b1c      	ldr	r3, [pc, #112]	; (8005628 <__ieee754_rem_pio2+0x340>)
 80055b6:	4598      	cmp	r8, r3
 80055b8:	dd38      	ble.n	800562c <__ieee754_rem_pio2+0x344>
 80055ba:	ee10 2a10 	vmov	r2, s0
 80055be:	462b      	mov	r3, r5
 80055c0:	4620      	mov	r0, r4
 80055c2:	4629      	mov	r1, r5
 80055c4:	f7fa fe60 	bl	8000288 <__aeabi_dsub>
 80055c8:	e9ca 0102 	strd	r0, r1, [sl, #8]
 80055cc:	e9ca 0100 	strd	r0, r1, [sl]
 80055d0:	2000      	movs	r0, #0
 80055d2:	e07f      	b.n	80056d4 <__ieee754_rem_pio2+0x3ec>
 80055d4:	f3af 8000 	nop.w
 80055d8:	54400000 	.word	0x54400000
 80055dc:	3ff921fb 	.word	0x3ff921fb
 80055e0:	1a626331 	.word	0x1a626331
 80055e4:	3dd0b461 	.word	0x3dd0b461
 80055e8:	1a600000 	.word	0x1a600000
 80055ec:	3dd0b461 	.word	0x3dd0b461
 80055f0:	2e037073 	.word	0x2e037073
 80055f4:	3ba3198a 	.word	0x3ba3198a
 80055f8:	6dc9c883 	.word	0x6dc9c883
 80055fc:	3fe45f30 	.word	0x3fe45f30
 8005600:	2e000000 	.word	0x2e000000
 8005604:	3ba3198a 	.word	0x3ba3198a
 8005608:	252049c1 	.word	0x252049c1
 800560c:	397b839a 	.word	0x397b839a
 8005610:	3fe921fb 	.word	0x3fe921fb
 8005614:	4002d97b 	.word	0x4002d97b
 8005618:	3ff921fb 	.word	0x3ff921fb
 800561c:	413921fb 	.word	0x413921fb
 8005620:	3fe00000 	.word	0x3fe00000
 8005624:	08007c10 	.word	0x08007c10
 8005628:	7fefffff 	.word	0x7fefffff
 800562c:	ea4f 5628 	mov.w	r6, r8, asr #20
 8005630:	f2a6 4616 	subw	r6, r6, #1046	; 0x416
 8005634:	eba8 5106 	sub.w	r1, r8, r6, lsl #20
 8005638:	4620      	mov	r0, r4
 800563a:	460d      	mov	r5, r1
 800563c:	f7fb fa72 	bl	8000b24 <__aeabi_d2iz>
 8005640:	f7fa ff70 	bl	8000524 <__aeabi_i2d>
 8005644:	4602      	mov	r2, r0
 8005646:	460b      	mov	r3, r1
 8005648:	4620      	mov	r0, r4
 800564a:	4629      	mov	r1, r5
 800564c:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8005650:	f7fa fe1a 	bl	8000288 <__aeabi_dsub>
 8005654:	2200      	movs	r2, #0
 8005656:	4b21      	ldr	r3, [pc, #132]	; (80056dc <__ieee754_rem_pio2+0x3f4>)
 8005658:	f7fa ffca 	bl	80005f0 <__aeabi_dmul>
 800565c:	460d      	mov	r5, r1
 800565e:	4604      	mov	r4, r0
 8005660:	f7fb fa60 	bl	8000b24 <__aeabi_d2iz>
 8005664:	f7fa ff5e 	bl	8000524 <__aeabi_i2d>
 8005668:	4602      	mov	r2, r0
 800566a:	460b      	mov	r3, r1
 800566c:	4620      	mov	r0, r4
 800566e:	4629      	mov	r1, r5
 8005670:	e9cd 2308 	strd	r2, r3, [sp, #32]
 8005674:	f7fa fe08 	bl	8000288 <__aeabi_dsub>
 8005678:	2200      	movs	r2, #0
 800567a:	4b18      	ldr	r3, [pc, #96]	; (80056dc <__ieee754_rem_pio2+0x3f4>)
 800567c:	f7fa ffb8 	bl	80005f0 <__aeabi_dmul>
 8005680:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
 8005684:	ad0c      	add	r5, sp, #48	; 0x30
 8005686:	2403      	movs	r4, #3
 8005688:	2200      	movs	r2, #0
 800568a:	2300      	movs	r3, #0
 800568c:	e975 0102 	ldrd	r0, r1, [r5, #-8]!
 8005690:	1e67      	subs	r7, r4, #1
 8005692:	f7fb fa15 	bl	8000ac0 <__aeabi_dcmpeq>
 8005696:	b108      	cbz	r0, 800569c <__ieee754_rem_pio2+0x3b4>
 8005698:	463c      	mov	r4, r7
 800569a:	e7f5      	b.n	8005688 <__ieee754_rem_pio2+0x3a0>
 800569c:	4b10      	ldr	r3, [pc, #64]	; (80056e0 <__ieee754_rem_pio2+0x3f8>)
 800569e:	9301      	str	r3, [sp, #4]
 80056a0:	2302      	movs	r3, #2
 80056a2:	9300      	str	r3, [sp, #0]
 80056a4:	4632      	mov	r2, r6
 80056a6:	4623      	mov	r3, r4
 80056a8:	4651      	mov	r1, sl
 80056aa:	a806      	add	r0, sp, #24
 80056ac:	f000 f904 	bl	80058b8 <__kernel_rem_pio2>
 80056b0:	f1bb 0f00 	cmp.w	fp, #0
 80056b4:	da0e      	bge.n	80056d4 <__ieee754_rem_pio2+0x3ec>
 80056b6:	f8da 3004 	ldr.w	r3, [sl, #4]
 80056ba:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 80056be:	f8ca 3004 	str.w	r3, [sl, #4]
 80056c2:	f8da 300c 	ldr.w	r3, [sl, #12]
 80056c6:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 80056ca:	f8ca 300c 	str.w	r3, [sl, #12]
 80056ce:	4240      	negs	r0, r0
 80056d0:	e000      	b.n	80056d4 <__ieee754_rem_pio2+0x3ec>
 80056d2:	4648      	mov	r0, r9
 80056d4:	b00d      	add	sp, #52	; 0x34
 80056d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80056da:	bf00      	nop
 80056dc:	41700000 	.word	0x41700000
 80056e0:	08007c90 	.word	0x08007c90
 80056e4:	00000000 	.word	0x00000000

080056e8 <__kernel_cos>:
 80056e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80056ec:	ec59 8b10 	vmov	r8, r9, d0
 80056f0:	f029 4700 	bic.w	r7, r9, #2147483648	; 0x80000000
 80056f4:	b085      	sub	sp, #20
 80056f6:	f1b7 5f79 	cmp.w	r7, #1044381696	; 0x3e400000
 80056fa:	ed8d 1b00 	vstr	d1, [sp]
 80056fe:	da07      	bge.n	8005710 <__kernel_cos+0x28>
 8005700:	ee10 0a10 	vmov	r0, s0
 8005704:	4649      	mov	r1, r9
 8005706:	f7fb fa0d 	bl	8000b24 <__aeabi_d2iz>
 800570a:	2800      	cmp	r0, #0
 800570c:	f000 80a6 	beq.w	800585c <__kernel_cos+0x174>
 8005710:	4642      	mov	r2, r8
 8005712:	464b      	mov	r3, r9
 8005714:	4640      	mov	r0, r8
 8005716:	4649      	mov	r1, r9
 8005718:	f7fa ff6a 	bl	80005f0 <__aeabi_dmul>
 800571c:	a359      	add	r3, pc, #356	; (adr r3, 8005884 <__kernel_cos+0x19c>)
 800571e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005722:	4604      	mov	r4, r0
 8005724:	460d      	mov	r5, r1
 8005726:	f7fa ff63 	bl	80005f0 <__aeabi_dmul>
 800572a:	a358      	add	r3, pc, #352	; (adr r3, 800588c <__kernel_cos+0x1a4>)
 800572c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005730:	f7fa fdac 	bl	800028c <__adddf3>
 8005734:	4622      	mov	r2, r4
 8005736:	462b      	mov	r3, r5
 8005738:	f7fa ff5a 	bl	80005f0 <__aeabi_dmul>
 800573c:	a355      	add	r3, pc, #340	; (adr r3, 8005894 <__kernel_cos+0x1ac>)
 800573e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005742:	f7fa fda1 	bl	8000288 <__aeabi_dsub>
 8005746:	4622      	mov	r2, r4
 8005748:	462b      	mov	r3, r5
 800574a:	f7fa ff51 	bl	80005f0 <__aeabi_dmul>
 800574e:	a353      	add	r3, pc, #332	; (adr r3, 800589c <__kernel_cos+0x1b4>)
 8005750:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005754:	f7fa fd9a 	bl	800028c <__adddf3>
 8005758:	4622      	mov	r2, r4
 800575a:	462b      	mov	r3, r5
 800575c:	f7fa ff48 	bl	80005f0 <__aeabi_dmul>
 8005760:	a350      	add	r3, pc, #320	; (adr r3, 80058a4 <__kernel_cos+0x1bc>)
 8005762:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005766:	f7fa fd8f 	bl	8000288 <__aeabi_dsub>
 800576a:	4622      	mov	r2, r4
 800576c:	462b      	mov	r3, r5
 800576e:	f7fa ff3f 	bl	80005f0 <__aeabi_dmul>
 8005772:	a34e      	add	r3, pc, #312	; (adr r3, 80058ac <__kernel_cos+0x1c4>)
 8005774:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005778:	f7fa fd88 	bl	800028c <__adddf3>
 800577c:	462b      	mov	r3, r5
 800577e:	4622      	mov	r2, r4
 8005780:	f7fa ff36 	bl	80005f0 <__aeabi_dmul>
 8005784:	4b3a      	ldr	r3, [pc, #232]	; (8005870 <__kernel_cos+0x188>)
 8005786:	429f      	cmp	r7, r3
 8005788:	4682      	mov	sl, r0
 800578a:	468b      	mov	fp, r1
 800578c:	dc26      	bgt.n	80057dc <__kernel_cos+0xf4>
 800578e:	2200      	movs	r2, #0
 8005790:	4b38      	ldr	r3, [pc, #224]	; (8005874 <__kernel_cos+0x18c>)
 8005792:	4620      	mov	r0, r4
 8005794:	4629      	mov	r1, r5
 8005796:	f7fa ff2b 	bl	80005f0 <__aeabi_dmul>
 800579a:	4652      	mov	r2, sl
 800579c:	4606      	mov	r6, r0
 800579e:	460f      	mov	r7, r1
 80057a0:	465b      	mov	r3, fp
 80057a2:	4620      	mov	r0, r4
 80057a4:	4629      	mov	r1, r5
 80057a6:	f7fa ff23 	bl	80005f0 <__aeabi_dmul>
 80057aa:	e9dd 2300 	ldrd	r2, r3, [sp]
 80057ae:	4604      	mov	r4, r0
 80057b0:	460d      	mov	r5, r1
 80057b2:	4640      	mov	r0, r8
 80057b4:	4649      	mov	r1, r9
 80057b6:	f7fa ff1b 	bl	80005f0 <__aeabi_dmul>
 80057ba:	4602      	mov	r2, r0
 80057bc:	460b      	mov	r3, r1
 80057be:	4620      	mov	r0, r4
 80057c0:	4629      	mov	r1, r5
 80057c2:	f7fa fd61 	bl	8000288 <__aeabi_dsub>
 80057c6:	4602      	mov	r2, r0
 80057c8:	460b      	mov	r3, r1
 80057ca:	4630      	mov	r0, r6
 80057cc:	4639      	mov	r1, r7
 80057ce:	f7fa fd5b 	bl	8000288 <__aeabi_dsub>
 80057d2:	4602      	mov	r2, r0
 80057d4:	460b      	mov	r3, r1
 80057d6:	2000      	movs	r0, #0
 80057d8:	4927      	ldr	r1, [pc, #156]	; (8005878 <__kernel_cos+0x190>)
 80057da:	e03c      	b.n	8005856 <__kernel_cos+0x16e>
 80057dc:	4b27      	ldr	r3, [pc, #156]	; (800587c <__kernel_cos+0x194>)
 80057de:	4926      	ldr	r1, [pc, #152]	; (8005878 <__kernel_cos+0x190>)
 80057e0:	429f      	cmp	r7, r3
 80057e2:	bfd7      	itett	le
 80057e4:	f5a7 1300 	suble.w	r3, r7, #2097152	; 0x200000
 80057e8:	4f25      	ldrgt	r7, [pc, #148]	; (8005880 <__kernel_cos+0x198>)
 80057ea:	2200      	movle	r2, #0
 80057ec:	4616      	movle	r6, r2
 80057ee:	bfd4      	ite	le
 80057f0:	461f      	movle	r7, r3
 80057f2:	2600      	movgt	r6, #0
 80057f4:	4632      	mov	r2, r6
 80057f6:	463b      	mov	r3, r7
 80057f8:	2000      	movs	r0, #0
 80057fa:	f7fa fd45 	bl	8000288 <__aeabi_dsub>
 80057fe:	2200      	movs	r2, #0
 8005800:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8005804:	4b1b      	ldr	r3, [pc, #108]	; (8005874 <__kernel_cos+0x18c>)
 8005806:	4620      	mov	r0, r4
 8005808:	4629      	mov	r1, r5
 800580a:	f7fa fef1 	bl	80005f0 <__aeabi_dmul>
 800580e:	4632      	mov	r2, r6
 8005810:	463b      	mov	r3, r7
 8005812:	f7fa fd39 	bl	8000288 <__aeabi_dsub>
 8005816:	4652      	mov	r2, sl
 8005818:	4606      	mov	r6, r0
 800581a:	460f      	mov	r7, r1
 800581c:	465b      	mov	r3, fp
 800581e:	4620      	mov	r0, r4
 8005820:	4629      	mov	r1, r5
 8005822:	f7fa fee5 	bl	80005f0 <__aeabi_dmul>
 8005826:	e9dd 2300 	ldrd	r2, r3, [sp]
 800582a:	4604      	mov	r4, r0
 800582c:	460d      	mov	r5, r1
 800582e:	4640      	mov	r0, r8
 8005830:	4649      	mov	r1, r9
 8005832:	f7fa fedd 	bl	80005f0 <__aeabi_dmul>
 8005836:	4602      	mov	r2, r0
 8005838:	460b      	mov	r3, r1
 800583a:	4620      	mov	r0, r4
 800583c:	4629      	mov	r1, r5
 800583e:	f7fa fd23 	bl	8000288 <__aeabi_dsub>
 8005842:	4602      	mov	r2, r0
 8005844:	460b      	mov	r3, r1
 8005846:	4630      	mov	r0, r6
 8005848:	4639      	mov	r1, r7
 800584a:	f7fa fd1d 	bl	8000288 <__aeabi_dsub>
 800584e:	4602      	mov	r2, r0
 8005850:	460b      	mov	r3, r1
 8005852:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005856:	f7fa fd17 	bl	8000288 <__aeabi_dsub>
 800585a:	e001      	b.n	8005860 <__kernel_cos+0x178>
 800585c:	4906      	ldr	r1, [pc, #24]	; (8005878 <__kernel_cos+0x190>)
 800585e:	2000      	movs	r0, #0
 8005860:	ec41 0b10 	vmov	d0, r0, r1
 8005864:	b005      	add	sp, #20
 8005866:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800586a:	bf00      	nop
 800586c:	f3af 8000 	nop.w
 8005870:	3fd33332 	.word	0x3fd33332
 8005874:	3fe00000 	.word	0x3fe00000
 8005878:	3ff00000 	.word	0x3ff00000
 800587c:	3fe90000 	.word	0x3fe90000
 8005880:	3fd20000 	.word	0x3fd20000
 8005884:	be8838d4 	.word	0xbe8838d4
 8005888:	bda8fae9 	.word	0xbda8fae9
 800588c:	bdb4b1c4 	.word	0xbdb4b1c4
 8005890:	3e21ee9e 	.word	0x3e21ee9e
 8005894:	809c52ad 	.word	0x809c52ad
 8005898:	3e927e4f 	.word	0x3e927e4f
 800589c:	19cb1590 	.word	0x19cb1590
 80058a0:	3efa01a0 	.word	0x3efa01a0
 80058a4:	16c15177 	.word	0x16c15177
 80058a8:	3f56c16c 	.word	0x3f56c16c
 80058ac:	5555554c 	.word	0x5555554c
 80058b0:	3fa55555 	.word	0x3fa55555
 80058b4:	00000000 	.word	0x00000000

080058b8 <__kernel_rem_pio2>:
 80058b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80058bc:	f5ad 7d19 	sub.w	sp, sp, #612	; 0x264
 80058c0:	2418      	movs	r4, #24
 80058c2:	9306      	str	r3, [sp, #24]
 80058c4:	9101      	str	r1, [sp, #4]
 80058c6:	4bba      	ldr	r3, [pc, #744]	; (8005bb0 <__kernel_rem_pio2+0x2f8>)
 80058c8:	99a2      	ldr	r1, [sp, #648]	; 0x288
 80058ca:	9009      	str	r0, [sp, #36]	; 0x24
 80058cc:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80058d0:	9302      	str	r3, [sp, #8]
 80058d2:	9b06      	ldr	r3, [sp, #24]
 80058d4:	3b01      	subs	r3, #1
 80058d6:	9305      	str	r3, [sp, #20]
 80058d8:	1ed3      	subs	r3, r2, #3
 80058da:	fb93 f4f4 	sdiv	r4, r3, r4
 80058de:	f06f 0317 	mvn.w	r3, #23
 80058e2:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
 80058e6:	fb04 3303 	mla	r3, r4, r3, r3
 80058ea:	eb03 0802 	add.w	r8, r3, r2
 80058ee:	9b02      	ldr	r3, [sp, #8]
 80058f0:	9a05      	ldr	r2, [sp, #20]
 80058f2:	eb03 0a02 	add.w	sl, r3, r2
 80058f6:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
 80058f8:	1aa7      	subs	r7, r4, r2
 80058fa:	ae20      	add	r6, sp, #128	; 0x80
 80058fc:	eb03 0987 	add.w	r9, r3, r7, lsl #2
 8005900:	2500      	movs	r5, #0
 8005902:	4555      	cmp	r5, sl
 8005904:	dc0c      	bgt.n	8005920 <__kernel_rem_pio2+0x68>
 8005906:	42ef      	cmn	r7, r5
 8005908:	d404      	bmi.n	8005914 <__kernel_rem_pio2+0x5c>
 800590a:	f859 0025 	ldr.w	r0, [r9, r5, lsl #2]
 800590e:	f7fa fe09 	bl	8000524 <__aeabi_i2d>
 8005912:	e001      	b.n	8005918 <__kernel_rem_pio2+0x60>
 8005914:	2000      	movs	r0, #0
 8005916:	2100      	movs	r1, #0
 8005918:	e8e6 0102 	strd	r0, r1, [r6], #8
 800591c:	3501      	adds	r5, #1
 800591e:	e7f0      	b.n	8005902 <__kernel_rem_pio2+0x4a>
 8005920:	f50d 7be0 	add.w	fp, sp, #448	; 0x1c0
 8005924:	2600      	movs	r6, #0
 8005926:	9b02      	ldr	r3, [sp, #8]
 8005928:	429e      	cmp	r6, r3
 800592a:	dc27      	bgt.n	800597c <__kernel_rem_pio2+0xc4>
 800592c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800592e:	9304      	str	r3, [sp, #16]
 8005930:	9b06      	ldr	r3, [sp, #24]
 8005932:	199d      	adds	r5, r3, r6
 8005934:	ab20      	add	r3, sp, #128	; 0x80
 8005936:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 800593a:	9308      	str	r3, [sp, #32]
 800593c:	f04f 0900 	mov.w	r9, #0
 8005940:	f04f 0a00 	mov.w	sl, #0
 8005944:	2700      	movs	r7, #0
 8005946:	9b05      	ldr	r3, [sp, #20]
 8005948:	429f      	cmp	r7, r3
 800594a:	dc13      	bgt.n	8005974 <__kernel_rem_pio2+0xbc>
 800594c:	9908      	ldr	r1, [sp, #32]
 800594e:	9d04      	ldr	r5, [sp, #16]
 8005950:	e971 2302 	ldrd	r2, r3, [r1, #-8]!
 8005954:	9108      	str	r1, [sp, #32]
 8005956:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 800595a:	9504      	str	r5, [sp, #16]
 800595c:	f7fa fe48 	bl	80005f0 <__aeabi_dmul>
 8005960:	4602      	mov	r2, r0
 8005962:	460b      	mov	r3, r1
 8005964:	4648      	mov	r0, r9
 8005966:	4651      	mov	r1, sl
 8005968:	f7fa fc90 	bl	800028c <__adddf3>
 800596c:	3701      	adds	r7, #1
 800596e:	4681      	mov	r9, r0
 8005970:	468a      	mov	sl, r1
 8005972:	e7e8      	b.n	8005946 <__kernel_rem_pio2+0x8e>
 8005974:	e8ab 0600 	stmia.w	fp!, {r9, sl}
 8005978:	3601      	adds	r6, #1
 800597a:	e7d4      	b.n	8005926 <__kernel_rem_pio2+0x6e>
 800597c:	9b02      	ldr	r3, [sp, #8]
 800597e:	f8dd b008 	ldr.w	fp, [sp, #8]
 8005982:	aa0c      	add	r2, sp, #48	; 0x30
 8005984:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8005988:	930a      	str	r3, [sp, #40]	; 0x28
 800598a:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
 800598c:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8005990:	930b      	str	r3, [sp, #44]	; 0x2c
 8005992:	ab98      	add	r3, sp, #608	; 0x260
 8005994:	f10b 5a00 	add.w	sl, fp, #536870912	; 0x20000000
 8005998:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 800599c:	f10a 3aff 	add.w	sl, sl, #4294967295
 80059a0:	e953 6728 	ldrd	r6, r7, [r3, #-160]	; 0xa0
 80059a4:	aa98      	add	r2, sp, #608	; 0x260
 80059a6:	ea4f 03ca 	mov.w	r3, sl, lsl #3
 80059aa:	eb02 0903 	add.w	r9, r2, r3
 80059ae:	9308      	str	r3, [sp, #32]
 80059b0:	f1a9 0998 	sub.w	r9, r9, #152	; 0x98
 80059b4:	f04f 0a00 	mov.w	sl, #0
 80059b8:	ebca 030b 	rsb	r3, sl, fp
 80059bc:	2b00      	cmp	r3, #0
 80059be:	dd25      	ble.n	8005a0c <__kernel_rem_pio2+0x154>
 80059c0:	2200      	movs	r2, #0
 80059c2:	4b7c      	ldr	r3, [pc, #496]	; (8005bb4 <__kernel_rem_pio2+0x2fc>)
 80059c4:	4630      	mov	r0, r6
 80059c6:	4639      	mov	r1, r7
 80059c8:	f7fa fe12 	bl	80005f0 <__aeabi_dmul>
 80059cc:	f7fb f8aa 	bl	8000b24 <__aeabi_d2iz>
 80059d0:	f7fa fda8 	bl	8000524 <__aeabi_i2d>
 80059d4:	2200      	movs	r2, #0
 80059d6:	4b78      	ldr	r3, [pc, #480]	; (8005bb8 <__kernel_rem_pio2+0x300>)
 80059d8:	4604      	mov	r4, r0
 80059da:	460d      	mov	r5, r1
 80059dc:	f7fa fe08 	bl	80005f0 <__aeabi_dmul>
 80059e0:	4602      	mov	r2, r0
 80059e2:	460b      	mov	r3, r1
 80059e4:	4630      	mov	r0, r6
 80059e6:	4639      	mov	r1, r7
 80059e8:	f7fa fc4e 	bl	8000288 <__aeabi_dsub>
 80059ec:	f7fb f89a 	bl	8000b24 <__aeabi_d2iz>
 80059f0:	ab0c      	add	r3, sp, #48	; 0x30
 80059f2:	4629      	mov	r1, r5
 80059f4:	f843 002a 	str.w	r0, [r3, sl, lsl #2]
 80059f8:	e979 2302 	ldrd	r2, r3, [r9, #-8]!
 80059fc:	4620      	mov	r0, r4
 80059fe:	f7fa fc45 	bl	800028c <__adddf3>
 8005a02:	f10a 0a01 	add.w	sl, sl, #1
 8005a06:	4606      	mov	r6, r0
 8005a08:	460f      	mov	r7, r1
 8005a0a:	e7d5      	b.n	80059b8 <__kernel_rem_pio2+0x100>
 8005a0c:	ec47 6b10 	vmov	d0, r6, r7
 8005a10:	4640      	mov	r0, r8
 8005a12:	f000 fbe9 	bl	80061e8 <scalbn>
 8005a16:	ec55 4b10 	vmov	r4, r5, d0
 8005a1a:	2200      	movs	r2, #0
 8005a1c:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
 8005a20:	ee10 0a10 	vmov	r0, s0
 8005a24:	4629      	mov	r1, r5
 8005a26:	f7fa fde3 	bl	80005f0 <__aeabi_dmul>
 8005a2a:	ec41 0b10 	vmov	d0, r0, r1
 8005a2e:	f000 fb57 	bl	80060e0 <floor>
 8005a32:	2200      	movs	r2, #0
 8005a34:	ec51 0b10 	vmov	r0, r1, d0
 8005a38:	4b60      	ldr	r3, [pc, #384]	; (8005bbc <__kernel_rem_pio2+0x304>)
 8005a3a:	f7fa fdd9 	bl	80005f0 <__aeabi_dmul>
 8005a3e:	4602      	mov	r2, r0
 8005a40:	460b      	mov	r3, r1
 8005a42:	4620      	mov	r0, r4
 8005a44:	4629      	mov	r1, r5
 8005a46:	f7fa fc1f 	bl	8000288 <__aeabi_dsub>
 8005a4a:	460d      	mov	r5, r1
 8005a4c:	4604      	mov	r4, r0
 8005a4e:	f7fb f869 	bl	8000b24 <__aeabi_d2iz>
 8005a52:	9004      	str	r0, [sp, #16]
 8005a54:	f7fa fd66 	bl	8000524 <__aeabi_i2d>
 8005a58:	4602      	mov	r2, r0
 8005a5a:	460b      	mov	r3, r1
 8005a5c:	4620      	mov	r0, r4
 8005a5e:	4629      	mov	r1, r5
 8005a60:	f7fa fc12 	bl	8000288 <__aeabi_dsub>
 8005a64:	f1b8 0f00 	cmp.w	r8, #0
 8005a68:	4606      	mov	r6, r0
 8005a6a:	460f      	mov	r7, r1
 8005a6c:	dd15      	ble.n	8005a9a <__kernel_rem_pio2+0x1e2>
 8005a6e:	f10b 31ff 	add.w	r1, fp, #4294967295
 8005a72:	ab0c      	add	r3, sp, #48	; 0x30
 8005a74:	f1c8 0018 	rsb	r0, r8, #24
 8005a78:	f853 2021 	ldr.w	r2, [r3, r1, lsl #2]
 8005a7c:	9c04      	ldr	r4, [sp, #16]
 8005a7e:	fa42 f300 	asr.w	r3, r2, r0
 8005a82:	441c      	add	r4, r3
 8005a84:	4083      	lsls	r3, r0
 8005a86:	1ad3      	subs	r3, r2, r3
 8005a88:	aa0c      	add	r2, sp, #48	; 0x30
 8005a8a:	f1c8 0017 	rsb	r0, r8, #23
 8005a8e:	9404      	str	r4, [sp, #16]
 8005a90:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 8005a94:	fa43 fa00 	asr.w	sl, r3, r0
 8005a98:	e00f      	b.n	8005aba <__kernel_rem_pio2+0x202>
 8005a9a:	d107      	bne.n	8005aac <__kernel_rem_pio2+0x1f4>
 8005a9c:	f10b 33ff 	add.w	r3, fp, #4294967295
 8005aa0:	aa0c      	add	r2, sp, #48	; 0x30
 8005aa2:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8005aa6:	ea4f 5ae0 	mov.w	sl, r0, asr #23
 8005aaa:	e006      	b.n	8005aba <__kernel_rem_pio2+0x202>
 8005aac:	2200      	movs	r2, #0
 8005aae:	4b44      	ldr	r3, [pc, #272]	; (8005bc0 <__kernel_rem_pio2+0x308>)
 8005ab0:	f7fb f824 	bl	8000afc <__aeabi_dcmpge>
 8005ab4:	b928      	cbnz	r0, 8005ac2 <__kernel_rem_pio2+0x20a>
 8005ab6:	4682      	mov	sl, r0
 8005ab8:	e052      	b.n	8005b60 <__kernel_rem_pio2+0x2a8>
 8005aba:	f1ba 0f00 	cmp.w	sl, #0
 8005abe:	dc02      	bgt.n	8005ac6 <__kernel_rem_pio2+0x20e>
 8005ac0:	e04e      	b.n	8005b60 <__kernel_rem_pio2+0x2a8>
 8005ac2:	f04f 0a02 	mov.w	sl, #2
 8005ac6:	9b04      	ldr	r3, [sp, #16]
 8005ac8:	2200      	movs	r2, #0
 8005aca:	3301      	adds	r3, #1
 8005acc:	9304      	str	r3, [sp, #16]
 8005ace:	4614      	mov	r4, r2
 8005ad0:	4593      	cmp	fp, r2
 8005ad2:	dd11      	ble.n	8005af8 <__kernel_rem_pio2+0x240>
 8005ad4:	ab0c      	add	r3, sp, #48	; 0x30
 8005ad6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8005ada:	b91c      	cbnz	r4, 8005ae4 <__kernel_rem_pio2+0x22c>
 8005adc:	b153      	cbz	r3, 8005af4 <__kernel_rem_pio2+0x23c>
 8005ade:	f1c3 7380 	rsb	r3, r3, #16777216	; 0x1000000
 8005ae2:	e003      	b.n	8005aec <__kernel_rem_pio2+0x234>
 8005ae4:	f1c3 13ff 	rsb	r3, r3, #16711935	; 0xff00ff
 8005ae8:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
 8005aec:	a90c      	add	r1, sp, #48	; 0x30
 8005aee:	2401      	movs	r4, #1
 8005af0:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
 8005af4:	3201      	adds	r2, #1
 8005af6:	e7eb      	b.n	8005ad0 <__kernel_rem_pio2+0x218>
 8005af8:	f1b8 0f00 	cmp.w	r8, #0
 8005afc:	dd17      	ble.n	8005b2e <__kernel_rem_pio2+0x276>
 8005afe:	f1b8 0f01 	cmp.w	r8, #1
 8005b02:	d00a      	beq.n	8005b1a <__kernel_rem_pio2+0x262>
 8005b04:	f1b8 0f02 	cmp.w	r8, #2
 8005b08:	d111      	bne.n	8005b2e <__kernel_rem_pio2+0x276>
 8005b0a:	f10b 32ff 	add.w	r2, fp, #4294967295
 8005b0e:	ab0c      	add	r3, sp, #48	; 0x30
 8005b10:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8005b14:	f3c3 0315 	ubfx	r3, r3, #0, #22
 8005b18:	e006      	b.n	8005b28 <__kernel_rem_pio2+0x270>
 8005b1a:	f10b 32ff 	add.w	r2, fp, #4294967295
 8005b1e:	ab0c      	add	r3, sp, #48	; 0x30
 8005b20:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8005b24:	f3c3 0316 	ubfx	r3, r3, #0, #23
 8005b28:	a90c      	add	r1, sp, #48	; 0x30
 8005b2a:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
 8005b2e:	f1ba 0f02 	cmp.w	sl, #2
 8005b32:	d115      	bne.n	8005b60 <__kernel_rem_pio2+0x2a8>
 8005b34:	4632      	mov	r2, r6
 8005b36:	463b      	mov	r3, r7
 8005b38:	2000      	movs	r0, #0
 8005b3a:	4922      	ldr	r1, [pc, #136]	; (8005bc4 <__kernel_rem_pio2+0x30c>)
 8005b3c:	f7fa fba4 	bl	8000288 <__aeabi_dsub>
 8005b40:	4606      	mov	r6, r0
 8005b42:	460f      	mov	r7, r1
 8005b44:	b164      	cbz	r4, 8005b60 <__kernel_rem_pio2+0x2a8>
 8005b46:	4640      	mov	r0, r8
 8005b48:	ed9f 0b17 	vldr	d0, [pc, #92]	; 8005ba8 <__kernel_rem_pio2+0x2f0>
 8005b4c:	f000 fb4c 	bl	80061e8 <scalbn>
 8005b50:	4630      	mov	r0, r6
 8005b52:	4639      	mov	r1, r7
 8005b54:	ec53 2b10 	vmov	r2, r3, d0
 8005b58:	f7fa fb96 	bl	8000288 <__aeabi_dsub>
 8005b5c:	4606      	mov	r6, r0
 8005b5e:	460f      	mov	r7, r1
 8005b60:	2200      	movs	r2, #0
 8005b62:	2300      	movs	r3, #0
 8005b64:	4630      	mov	r0, r6
 8005b66:	4639      	mov	r1, r7
 8005b68:	f7fa ffaa 	bl	8000ac0 <__aeabi_dcmpeq>
 8005b6c:	2800      	cmp	r0, #0
 8005b6e:	d074      	beq.n	8005c5a <__kernel_rem_pio2+0x3a2>
 8005b70:	f10b 31ff 	add.w	r1, fp, #4294967295
 8005b74:	460b      	mov	r3, r1
 8005b76:	2200      	movs	r2, #0
 8005b78:	9802      	ldr	r0, [sp, #8]
 8005b7a:	4283      	cmp	r3, r0
 8005b7c:	db05      	blt.n	8005b8a <__kernel_rem_pio2+0x2d2>
 8005b7e:	a80c      	add	r0, sp, #48	; 0x30
 8005b80:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 8005b84:	3b01      	subs	r3, #1
 8005b86:	4302      	orrs	r2, r0
 8005b88:	e7f6      	b.n	8005b78 <__kernel_rem_pio2+0x2c0>
 8005b8a:	2a00      	cmp	r2, #0
 8005b8c:	d158      	bne.n	8005c40 <__kernel_rem_pio2+0x388>
 8005b8e:	2301      	movs	r3, #1
 8005b90:	f06f 0103 	mvn.w	r1, #3
 8005b94:	fb01 f203 	mul.w	r2, r1, r3
 8005b98:	980a      	ldr	r0, [sp, #40]	; 0x28
 8005b9a:	5882      	ldr	r2, [r0, r2]
 8005b9c:	b9a2      	cbnz	r2, 8005bc8 <__kernel_rem_pio2+0x310>
 8005b9e:	3301      	adds	r3, #1
 8005ba0:	e7f8      	b.n	8005b94 <__kernel_rem_pio2+0x2dc>
 8005ba2:	bf00      	nop
 8005ba4:	f3af 8000 	nop.w
 8005ba8:	00000000 	.word	0x00000000
 8005bac:	3ff00000 	.word	0x3ff00000
 8005bb0:	08007d98 	.word	0x08007d98
 8005bb4:	3e700000 	.word	0x3e700000
 8005bb8:	41700000 	.word	0x41700000
 8005bbc:	40200000 	.word	0x40200000
 8005bc0:	3fe00000 	.word	0x3fe00000
 8005bc4:	3ff00000 	.word	0x3ff00000
 8005bc8:	9a08      	ldr	r2, [sp, #32]
 8005bca:	a998      	add	r1, sp, #608	; 0x260
 8005bcc:	440a      	add	r2, r1
 8005bce:	3a98      	subs	r2, #152	; 0x98
 8005bd0:	9204      	str	r2, [sp, #16]
 8005bd2:	9a06      	ldr	r2, [sp, #24]
 8005bd4:	445b      	add	r3, fp
 8005bd6:	eb02 050b 	add.w	r5, r2, fp
 8005bda:	aa20      	add	r2, sp, #128	; 0x80
 8005bdc:	f10b 0601 	add.w	r6, fp, #1
 8005be0:	eb02 05c5 	add.w	r5, r2, r5, lsl #3
 8005be4:	9308      	str	r3, [sp, #32]
 8005be6:	9b08      	ldr	r3, [sp, #32]
 8005be8:	429e      	cmp	r6, r3
 8005bea:	dc27      	bgt.n	8005c3c <__kernel_rem_pio2+0x384>
 8005bec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8005bee:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
 8005bf2:	f7fa fc97 	bl	8000524 <__aeabi_i2d>
 8005bf6:	e8e5 0102 	strd	r0, r1, [r5], #8
 8005bfa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8005bfc:	46a9      	mov	r9, r5
 8005bfe:	461c      	mov	r4, r3
 8005c00:	2700      	movs	r7, #0
 8005c02:	f04f 0a00 	mov.w	sl, #0
 8005c06:	f04f 0b00 	mov.w	fp, #0
 8005c0a:	9b05      	ldr	r3, [sp, #20]
 8005c0c:	429f      	cmp	r7, r3
 8005c0e:	dc0f      	bgt.n	8005c30 <__kernel_rem_pio2+0x378>
 8005c10:	e979 2302 	ldrd	r2, r3, [r9, #-8]!
 8005c14:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 8005c18:	f7fa fcea 	bl	80005f0 <__aeabi_dmul>
 8005c1c:	4602      	mov	r2, r0
 8005c1e:	460b      	mov	r3, r1
 8005c20:	4650      	mov	r0, sl
 8005c22:	4659      	mov	r1, fp
 8005c24:	f7fa fb32 	bl	800028c <__adddf3>
 8005c28:	3701      	adds	r7, #1
 8005c2a:	4682      	mov	sl, r0
 8005c2c:	468b      	mov	fp, r1
 8005c2e:	e7ec      	b.n	8005c0a <__kernel_rem_pio2+0x352>
 8005c30:	9b04      	ldr	r3, [sp, #16]
 8005c32:	e9e3 ab02 	strd	sl, fp, [r3, #8]!
 8005c36:	3601      	adds	r6, #1
 8005c38:	9304      	str	r3, [sp, #16]
 8005c3a:	e7d4      	b.n	8005be6 <__kernel_rem_pio2+0x32e>
 8005c3c:	469b      	mov	fp, r3
 8005c3e:	e6a8      	b.n	8005992 <__kernel_rem_pio2+0xda>
 8005c40:	f1a8 0818 	sub.w	r8, r8, #24
 8005c44:	468b      	mov	fp, r1
 8005c46:	ab0c      	add	r3, sp, #48	; 0x30
 8005c48:	f853 302b 	ldr.w	r3, [r3, fp, lsl #2]
 8005c4c:	2b00      	cmp	r3, #0
 8005c4e:	d13c      	bne.n	8005cca <__kernel_rem_pio2+0x412>
 8005c50:	f10b 3bff 	add.w	fp, fp, #4294967295
 8005c54:	f1a8 0818 	sub.w	r8, r8, #24
 8005c58:	e7f5      	b.n	8005c46 <__kernel_rem_pio2+0x38e>
 8005c5a:	f1c8 0000 	rsb	r0, r8, #0
 8005c5e:	ec47 6b10 	vmov	d0, r6, r7
 8005c62:	f000 fac1 	bl	80061e8 <scalbn>
 8005c66:	ec55 4b10 	vmov	r4, r5, d0
 8005c6a:	2200      	movs	r2, #0
 8005c6c:	4bb6      	ldr	r3, [pc, #728]	; (8005f48 <__kernel_rem_pio2+0x690>)
 8005c6e:	ee10 0a10 	vmov	r0, s0
 8005c72:	4629      	mov	r1, r5
 8005c74:	f7fa ff42 	bl	8000afc <__aeabi_dcmpge>
 8005c78:	b300      	cbz	r0, 8005cbc <__kernel_rem_pio2+0x404>
 8005c7a:	2200      	movs	r2, #0
 8005c7c:	4bb3      	ldr	r3, [pc, #716]	; (8005f4c <__kernel_rem_pio2+0x694>)
 8005c7e:	4620      	mov	r0, r4
 8005c80:	4629      	mov	r1, r5
 8005c82:	f7fa fcb5 	bl	80005f0 <__aeabi_dmul>
 8005c86:	f7fa ff4d 	bl	8000b24 <__aeabi_d2iz>
 8005c8a:	4606      	mov	r6, r0
 8005c8c:	f7fa fc4a 	bl	8000524 <__aeabi_i2d>
 8005c90:	2200      	movs	r2, #0
 8005c92:	4bad      	ldr	r3, [pc, #692]	; (8005f48 <__kernel_rem_pio2+0x690>)
 8005c94:	f7fa fcac 	bl	80005f0 <__aeabi_dmul>
 8005c98:	460b      	mov	r3, r1
 8005c9a:	4602      	mov	r2, r0
 8005c9c:	4629      	mov	r1, r5
 8005c9e:	4620      	mov	r0, r4
 8005ca0:	f7fa faf2 	bl	8000288 <__aeabi_dsub>
 8005ca4:	f7fa ff3e 	bl	8000b24 <__aeabi_d2iz>
 8005ca8:	ab0c      	add	r3, sp, #48	; 0x30
 8005caa:	f108 0818 	add.w	r8, r8, #24
 8005cae:	f843 002b 	str.w	r0, [r3, fp, lsl #2]
 8005cb2:	f10b 0b01 	add.w	fp, fp, #1
 8005cb6:	f843 602b 	str.w	r6, [r3, fp, lsl #2]
 8005cba:	e006      	b.n	8005cca <__kernel_rem_pio2+0x412>
 8005cbc:	4620      	mov	r0, r4
 8005cbe:	4629      	mov	r1, r5
 8005cc0:	f7fa ff30 	bl	8000b24 <__aeabi_d2iz>
 8005cc4:	ab0c      	add	r3, sp, #48	; 0x30
 8005cc6:	f843 002b 	str.w	r0, [r3, fp, lsl #2]
 8005cca:	4640      	mov	r0, r8
 8005ccc:	ed9f 0b9a 	vldr	d0, [pc, #616]	; 8005f38 <__kernel_rem_pio2+0x680>
 8005cd0:	f000 fa8a 	bl	80061e8 <scalbn>
 8005cd4:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8005cd8:	9305      	str	r3, [sp, #20]
 8005cda:	9a05      	ldr	r2, [sp, #20]
 8005cdc:	ab98      	add	r3, sp, #608	; 0x260
 8005cde:	189f      	adds	r7, r3, r2
 8005ce0:	ec55 4b10 	vmov	r4, r5, d0
 8005ce4:	3f98      	subs	r7, #152	; 0x98
 8005ce6:	465e      	mov	r6, fp
 8005ce8:	2e00      	cmp	r6, #0
 8005cea:	db14      	blt.n	8005d16 <__kernel_rem_pio2+0x45e>
 8005cec:	ab0c      	add	r3, sp, #48	; 0x30
 8005cee:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
 8005cf2:	f7fa fc17 	bl	8000524 <__aeabi_i2d>
 8005cf6:	4622      	mov	r2, r4
 8005cf8:	462b      	mov	r3, r5
 8005cfa:	f7fa fc79 	bl	80005f0 <__aeabi_dmul>
 8005cfe:	2200      	movs	r2, #0
 8005d00:	e967 0102 	strd	r0, r1, [r7, #-8]!
 8005d04:	4b91      	ldr	r3, [pc, #580]	; (8005f4c <__kernel_rem_pio2+0x694>)
 8005d06:	4620      	mov	r0, r4
 8005d08:	4629      	mov	r1, r5
 8005d0a:	f7fa fc71 	bl	80005f0 <__aeabi_dmul>
 8005d0e:	3e01      	subs	r6, #1
 8005d10:	4604      	mov	r4, r0
 8005d12:	460d      	mov	r5, r1
 8005d14:	e7e8      	b.n	8005ce8 <__kernel_rem_pio2+0x430>
 8005d16:	f50d 7890 	add.w	r8, sp, #288	; 0x120
 8005d1a:	2400      	movs	r4, #0
 8005d1c:	4645      	mov	r5, r8
 8005d1e:	ebbb 0704 	subs.w	r7, fp, r4
 8005d22:	d424      	bmi.n	8005d6e <__kernel_rem_pio2+0x4b6>
 8005d24:	ed9f 7b86 	vldr	d7, [pc, #536]	; 8005f40 <__kernel_rem_pio2+0x688>
 8005d28:	ed8d 7b06 	vstr	d7, [sp, #24]
 8005d2c:	ab70      	add	r3, sp, #448	; 0x1c0
 8005d2e:	f8df 9220 	ldr.w	r9, [pc, #544]	; 8005f50 <__kernel_rem_pio2+0x698>
 8005d32:	eb03 07c7 	add.w	r7, r3, r7, lsl #3
 8005d36:	2600      	movs	r6, #0
 8005d38:	9b02      	ldr	r3, [sp, #8]
 8005d3a:	429e      	cmp	r6, r3
 8005d3c:	dc11      	bgt.n	8005d62 <__kernel_rem_pio2+0x4aa>
 8005d3e:	42a6      	cmp	r6, r4
 8005d40:	dc0f      	bgt.n	8005d62 <__kernel_rem_pio2+0x4aa>
 8005d42:	e8f7 2302 	ldrd	r2, r3, [r7], #8
 8005d46:	e8f9 0102 	ldrd	r0, r1, [r9], #8
 8005d4a:	f7fa fc51 	bl	80005f0 <__aeabi_dmul>
 8005d4e:	4602      	mov	r2, r0
 8005d50:	460b      	mov	r3, r1
 8005d52:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8005d56:	f7fa fa99 	bl	800028c <__adddf3>
 8005d5a:	3601      	adds	r6, #1
 8005d5c:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8005d60:	e7ea      	b.n	8005d38 <__kernel_rem_pio2+0x480>
 8005d62:	ed9d 7b06 	vldr	d7, [sp, #24]
 8005d66:	3401      	adds	r4, #1
 8005d68:	eca8 7b02 	vstmia	r8!, {d7}
 8005d6c:	e7d7      	b.n	8005d1e <__kernel_rem_pio2+0x466>
 8005d6e:	9ba2      	ldr	r3, [sp, #648]	; 0x288
 8005d70:	2b03      	cmp	r3, #3
 8005d72:	f200 80d8 	bhi.w	8005f26 <__kernel_rem_pio2+0x66e>
 8005d76:	e8df f003 	tbb	[pc, r3]
 8005d7a:	0810      	.short	0x0810
 8005d7c:	0208      	.short	0x0208
 8005d7e:	9a05      	ldr	r2, [sp, #20]
 8005d80:	ab48      	add	r3, sp, #288	; 0x120
 8005d82:	189c      	adds	r4, r3, r2
 8005d84:	46a0      	mov	r8, r4
 8005d86:	46d9      	mov	r9, fp
 8005d88:	e056      	b.n	8005e38 <__kernel_rem_pio2+0x580>
 8005d8a:	9c05      	ldr	r4, [sp, #20]
 8005d8c:	ab48      	add	r3, sp, #288	; 0x120
 8005d8e:	3408      	adds	r4, #8
 8005d90:	441c      	add	r4, r3
 8005d92:	465d      	mov	r5, fp
 8005d94:	2000      	movs	r0, #0
 8005d96:	2100      	movs	r1, #0
 8005d98:	e01d      	b.n	8005dd6 <__kernel_rem_pio2+0x51e>
 8005d9a:	9b05      	ldr	r3, [sp, #20]
 8005d9c:	aa98      	add	r2, sp, #608	; 0x260
 8005d9e:	4413      	add	r3, r2
 8005da0:	f5a3 749c 	sub.w	r4, r3, #312	; 0x138
 8005da4:	2000      	movs	r0, #0
 8005da6:	2100      	movs	r1, #0
 8005da8:	f1bb 0f00 	cmp.w	fp, #0
 8005dac:	db06      	blt.n	8005dbc <__kernel_rem_pio2+0x504>
 8005dae:	e974 2302 	ldrd	r2, r3, [r4, #-8]!
 8005db2:	f7fa fa6b 	bl	800028c <__adddf3>
 8005db6:	f10b 3bff 	add.w	fp, fp, #4294967295
 8005dba:	e7f5      	b.n	8005da8 <__kernel_rem_pio2+0x4f0>
 8005dbc:	f1ba 0f00 	cmp.w	sl, #0
 8005dc0:	d003      	beq.n	8005dca <__kernel_rem_pio2+0x512>
 8005dc2:	4602      	mov	r2, r0
 8005dc4:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8005dc8:	e001      	b.n	8005dce <__kernel_rem_pio2+0x516>
 8005dca:	4602      	mov	r2, r0
 8005dcc:	460b      	mov	r3, r1
 8005dce:	9901      	ldr	r1, [sp, #4]
 8005dd0:	e9c1 2300 	strd	r2, r3, [r1]
 8005dd4:	e0a7      	b.n	8005f26 <__kernel_rem_pio2+0x66e>
 8005dd6:	2d00      	cmp	r5, #0
 8005dd8:	db05      	blt.n	8005de6 <__kernel_rem_pio2+0x52e>
 8005dda:	e974 2302 	ldrd	r2, r3, [r4, #-8]!
 8005dde:	f7fa fa55 	bl	800028c <__adddf3>
 8005de2:	3d01      	subs	r5, #1
 8005de4:	e7f7      	b.n	8005dd6 <__kernel_rem_pio2+0x51e>
 8005de6:	f1ba 0f00 	cmp.w	sl, #0
 8005dea:	d003      	beq.n	8005df4 <__kernel_rem_pio2+0x53c>
 8005dec:	4602      	mov	r2, r0
 8005dee:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8005df2:	e001      	b.n	8005df8 <__kernel_rem_pio2+0x540>
 8005df4:	4602      	mov	r2, r0
 8005df6:	460b      	mov	r3, r1
 8005df8:	9c01      	ldr	r4, [sp, #4]
 8005dfa:	e9c4 2300 	strd	r2, r3, [r4]
 8005dfe:	4602      	mov	r2, r0
 8005e00:	460b      	mov	r3, r1
 8005e02:	e9dd 0148 	ldrd	r0, r1, [sp, #288]	; 0x120
 8005e06:	f7fa fa3f 	bl	8000288 <__aeabi_dsub>
 8005e0a:	ad4a      	add	r5, sp, #296	; 0x128
 8005e0c:	2401      	movs	r4, #1
 8005e0e:	45a3      	cmp	fp, r4
 8005e10:	db05      	blt.n	8005e1e <__kernel_rem_pio2+0x566>
 8005e12:	e8f5 2302 	ldrd	r2, r3, [r5], #8
 8005e16:	f7fa fa39 	bl	800028c <__adddf3>
 8005e1a:	3401      	adds	r4, #1
 8005e1c:	e7f7      	b.n	8005e0e <__kernel_rem_pio2+0x556>
 8005e1e:	f1ba 0f00 	cmp.w	sl, #0
 8005e22:	d003      	beq.n	8005e2c <__kernel_rem_pio2+0x574>
 8005e24:	4602      	mov	r2, r0
 8005e26:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8005e2a:	e001      	b.n	8005e30 <__kernel_rem_pio2+0x578>
 8005e2c:	4602      	mov	r2, r0
 8005e2e:	460b      	mov	r3, r1
 8005e30:	9901      	ldr	r1, [sp, #4]
 8005e32:	e9c1 2302 	strd	r2, r3, [r1, #8]
 8005e36:	e076      	b.n	8005f26 <__kernel_rem_pio2+0x66e>
 8005e38:	f1b9 0f00 	cmp.w	r9, #0
 8005e3c:	dd20      	ble.n	8005e80 <__kernel_rem_pio2+0x5c8>
 8005e3e:	e978 6702 	ldrd	r6, r7, [r8, #-8]!
 8005e42:	ed98 7b02 	vldr	d7, [r8, #8]
 8005e46:	4630      	mov	r0, r6
 8005e48:	ec53 2b17 	vmov	r2, r3, d7
 8005e4c:	4639      	mov	r1, r7
 8005e4e:	ed8d 7b02 	vstr	d7, [sp, #8]
 8005e52:	f7fa fa1b 	bl	800028c <__adddf3>
 8005e56:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8005e5a:	4602      	mov	r2, r0
 8005e5c:	460b      	mov	r3, r1
 8005e5e:	4630      	mov	r0, r6
 8005e60:	4639      	mov	r1, r7
 8005e62:	f7fa fa11 	bl	8000288 <__aeabi_dsub>
 8005e66:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8005e6a:	f7fa fa0f 	bl	800028c <__adddf3>
 8005e6e:	ed9d 7b06 	vldr	d7, [sp, #24]
 8005e72:	f109 39ff 	add.w	r9, r9, #4294967295
 8005e76:	e9c8 0102 	strd	r0, r1, [r8, #8]
 8005e7a:	ed88 7b00 	vstr	d7, [r8]
 8005e7e:	e7db      	b.n	8005e38 <__kernel_rem_pio2+0x580>
 8005e80:	465e      	mov	r6, fp
 8005e82:	2e01      	cmp	r6, #1
 8005e84:	dd1f      	ble.n	8005ec6 <__kernel_rem_pio2+0x60e>
 8005e86:	e974 8902 	ldrd	r8, r9, [r4, #-8]!
 8005e8a:	ed94 7b02 	vldr	d7, [r4, #8]
 8005e8e:	4640      	mov	r0, r8
 8005e90:	ec53 2b17 	vmov	r2, r3, d7
 8005e94:	4649      	mov	r1, r9
 8005e96:	ed8d 7b02 	vstr	d7, [sp, #8]
 8005e9a:	f7fa f9f7 	bl	800028c <__adddf3>
 8005e9e:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8005ea2:	4602      	mov	r2, r0
 8005ea4:	460b      	mov	r3, r1
 8005ea6:	4640      	mov	r0, r8
 8005ea8:	4649      	mov	r1, r9
 8005eaa:	f7fa f9ed 	bl	8000288 <__aeabi_dsub>
 8005eae:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8005eb2:	f7fa f9eb 	bl	800028c <__adddf3>
 8005eb6:	ed9d 7b06 	vldr	d7, [sp, #24]
 8005eba:	3e01      	subs	r6, #1
 8005ebc:	e9c4 0102 	strd	r0, r1, [r4, #8]
 8005ec0:	ed84 7b00 	vstr	d7, [r4]
 8005ec4:	e7dd      	b.n	8005e82 <__kernel_rem_pio2+0x5ca>
 8005ec6:	9c05      	ldr	r4, [sp, #20]
 8005ec8:	ab48      	add	r3, sp, #288	; 0x120
 8005eca:	3408      	adds	r4, #8
 8005ecc:	441c      	add	r4, r3
 8005ece:	2000      	movs	r0, #0
 8005ed0:	2100      	movs	r1, #0
 8005ed2:	f1bb 0f01 	cmp.w	fp, #1
 8005ed6:	dd06      	ble.n	8005ee6 <__kernel_rem_pio2+0x62e>
 8005ed8:	e974 2302 	ldrd	r2, r3, [r4, #-8]!
 8005edc:	f7fa f9d6 	bl	800028c <__adddf3>
 8005ee0:	f10b 3bff 	add.w	fp, fp, #4294967295
 8005ee4:	e7f5      	b.n	8005ed2 <__kernel_rem_pio2+0x61a>
 8005ee6:	f1ba 0f00 	cmp.w	sl, #0
 8005eea:	d10b      	bne.n	8005f04 <__kernel_rem_pio2+0x64c>
 8005eec:	e9dd 2348 	ldrd	r2, r3, [sp, #288]	; 0x120
 8005ef0:	9c01      	ldr	r4, [sp, #4]
 8005ef2:	e9c4 2300 	strd	r2, r3, [r4]
 8005ef6:	e9dd 234a 	ldrd	r2, r3, [sp, #296]	; 0x128
 8005efa:	e9c4 0104 	strd	r0, r1, [r4, #16]
 8005efe:	e9c4 2302 	strd	r2, r3, [r4, #8]
 8005f02:	e010      	b.n	8005f26 <__kernel_rem_pio2+0x66e>
 8005f04:	9a01      	ldr	r2, [sp, #4]
 8005f06:	682b      	ldr	r3, [r5, #0]
 8005f08:	6013      	str	r3, [r2, #0]
 8005f0a:	686b      	ldr	r3, [r5, #4]
 8005f0c:	6110      	str	r0, [r2, #16]
 8005f0e:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8005f12:	6053      	str	r3, [r2, #4]
 8005f14:	68ab      	ldr	r3, [r5, #8]
 8005f16:	6093      	str	r3, [r2, #8]
 8005f18:	68eb      	ldr	r3, [r5, #12]
 8005f1a:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8005f1e:	60d3      	str	r3, [r2, #12]
 8005f20:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8005f24:	6153      	str	r3, [r2, #20]
 8005f26:	9b04      	ldr	r3, [sp, #16]
 8005f28:	f003 0007 	and.w	r0, r3, #7
 8005f2c:	f50d 7d19 	add.w	sp, sp, #612	; 0x264
 8005f30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005f34:	f3af 8000 	nop.w
 8005f38:	00000000 	.word	0x00000000
 8005f3c:	3ff00000 	.word	0x3ff00000
	...
 8005f48:	41700000 	.word	0x41700000
 8005f4c:	3e700000 	.word	0x3e700000
 8005f50:	08007da8 	.word	0x08007da8
 8005f54:	00000000 	.word	0x00000000

08005f58 <__kernel_sin>:
 8005f58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005f5c:	ec55 4b10 	vmov	r4, r5, d0
 8005f60:	b085      	sub	sp, #20
 8005f62:	f025 4300 	bic.w	r3, r5, #2147483648	; 0x80000000
 8005f66:	f1b3 5f79 	cmp.w	r3, #1044381696	; 0x3e400000
 8005f6a:	ed8d 1b00 	vstr	d1, [sp]
 8005f6e:	9002      	str	r0, [sp, #8]
 8005f70:	da07      	bge.n	8005f82 <__kernel_sin+0x2a>
 8005f72:	ee10 0a10 	vmov	r0, s0
 8005f76:	4629      	mov	r1, r5
 8005f78:	f7fa fdd4 	bl	8000b24 <__aeabi_d2iz>
 8005f7c:	2800      	cmp	r0, #0
 8005f7e:	f000 8081 	beq.w	8006084 <__kernel_sin+0x12c>
 8005f82:	4622      	mov	r2, r4
 8005f84:	462b      	mov	r3, r5
 8005f86:	4620      	mov	r0, r4
 8005f88:	4629      	mov	r1, r5
 8005f8a:	f7fa fb31 	bl	80005f0 <__aeabi_dmul>
 8005f8e:	4682      	mov	sl, r0
 8005f90:	468b      	mov	fp, r1
 8005f92:	4602      	mov	r2, r0
 8005f94:	460b      	mov	r3, r1
 8005f96:	4620      	mov	r0, r4
 8005f98:	4629      	mov	r1, r5
 8005f9a:	f7fa fb29 	bl	80005f0 <__aeabi_dmul>
 8005f9e:	a341      	add	r3, pc, #260	; (adr r3, 80060a4 <__kernel_sin+0x14c>)
 8005fa0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005fa4:	4680      	mov	r8, r0
 8005fa6:	4689      	mov	r9, r1
 8005fa8:	4650      	mov	r0, sl
 8005faa:	4659      	mov	r1, fp
 8005fac:	f7fa fb20 	bl	80005f0 <__aeabi_dmul>
 8005fb0:	a33e      	add	r3, pc, #248	; (adr r3, 80060ac <__kernel_sin+0x154>)
 8005fb2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005fb6:	f7fa f967 	bl	8000288 <__aeabi_dsub>
 8005fba:	4652      	mov	r2, sl
 8005fbc:	465b      	mov	r3, fp
 8005fbe:	f7fa fb17 	bl	80005f0 <__aeabi_dmul>
 8005fc2:	a33c      	add	r3, pc, #240	; (adr r3, 80060b4 <__kernel_sin+0x15c>)
 8005fc4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005fc8:	f7fa f960 	bl	800028c <__adddf3>
 8005fcc:	4652      	mov	r2, sl
 8005fce:	465b      	mov	r3, fp
 8005fd0:	f7fa fb0e 	bl	80005f0 <__aeabi_dmul>
 8005fd4:	a339      	add	r3, pc, #228	; (adr r3, 80060bc <__kernel_sin+0x164>)
 8005fd6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005fda:	f7fa f955 	bl	8000288 <__aeabi_dsub>
 8005fde:	4652      	mov	r2, sl
 8005fe0:	465b      	mov	r3, fp
 8005fe2:	f7fa fb05 	bl	80005f0 <__aeabi_dmul>
 8005fe6:	a337      	add	r3, pc, #220	; (adr r3, 80060c4 <__kernel_sin+0x16c>)
 8005fe8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005fec:	f7fa f94e 	bl	800028c <__adddf3>
 8005ff0:	9b02      	ldr	r3, [sp, #8]
 8005ff2:	4606      	mov	r6, r0
 8005ff4:	460f      	mov	r7, r1
 8005ff6:	b99b      	cbnz	r3, 8006020 <__kernel_sin+0xc8>
 8005ff8:	4602      	mov	r2, r0
 8005ffa:	460b      	mov	r3, r1
 8005ffc:	4650      	mov	r0, sl
 8005ffe:	4659      	mov	r1, fp
 8006000:	f7fa faf6 	bl	80005f0 <__aeabi_dmul>
 8006004:	a324      	add	r3, pc, #144	; (adr r3, 8006098 <__kernel_sin+0x140>)
 8006006:	e9d3 2300 	ldrd	r2, r3, [r3]
 800600a:	f7fa f93d 	bl	8000288 <__aeabi_dsub>
 800600e:	4642      	mov	r2, r8
 8006010:	464b      	mov	r3, r9
 8006012:	f7fa faed 	bl	80005f0 <__aeabi_dmul>
 8006016:	4622      	mov	r2, r4
 8006018:	462b      	mov	r3, r5
 800601a:	f7fa f937 	bl	800028c <__adddf3>
 800601e:	e033      	b.n	8006088 <__kernel_sin+0x130>
 8006020:	2200      	movs	r2, #0
 8006022:	4b1f      	ldr	r3, [pc, #124]	; (80060a0 <__kernel_sin+0x148>)
 8006024:	e9dd 0100 	ldrd	r0, r1, [sp]
 8006028:	f7fa fae2 	bl	80005f0 <__aeabi_dmul>
 800602c:	4632      	mov	r2, r6
 800602e:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8006032:	463b      	mov	r3, r7
 8006034:	4640      	mov	r0, r8
 8006036:	4649      	mov	r1, r9
 8006038:	f7fa fada 	bl	80005f0 <__aeabi_dmul>
 800603c:	4602      	mov	r2, r0
 800603e:	460b      	mov	r3, r1
 8006040:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8006044:	f7fa f920 	bl	8000288 <__aeabi_dsub>
 8006048:	4652      	mov	r2, sl
 800604a:	465b      	mov	r3, fp
 800604c:	f7fa fad0 	bl	80005f0 <__aeabi_dmul>
 8006050:	e9dd 2300 	ldrd	r2, r3, [sp]
 8006054:	f7fa f918 	bl	8000288 <__aeabi_dsub>
 8006058:	a30f      	add	r3, pc, #60	; (adr r3, 8006098 <__kernel_sin+0x140>)
 800605a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800605e:	4606      	mov	r6, r0
 8006060:	460f      	mov	r7, r1
 8006062:	4640      	mov	r0, r8
 8006064:	4649      	mov	r1, r9
 8006066:	f7fa fac3 	bl	80005f0 <__aeabi_dmul>
 800606a:	4602      	mov	r2, r0
 800606c:	460b      	mov	r3, r1
 800606e:	4630      	mov	r0, r6
 8006070:	4639      	mov	r1, r7
 8006072:	f7fa f90b 	bl	800028c <__adddf3>
 8006076:	4602      	mov	r2, r0
 8006078:	460b      	mov	r3, r1
 800607a:	4620      	mov	r0, r4
 800607c:	4629      	mov	r1, r5
 800607e:	f7fa f903 	bl	8000288 <__aeabi_dsub>
 8006082:	e001      	b.n	8006088 <__kernel_sin+0x130>
 8006084:	4620      	mov	r0, r4
 8006086:	4629      	mov	r1, r5
 8006088:	ec41 0b10 	vmov	d0, r0, r1
 800608c:	b005      	add	sp, #20
 800608e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006092:	bf00      	nop
 8006094:	f3af 8000 	nop.w
 8006098:	55555549 	.word	0x55555549
 800609c:	3fc55555 	.word	0x3fc55555
 80060a0:	3fe00000 	.word	0x3fe00000
 80060a4:	5acfd57c 	.word	0x5acfd57c
 80060a8:	3de5d93a 	.word	0x3de5d93a
 80060ac:	8a2b9ceb 	.word	0x8a2b9ceb
 80060b0:	3e5ae5e6 	.word	0x3e5ae5e6
 80060b4:	57b1fe7d 	.word	0x57b1fe7d
 80060b8:	3ec71de3 	.word	0x3ec71de3
 80060bc:	19c161d5 	.word	0x19c161d5
 80060c0:	3f2a01a0 	.word	0x3f2a01a0
 80060c4:	1110f8a6 	.word	0x1110f8a6
 80060c8:	3f811111 	.word	0x3f811111

080060cc <fabs>:
 80060cc:	ec53 2b10 	vmov	r2, r3, d0
 80060d0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80060d4:	ec43 2b10 	vmov	d0, r2, r3
 80060d8:	4770      	bx	lr
 80060da:	0000      	movs	r0, r0
 80060dc:	0000      	movs	r0, r0
	...

080060e0 <floor>:
 80060e0:	ec51 0b10 	vmov	r0, r1, d0
 80060e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80060e8:	f3c1 570a 	ubfx	r7, r1, #20, #11
 80060ec:	f2a7 36ff 	subw	r6, r7, #1023	; 0x3ff
 80060f0:	2e13      	cmp	r6, #19
 80060f2:	ee10 8a10 	vmov	r8, s0
 80060f6:	460c      	mov	r4, r1
 80060f8:	ee10 5a10 	vmov	r5, s0
 80060fc:	dc33      	bgt.n	8006166 <floor+0x86>
 80060fe:	2e00      	cmp	r6, #0
 8006100:	da16      	bge.n	8006130 <floor+0x50>
 8006102:	a335      	add	r3, pc, #212	; (adr r3, 80061d8 <floor+0xf8>)
 8006104:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006108:	f7fa f8c0 	bl	800028c <__adddf3>
 800610c:	2200      	movs	r2, #0
 800610e:	2300      	movs	r3, #0
 8006110:	f7fa fcfe 	bl	8000b10 <__aeabi_dcmpgt>
 8006114:	2800      	cmp	r0, #0
 8006116:	d057      	beq.n	80061c8 <floor+0xe8>
 8006118:	2c00      	cmp	r4, #0
 800611a:	da53      	bge.n	80061c4 <floor+0xe4>
 800611c:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
 8006120:	ea53 0308 	orrs.w	r3, r3, r8
 8006124:	4b2e      	ldr	r3, [pc, #184]	; (80061e0 <floor+0x100>)
 8006126:	f04f 0500 	mov.w	r5, #0
 800612a:	bf18      	it	ne
 800612c:	461c      	movne	r4, r3
 800612e:	e04b      	b.n	80061c8 <floor+0xe8>
 8006130:	4f2c      	ldr	r7, [pc, #176]	; (80061e4 <floor+0x104>)
 8006132:	4137      	asrs	r7, r6
 8006134:	ea01 0307 	and.w	r3, r1, r7
 8006138:	4303      	orrs	r3, r0
 800613a:	d047      	beq.n	80061cc <floor+0xec>
 800613c:	a326      	add	r3, pc, #152	; (adr r3, 80061d8 <floor+0xf8>)
 800613e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006142:	f7fa f8a3 	bl	800028c <__adddf3>
 8006146:	2200      	movs	r2, #0
 8006148:	2300      	movs	r3, #0
 800614a:	f7fa fce1 	bl	8000b10 <__aeabi_dcmpgt>
 800614e:	b3d8      	cbz	r0, 80061c8 <floor+0xe8>
 8006150:	2c00      	cmp	r4, #0
 8006152:	bfbe      	ittt	lt
 8006154:	f44f 1380 	movlt.w	r3, #1048576	; 0x100000
 8006158:	fa43 f606 	asrlt.w	r6, r3, r6
 800615c:	19a4      	addlt	r4, r4, r6
 800615e:	ea24 0407 	bic.w	r4, r4, r7
 8006162:	2500      	movs	r5, #0
 8006164:	e030      	b.n	80061c8 <floor+0xe8>
 8006166:	2e33      	cmp	r6, #51	; 0x33
 8006168:	dd08      	ble.n	800617c <floor+0x9c>
 800616a:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 800616e:	d12d      	bne.n	80061cc <floor+0xec>
 8006170:	ee10 2a10 	vmov	r2, s0
 8006174:	460b      	mov	r3, r1
 8006176:	f7fa f889 	bl	800028c <__adddf3>
 800617a:	e027      	b.n	80061cc <floor+0xec>
 800617c:	f2a7 4713 	subw	r7, r7, #1043	; 0x413
 8006180:	f04f 33ff 	mov.w	r3, #4294967295
 8006184:	fa23 f707 	lsr.w	r7, r3, r7
 8006188:	4238      	tst	r0, r7
 800618a:	d01f      	beq.n	80061cc <floor+0xec>
 800618c:	a312      	add	r3, pc, #72	; (adr r3, 80061d8 <floor+0xf8>)
 800618e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006192:	f7fa f87b 	bl	800028c <__adddf3>
 8006196:	2200      	movs	r2, #0
 8006198:	2300      	movs	r3, #0
 800619a:	f7fa fcb9 	bl	8000b10 <__aeabi_dcmpgt>
 800619e:	b198      	cbz	r0, 80061c8 <floor+0xe8>
 80061a0:	2c00      	cmp	r4, #0
 80061a2:	da0c      	bge.n	80061be <floor+0xde>
 80061a4:	2e14      	cmp	r6, #20
 80061a6:	d101      	bne.n	80061ac <floor+0xcc>
 80061a8:	3401      	adds	r4, #1
 80061aa:	e008      	b.n	80061be <floor+0xde>
 80061ac:	2301      	movs	r3, #1
 80061ae:	f1c6 0634 	rsb	r6, r6, #52	; 0x34
 80061b2:	fa03 f606 	lsl.w	r6, r3, r6
 80061b6:	4435      	add	r5, r6
 80061b8:	45a8      	cmp	r8, r5
 80061ba:	bf88      	it	hi
 80061bc:	18e4      	addhi	r4, r4, r3
 80061be:	ea25 0507 	bic.w	r5, r5, r7
 80061c2:	e001      	b.n	80061c8 <floor+0xe8>
 80061c4:	2500      	movs	r5, #0
 80061c6:	462c      	mov	r4, r5
 80061c8:	4621      	mov	r1, r4
 80061ca:	4628      	mov	r0, r5
 80061cc:	ec41 0b10 	vmov	d0, r0, r1
 80061d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80061d4:	f3af 8000 	nop.w
 80061d8:	8800759c 	.word	0x8800759c
 80061dc:	7e37e43c 	.word	0x7e37e43c
 80061e0:	bff00000 	.word	0xbff00000
 80061e4:	000fffff 	.word	0x000fffff

080061e8 <scalbn>:
 80061e8:	b570      	push	{r4, r5, r6, lr}
 80061ea:	ec55 4b10 	vmov	r4, r5, d0
 80061ee:	f3c5 520a 	ubfx	r2, r5, #20, #11
 80061f2:	4606      	mov	r6, r0
 80061f4:	462b      	mov	r3, r5
 80061f6:	b9a2      	cbnz	r2, 8006222 <scalbn+0x3a>
 80061f8:	f025 4300 	bic.w	r3, r5, #2147483648	; 0x80000000
 80061fc:	4323      	orrs	r3, r4
 80061fe:	d059      	beq.n	80062b4 <scalbn+0xcc>
 8006200:	2200      	movs	r2, #0
 8006202:	4b33      	ldr	r3, [pc, #204]	; (80062d0 <scalbn+0xe8>)
 8006204:	4629      	mov	r1, r5
 8006206:	ee10 0a10 	vmov	r0, s0
 800620a:	f7fa f9f1 	bl	80005f0 <__aeabi_dmul>
 800620e:	4a31      	ldr	r2, [pc, #196]	; (80062d4 <scalbn+0xec>)
 8006210:	4296      	cmp	r6, r2
 8006212:	4604      	mov	r4, r0
 8006214:	460d      	mov	r5, r1
 8006216:	460b      	mov	r3, r1
 8006218:	da0f      	bge.n	800623a <scalbn+0x52>
 800621a:	a329      	add	r3, pc, #164	; (adr r3, 80062c0 <scalbn+0xd8>)
 800621c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006220:	e045      	b.n	80062ae <scalbn+0xc6>
 8006222:	f240 71ff 	movw	r1, #2047	; 0x7ff
 8006226:	428a      	cmp	r2, r1
 8006228:	d10a      	bne.n	8006240 <scalbn+0x58>
 800622a:	ee10 2a10 	vmov	r2, s0
 800622e:	462b      	mov	r3, r5
 8006230:	4620      	mov	r0, r4
 8006232:	4629      	mov	r1, r5
 8006234:	f7fa f82a 	bl	800028c <__adddf3>
 8006238:	e03e      	b.n	80062b8 <scalbn+0xd0>
 800623a:	f3c1 520a 	ubfx	r2, r1, #20, #11
 800623e:	3a36      	subs	r2, #54	; 0x36
 8006240:	4432      	add	r2, r6
 8006242:	f240 71fe 	movw	r1, #2046	; 0x7fe
 8006246:	428a      	cmp	r2, r1
 8006248:	dd02      	ble.n	8006250 <scalbn+0x68>
 800624a:	ec45 4b11 	vmov	d1, r4, r5
 800624e:	e011      	b.n	8006274 <scalbn+0x8c>
 8006250:	2a00      	cmp	r2, #0
 8006252:	dd06      	ble.n	8006262 <scalbn+0x7a>
 8006254:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 8006258:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 800625c:	ea43 5502 	orr.w	r5, r3, r2, lsl #20
 8006260:	e028      	b.n	80062b4 <scalbn+0xcc>
 8006262:	f112 0f35 	cmn.w	r2, #53	; 0x35
 8006266:	da17      	bge.n	8006298 <scalbn+0xb0>
 8006268:	f24c 3350 	movw	r3, #50000	; 0xc350
 800626c:	429e      	cmp	r6, r3
 800626e:	ec45 4b11 	vmov	d1, r4, r5
 8006272:	dd07      	ble.n	8006284 <scalbn+0x9c>
 8006274:	ed9f 0b14 	vldr	d0, [pc, #80]	; 80062c8 <scalbn+0xe0>
 8006278:	f000 f830 	bl	80062dc <copysign>
 800627c:	a312      	add	r3, pc, #72	; (adr r3, 80062c8 <scalbn+0xe0>)
 800627e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006282:	e006      	b.n	8006292 <scalbn+0xaa>
 8006284:	ed9f 0b0e 	vldr	d0, [pc, #56]	; 80062c0 <scalbn+0xd8>
 8006288:	f000 f828 	bl	80062dc <copysign>
 800628c:	a30c      	add	r3, pc, #48	; (adr r3, 80062c0 <scalbn+0xd8>)
 800628e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006292:	ec51 0b10 	vmov	r0, r1, d0
 8006296:	e00a      	b.n	80062ae <scalbn+0xc6>
 8006298:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 800629c:	3236      	adds	r2, #54	; 0x36
 800629e:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 80062a2:	ea43 5502 	orr.w	r5, r3, r2, lsl #20
 80062a6:	4b0c      	ldr	r3, [pc, #48]	; (80062d8 <scalbn+0xf0>)
 80062a8:	4620      	mov	r0, r4
 80062aa:	4629      	mov	r1, r5
 80062ac:	2200      	movs	r2, #0
 80062ae:	f7fa f99f 	bl	80005f0 <__aeabi_dmul>
 80062b2:	e001      	b.n	80062b8 <scalbn+0xd0>
 80062b4:	4620      	mov	r0, r4
 80062b6:	4629      	mov	r1, r5
 80062b8:	ec41 0b10 	vmov	d0, r0, r1
 80062bc:	bd70      	pop	{r4, r5, r6, pc}
 80062be:	bf00      	nop
 80062c0:	c2f8f359 	.word	0xc2f8f359
 80062c4:	01a56e1f 	.word	0x01a56e1f
 80062c8:	8800759c 	.word	0x8800759c
 80062cc:	7e37e43c 	.word	0x7e37e43c
 80062d0:	43500000 	.word	0x43500000
 80062d4:	ffff3cb0 	.word	0xffff3cb0
 80062d8:	3c900000 	.word	0x3c900000

080062dc <copysign>:
 80062dc:	ec53 2b10 	vmov	r2, r3, d0
 80062e0:	ee11 0a90 	vmov	r0, s3
 80062e4:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 80062e8:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80062ec:	ea41 0300 	orr.w	r3, r1, r0
 80062f0:	ec43 2b10 	vmov	d0, r2, r3
 80062f4:	4770      	bx	lr
	...

080062f8 <_init>:
 80062f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80062fa:	bf00      	nop
 80062fc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80062fe:	bc08      	pop	{r3}
 8006300:	469e      	mov	lr, r3
 8006302:	4770      	bx	lr

08006304 <_fini>:
 8006304:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006306:	bf00      	nop
 8006308:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800630a:	bc08      	pop	{r3}
 800630c:	469e      	mov	lr, r3
 800630e:	4770      	bx	lr
